/**
 * @dmbdoc Directive
 * @name dmbButton
 * @description Will render a button
 * @attribute type posible values: submit
 */
class DmbButton extends DumboDirective {
    constructor() {
        super();
    }

    _submitter(e) {
        const form = e.target.closest('dmb-form');
        const type = e.target.getAttribute('type');

        if (form) {
            switch (type) {
            case 'submit':
                form.submit();
                break;
            case 'reset':
                form.reset();
                break;
            }
        }
    }

    init() {
        this.addEventListener('click', this._submitter);
    }
    /**
     * Attach a method to run when event click is fired.
     * @param {function} method
     */
    click(method) {
        if (typeof method === 'function') {
            this.removeEventListener('click', this._submitter);
            this.addEventListener('click', method);
        }
    }
}
customElements.define('dmb-button', DmbButton);
class DmbClosePanel extends DumboDirective {
    constructor() {
        super();

        const template = '<i class="icon"></i>';
        
        this.setTemplate(template);
    }
    
    init() {
        const orientation = this.getAttribute('orientation') || 'right';
        const icon = this.querySelector('i.icon');
        let panel = null;

        this.classList.add(orientation);
        icon.classList.add(`icon-chevron-${orientation}`);


        this.addEventListener('click', () => {
            panel = this.closest('dmb-panel');
            panel.close();
        });
    }
}

customElements.define('dmb-close-panel', DmbClosePanel);

/**
 * 
 */
class DmbContent extends DumboDirective {
    constructor() {
        super();
    }
}
customElements.define('dmb-content', DmbContent);


class DmbDialog extends DumboDirective {
    static get observedAttributes() { return ['open']; }

    constructor() {
        super();

        const template = '<dmb-view class="wrapper" transclude>' +
                        '</dmb-view>';

        this.setTemplate(template);
        this.returnValue = null;
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        this.openValue = (newValue !== null);
    }

    close(value) {
        this.returnValue = value;
        this.removeAttribute('open');
        this.dispatchEvent(new Event('close'));
        (this.localName === 'dmb-dialog') && this.remove();
        this.dispatchEvent(new Event('close-dialog'));
        return true;
    }

    open() {
        this.hasAttribute('open') || this.setAttribute('open','');
        this.dispatchEvent(window.DmbEvents.dialogOpen.event);
    }

    showModal() {
        const buttons = this.querySelectorAll('[type="modal-answer"]');

        [].forEach.call(buttons, button => {
            button.addEventListener('click', e => {
                this.close(e.target.getAttribute('value'));
            });
        });
        this.open();
    }

    init() {
        let delay = 1000 * this.getAttribute('delay');
        this.hasAttribute('no-close') || this.setCloseButton();

        setTimeout(() => {
            this.open();
        }, delay);
    }

    setCloseButton() {
        let icon = null;

        if (!this.classList.contains('loader')) {
            icon = this.querySelector('.close-modal-button');
            if(!icon || !icon.length) {
                icon = document.createElement('i');
                icon.classList.add('icon');
                icon.classList.add('icon-cancel');
                icon.classList.add('close-modal-button');
                this.querySelector('.wrapper').prepend(icon);
                icon.addEventListener('click', (e) => {
                    e.target.closest('dmb-dialog').close('cancelled');
                });
            }
        }
    }

    isOpen() {
        return this.openValue;
    }

    setIcon(icon) {
        const iconElement = document.createElement('i');
        const wrapper = this.querySelector('.wrapper');

        iconElement.classList.add('icon');
        iconElement.classList.add(`icon-${icon}`);

        wrapper.prepend(iconElement);
    }

    error(msg) {
        const message = document.createElement('span');
        const wrapper = this.querySelector('.wrapper');

        this.setIcon('alert');
        msg = msg || '';
        this.classList.add('error');
        message.classList.add('message');
        if (typeof msg === 'string') {
            message.innerHTML = msg;
        } else {
            message.append(msg);
        }
        wrapper.append(message);
    }

    info(msg) {
        const message = document.createElement('span');
        const wrapper = this.querySelector('.wrapper');

        this.setCloseButton();
        this.setIcon('info');
        msg = msg || '';
        this.classList.add('info');
        message.classList.add('message');
        if (typeof msg === 'string') {
            message.innerHTML = msg;
        } else {
            message.append(msg);
        }
        wrapper.append(message);
    }

    prompt(options) {
        const message = document.createElement('span');
        const wrapper = this.querySelector('.wrapper');
        let msg = options.message || '';

        this.classList.add('question');
        message.classList.add('message');
        if (typeof msg === 'string') {
            message.innerHTML = msg;
        } else {
            message.append(msg);
        }
        wrapper.append(message);
    }

    onClose(fn) {
        if (typeof fn === 'function') {
            this.addEventListener('close-dialog', fn);
        }
    }
}
customElements.define('dmb-dialog', DmbDialog);
class DmbFooter extends DumboDirective {
    constructor() {
        super();
    }
    
    init() {
        const dmbview = this.parentNode.querySelector('dmb-content');

        if(dmbview) {
            dmbview.classList.add('padded-footer');
        }
    }
}

customElements.define('dmb-footer', DmbFooter);
class DmbForm extends DumboDirective {
    constructor() {
        super();
        this._valids = 0;

        this.setTemplate('<form arial-role="form" transclude></form>');
        this.form = null;
        this.callback = this.callback || null;
    }

    get valids() {
        return this._valids;
    }

    init() {
        let inputs = null;
        let item = null;

        this.form = this.querySelector('form');

        this.form.setAttribute('method', this.getAttribute('method') || 'POST');
        this.form.setAttribute('action', this.getAttribute('action') || '#');
        this.form.setAttribute('autocomplete', this.getAttribute('autocomplete') || 'on');
        this.form.setAttribute('name', this.getAttribute('dmb-name') || '');
        this.form.setAttribute('target', this.getAttribute('target') || '');
        this.form.setAttribute('id', this.getAttribute('dmb-id') || this.generateId());
        this.form.setAttribute('enctype', this.getAttribute('enctype') || 'application/x-www-form-urlencoded');

        inputs = [...this.querySelectorAll('input:not([type="submit"])')];
        if (this.querySelector('input[type="submit"]') === null || inputs.length > 1) {
            while ((item = inputs.shift())) {
                item.addEventListener('keypress', e => {
                    if (13 === e.keyCode) {
                        this.submit();
                    }
                });
            }
        }
    }

    reset() {
        this.form.reset();
    }

    validate(formElements, parentSelector) {
        let item = null;
        let hasInvalids = false;

        formElements.forEach(element => {
            element.closest(parentSelector).resetValidation();
        });

        this.dispatchEvent(window.DmbEvents.formBeforeValidate.event);
        while ((item = formElements.shift())) {
            if (item.closest('.novalidate') === null) {
                item.closest(parentSelector).setValidation();

                if (!item.hasAttribute('valid') && !item.hasAttribute('hidden')) {
                    item.reportValidity();
                    item.focus();
                    hasInvalids = true;
                } else {
                    this._valids++;
                }
            }
        }

        this.dispatchEvent(window.DmbEvents.formAfterValidate.event);

        return !hasInvalids;
    }

    submit() {
        this.dispatchEvent(window.DmbEvents.formSubmit.event);
        const inputs = [...this.querySelectorAll('dmb-input[validate] input')];
        const selects = [...this.querySelectorAll('dmb-select[validate] select')];
        const textAreas = [...this.querySelectorAll('dmb-text-area[validate] textarea')];
        const isAsync = this.hasAttribute('async');
        const form = this.querySelector('form');
        let totalvalidations = 0;

        this._valids = 0;
        totalvalidations = this.validate(inputs, 'dmb-input') + this.validate(selects, 'dmb-select') + this.validate(textAreas, 'dmb-text-area');

        if (totalvalidations === 3) {

            if (isAsync) {
                if(typeof this.callback === 'function') {
                    this.callback(this);
                }
                return false;
            } else {
                form.submit();
            }

            return true;
        }

        return false;
    }

    getFormData() {
        return new FormData(this.form);
    }
}

customElements.define('dmb-form', DmbForm);
class DmbHeader extends DumboDirective {
    constructor() {
        super();
    }

    init() {
        let titleDOM = null;

        if (this.title) {
            titleDOM = document.createElement('h2');
            titleDOM.classList.add('dmb-header-title');
            titleDOM.textContent = this.title;
            
            this.prepend(titleDOM);
        }
    }
}

customElements.define('dmb-header', DmbHeader);
/**
 * Component handle Imageloader
 * Get the elements of principal issues, and sub issues
 */ 

class DmbImageUploader extends DumboDirective {
    constructor() {
        super();

        /**
        * Creation of html
        */
        const template = '<dmb-input type="file" dmb-name="imgfile" accept="image/*"></dmb-input>' +
                         '<div class="preview"><img /></div>';

        this.setTemplate(template);
    }

    init() {
        /*
        * Get elements HTML and assing to a var
        */
        const dmbimgInput = this.querySelector('dmb-input[type="file"]');
        const imgInput = dmbimgInput.querySelector('input[type="file"]');
        const previewimg = this.querySelector('.preview img');
        
        previewimg.setAttribute('alt', this.getAttribute('img-alt') || 'Image Preview');
        this.hasAttribute('validate') && dmbimgInput.setAttribute('validate', this.getAttribute('validate'));
        this.hasAttribute('dmb-name') && dmbimgInput.setAttribute('dmb-name', this.getAttribute('dmb-name'));
        this.hasAttribute('label') && dmbimgInput.setAttribute('label', this.getAttribute('label'));
        /**
         * Check when the event change in Select Item, and create the options for display
         */
        imgInput.addEventListener('change', e => {
            this.loadFile(e.target.files[0]);
        });
    }

    loadFile (file) {
        const previewimg = this.querySelector('.preview img');
        const reader = new FileReader();
        const promise = new Promise((resolve) => {
            reader.onload = () => {
                resolve();
                previewimg.setAttribute('src', reader.result.toString());
            };
        });
        reader.readAsDataURL(file);
        return promise;
    }
}

customElements.define('dmb-image-uploader', DmbImageUploader);
class DmbInfoPop extends DumboDirective {
    constructor() {
        super();

        const template = '<div class="float-content" transclude></div>';
        
        this.setTemplate(template);
    }

    init() {
        const size = this.getAttribute('size') || 'small';

        this.querySelector('.float-content').classList.add(`float-content_${size}`);
    }

}

customElements.define('dmb-info-pop', DmbInfoPop);
class DmbInput extends DumboDirective {
    static get observedAttributes() { return ['valid','name', 'validate', 'dmb-name', 'label']; }

    constructor() {
        super();

        const template = '<label></label>' +
                        '<input type="text" placeholder="" />';

        this.setTemplate(template);
        this.isValid = false;
        this._errorInputClass = '_error';
        this.validations = {
            _required: function (value, param, input) {
                let response = {
                    valid: true,
                    error: null
                };
                param = null;

                if (typeof value === 'undefined' || value === null || value === '' || (input.getAttribute('type') === 'checkbox' && !input.checked)) {
                    response.valid = false;
                }

                return response;
            },
            _email: function (value) {
                let response = {
                        valid: true,
                        error: null
                    },
                    re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/;

                if (value && !re.test(value)) {
                    response.valid = false;
                }

                return response;
            },
            _numeric: function (value) {
                let response = {
                        valid: true,
                        error: null
                    },
                    re = /^[0-9]\d*/;

                if (value && !re.test(value)) {
                    response.valid = false;
                }

                return response;
            },
            _min: function(value, param) {
                let response = {
                    valid: true,
                    error: null
                };

                if (value && value.length < param) {
                    response.valid = false;
                }

                return response;
            },
            _max: function(value, param) {
                let response = {
                    valid: true,
                    error: null
                };

                if (value && value.length > param) {
                    response.valid = false;
                }

                return response;
            }
        };
    }

    set value(val) {
        const input = this.querySelector('input');
        input.value = val;
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        const input = this.querySelector('input');

        switch(attr) {
        case 'valid':
            this.isValid = (newValue !== null);
            break;
        case 'name':
        case 'dmb-name':
            if (input) input.setAttribute('name', newValue);
            break;
        case 'validate':
            this.buildValidators();
            break;
        case 'label':
            if (input) {
                this.querySelector('label').innerText = newValue;
                input.setAttribute('aria-label', newValue);
                input.setAttribute('placeholder', newValue);
            }
            break;
        }
    }

    buildValidators () {
        let validators = [];
        let validatorList = (this.getAttribute('validate') || '').split(',');
        const input = this.querySelector('input');

        for (let i = 0, len = validatorList.length; i < len; i++) {
            let keyParam = validatorList[i].split(':');

            if (keyParam[0]) {
                validators.push({
                    key: keyParam[0],
                    param: keyParam.length === 2 ? keyParam[1] : null,
                    input
                });

                if (keyParam[0] === 'required' && input) {
                    this.classList.add('required');
                    input.setAttribute('required','required');
                }
            }
        }

        return validators;
    }

    _runValidators(element, validators) {
        const unknownValidator = () => {
            return {valid: false, error: 'Unknown validator type: "' + (validator || {}).key + '"'};
        };
        const type = element.getAttribute('type');
        let content = element.value.trim();
        let valid = true;
        let validator= null;
        let func = null;
        let result = null;

        if (type !== 'file') element.value = content;
        while((validator = validators.shift())) {
            func = this.validations['_' + validator.key] || unknownValidator;

            result = func(content, validator.param, validator.input);
            if (result.valid !== true) {
                valid = false;
                break;
            }
        }

        if (valid === true) {
            element.parentNode.classList.remove(this._errorInputClass);
        } else {
            element.parentNode.classList.add(this._errorInputClass);
        }

        this.isValid = valid;
        valid? element.setAttribute('valid','') : element.removeAttribute('valid');
    }

    resetValidation() {
        let elements = this.getElementsByClassName(this._errorInputClass);
        for (let i = 0; elements.length; i++) {
            elements.item(0).classList.remove(this._errorInputClass);
        }
    }

    setValidation() {
        this._runValidators(this.querySelector('input'), this.buildValidators());
    }

    init() {
        const input = this.querySelector('input');
        const labelElement = this.querySelector('label');
        const label = this.getAttribute('label') || null;
        const placeholder = this.getAttribute('placeholder') || label;
        const masked = this.getAttribute('masked') || null;
        const autocomplete = this.getAttribute('autocomplete') || null;
        const classd = this.getAttribute('dmb-class') || null;
        const name = this.getAttribute('dmb-name') || null;
        const validate = this.getAttribute('validate') || null;
        const pattern = this.getAttribute('pattern') || null;
        const value = this.getAttribute('value') || this.getAttribute('dmb-value') || null;
        const step = this.getAttribute('step') || null;
        const type = this.getAttribute('type') || 'text';
        const checked = this.hasAttribute('checked');

        input.id = this.getAttribute('dmb-id') || this.generateId();
        input.setAttribute('type', type);

        if (label) {
            this.querySelector('label').innerText = label;
            input.setAttribute('aria-label', label);
        }
        if (placeholder) {
            input.setAttribute('placeholder', placeholder);
        }
        if (labelElement) {
            labelElement.setAttribute('for', input.id);
        }

        if (type === 'checkbox') {
            this.insertBefore(input, labelElement);
            if (checked) {
                input.setAttribute('checked', 'on');
            }
        }

        if (masked) input.setAttribute('masked', masked);
        if (autocomplete) input.setAttribute('autocomplete', autocomplete);
        if (classd) input.setAttribute('class', classd);
        if (name) input.setAttribute('name', name);
        if (validate) input.setAttribute('validate', validate);
        if (pattern) input.setAttribute('pattern', pattern);
        if (value) input.value = value;
        if (step) input.setAttribute('step', step);

        type === 'file' && this.hasAttribute('accept') && input.setAttribute('accept', this.getAttribute('accept'));

        const maskInputUppercase = (e) => {
            e.target.value = e.target.value.toUpperCase();
        };

        const maskInputAlpha = (e) => {
            const char = e.which || e.keyCode;

            if ((char < 65 || char > 90) && (char < 97 || char > 122)) {
                return false;
            }
        };

        const maskInputNumeric = (e) => {
            const char = e.which || e.keyCode;

            if (char < 48 || char > 57) {
                return false;
            }
        };

        if (this.getAttribute('masked')) {
            switch (this.getAttribute('masked')) {
            case 'alpha':
                input.onkeypress = maskInputAlpha;
                break;
            case 'numeric':
                input.onkeypress = maskInputNumeric;
                break;
            case 'uppercase':
                input.oninput = maskInputUppercase;
                break;
            }
        }

        this.buildValidators();

        input.addEventListener('blur', () => {
            this.setValidation();
        }, true);
    }
}

customElements.define('dmb-input', DmbInput);

class DmbMenuButton extends DumboDirective {
    constructor() {
        super();
        
        let template = '<i class="icon icon-bars"></i>' +
                        '<span class="legend" transclude></span>';

        this.setTemplate(template);

    }
    
    init() {
        this.addEventListener('click', () => {
            let menu = this.getAttribute('menu');
    
            if (menu.length) {
                document.querySelector(menu).showModal();
            }
        });
    }
}

customElements.define('dmb-menu-button',DmbMenuButton);

class DmbPageLoader extends DumboDirective {
    constructor() {
        super();

        window.addEventListener('beforeunload', () => {
            this.classList.add('active');
        });

        document.addEventListener('readystatechange', () => setTimeout(
            () => {
                (document.readyState === 'complete') && this.classList.contains('active') && this.close();
            }, 100
        ));

        document.addEventListener('DOMContentLoaded', () => setTimeout(
            () => {
                this.classList.contains('active') && this.close();
            }, 100
        ));

        window.addEventListener(window.DmbEvents.pageLoaderClose.listener, () => this.close());
        window.addEventListener('load', () => this.close());
    }

    open() {
        !this.classList.contains('active') && this.classList.add('active');
        return true;
    }

    close() {
        this.classList.contains('active') && this.classList.remove('active');
        return true;
    }

}
customElements.define('dmb-page-loader', DmbPageLoader);

class DmbPagination extends DumboDirective {
    constructor() {
        super();
    }

    init() {
        const formTarget = this.getAttribute('filter-form') || '';
        let form = null;

        this.addEventListener('click', e => {
            const target = e.target;
            const classes = target.getAttribute('class');

            if(formTarget) {
                form = document.querySelector(formTarget);
            }

            if (/paginate-page(-\w+)?/gm.test(classes)) {
                if (form) {
                    e.preventDefault();
                    form.setAttribute('action', e.target.getAttribute('href'));
                    form.submit();
                }
            }
        });
    }
}

customElements.define('dmb-pagination', DmbPagination);

class DmbPanel extends DumboDirective {
    static get observedAttributes() { return ['source']; }

    constructor() {
        super();
        const template = '<dmb-view class="wrapper" transclude>' +
                        '</dmb-view>';

        this.setTemplate(template);
        this.returnValue = null;
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        !!newValue && newValue.length && this.loadExternalSource();
    }

    loadExternalSource() {
        const url = this.getAttribute('source');
        let wrapper = null;
        let sourceRequest = null;

        if (url && url.length) {
            sourceRequest = new Request(url);
            fetch(sourceRequest)
                .then(res => res.text())
                .then(data => {
                    wrapper = this.querySelector('.wrapper');
                    wrapper.innerHTML = data;
                });
        }

        return true;
    }

    close(value) {
        this.returnValue = value;
        this.removeAttribute('open');
        this.dispatchEvent(window.DmbEvents.panelClose.event);
        (this.localName === 'dmb-dialog') && this.remove();
        this.dispatchEvent(window.DmbEvents.dialogClose.event);
    }

    open() {
        this.setAttribute('open','');
        this.dispatchEvent(window.DmbEvents.panelOpened.event);
        this.addEventListener('click', (e) => {
            if (this.openValue && e.target === this) {
                this.close('cancelled');
            }
        },true);
    }

    showModal() {
        const buttons = this.querySelectorAll('[type="modal-answer"]');

        [].forEach.call(buttons, button => {
            button.addEventListener('click', e => {
                this.close(e.target.getAttribute('value'));
            });
        });
        this.open();
    }

    setCloseButton() {
        let icon = null;

        if (!this.classList.contains('loader')) {
            icon = document.createElement('i');
            icon.classList.add('icon');
            icon.classList.add('icon-cancel');
            icon.classList.add('close-modal-button');
            icon.addEventListener('click', (e) => {
                e.target.closest('dmb-dialog').close('cancelled');
            });
            this.querySelector('.wrapper').prepend(icon);
        }
    }

    isOpen() {
        return this.openValue;
    }

    setIcon(icon) {
        const iconElement = document.createElement('i');
        const wrapper = this.querySelector('.wrapper');

        iconElement.classList.add('icon');
        iconElement.classList.add(`icon-${icon}`);

        wrapper.prepend(iconElement);
    }

    error(msg) {
        const message = document.createElement('span');
        const wrapper = this.querySelector('.wrapper');

        this.setCloseButton();
        this.setIcon('alert');
        msg = msg || '';
        this.classList.add('error');
        message.classList.add('message');
        message.textContent = msg;
        wrapper.append(message);
    }

    prompt(options) {
        const message = document.createElement('span');
        const wrapper = this.querySelector('.wrapper');
        let msg = options.message || '';

        this.classList.add('question');
        message.classList.add('message');
        message.textContent = msg;
        wrapper.append(message);
    }

    onClose(fn) {
        if (typeof fn === 'function') {
            this.addEventListener('close-panel', fn);
        }
    }

    init() {
        !this.classList.contains('right') && !this.classList.contains('left') && this.classList.add('right');
        !this.classList.contains('small') && !this.classList.contains('large') && this.classList.add('small');

        this.addEventListener('click', (e) => {
            e.target === this && this.close('cancelled');
        }, true);

        this.loadExternalSource();
    }
}

customElements.define('dmb-panel', DmbPanel);
class DmbSelect extends DumboDirective {
    static get observedAttributes() { 
        return [
            'valid','values', 'dmb-name', 'label', 'dmb-class', 'validate', 'dmb-value'
        ]; 
    }

    constructor() {
        super();

        const template = '<label></label>' +
                        '<select transclude></select>';

        this.setTemplate(template);
        this.validations = {
            _required: value => {
                let response = {
                    valid: true,
                    error: null
                };

                if (typeof value === 'undefined' || value === null || value === '') {
                    response.valid = false;
                    response.error = '';
                }

                return response;
            }
        };
        this.isValid = false;
        this.valueList = [];
        this.validators = [];
        this._errorInputClass = '_error';
    }

    set values(newValues = []) {
        this.valueList = newValues;
        this.buildOptions();
    }

    init() {
        const select = this.querySelector('select');
        let value = null;
        let options = null;
        let option = null;
        let opval = null;

        this.hasAttribute('label') && (this.querySelector('label').innerText = this.getAttribute('label'));
        this.hasAttribute('label') && select.setAttribute('aria-label',this.getAttribute('label'));
        this.hasAttribute('dmb-class') && select.setAttribute('class', this.getAttribute('dmb-class'));
        select.setAttribute('name', this.getAttribute('dmb-name') || '');
        this.hasAttribute('validate') && select.setAttribute('validate',this.getAttribute('validate'));
        select.id = this.getAttribute('dmb-id') || this.generateId();
        select.multiple = this.hasAttribute('multiple');

        if (this.hasAttribute('dmb-value')) {
            value = this.getAttribute('dmb-value').trim();
            value = select.multiple ? JSON.parse(value) : value;
        }

        if (select && this.getAttribute('validate')) {
            this.validators = this.buildValidators(select, this.getAttribute('validate'));
        }

        select.addEventListener('blur', (e) => {
            this._runValidators(e.target, this.validators);
        }, {capture: true, passive: true});

        options = [...select.querySelectorAll('option')];
        if(options.length){
            while((option = options.shift())) {
                option.value = (option.getAttribute('value') || '').trim();
                opval = isNaN(option.value) ? option.value : parseInt(option.value);
                value = isNaN(value) ? value : parseInt(value);

                if ((!option.hasAttribute('selected') && (opval && opval == value)) || (Array.isArray(value) && value.includes(opval))) {
                    option.setAttribute('selected',true);
                    option.selected = true;
                }

            }
        }
    }

    _runValidators(element, validators) {
        let unknownValidator = () => {
            return {valid: false, error: 'Unknown validator type: "' + (validator || {}).key + '"'};
        };
        let options = element.querySelectorAll('option');
        let content = [...options].filter(x=>x.selected).map(x=>x.value.trim() || '');
        let valid = true;
        let validator= null;
        let func = null;
        let result = null;

        !element.multiple && (content = content[0]);
        for (var i = 0, len = validators.length; i < len; i++) {
            validator = validators[i];
            func = this.validations['_' + validator.key] || unknownValidator;

            result = func(content, validator.param);
            if (result.valid !== true) {
                valid = false;
                break;
            }
        }

        if (valid === true) {
            element.parentNode.classList.remove(this._errorInputClass);
        } else {
            element.parentNode.classList.add(this._errorInputClass);
        }
        this.isValid = valid;
        valid? element.setAttribute('valid','') : element.removeAttribute('valid');
    }

    buildValidators(element, validations) {
        let validators = [];
        let validatorList = (validations || '').split(',');
        let keyParam = '';

        for (let i = 0, len = validatorList.length; i < len; i++) {
            keyParam = validatorList[i].split(':');

            if (keyParam[0]) {
                validators.push({
                    key: keyParam[0],
                    param: keyParam.length === 2 ? keyParam[1] : null
                });

                if (keyParam[0] === 'required') {
                    element.parentNode.classList.add('required');
                    element.setAttribute('required',true);
                }
            }
        }

        return validators;
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        const select = this.querySelector('select');
        const label = this.querySelector('label');

        switch(attr) {
        case 'valid':
            this.isValid = (newValue !== null);
            break;
        case 'values':
            if (!oldValue && newValue) {
                this.valueList = JSON.parse(newValue);
                this.buildOptions();
            }
            break;
        case 'dmb-name':
            if (select) select.setAttribute('name', newValue);
            break;
        case 'validate':
            if (select) this.validators = this.buildValidators(select, newValue);
            break;
        case 'dmb-value':
            if (!oldValue && newValue && select) {
                this.buildOptions();
            }
            break;
        case 'label':
            if (label) label.innerText = newValue;
            break;
        }

    }

    buildOptions() {
        let i = 0;
        let total = this.valueList.length || 0;
        let option = null;
        let value = this.getAttribute('dmb-value') || null;
        const select = this.querySelector('select');

        if (select) {
            select.innerHTML = '';
            select.multiple && value && (value = JSON.parse(value));
    
            for (i = 0; i < total; i++) {
                option = document.createElement('option');
                option.value, this.valueList[i].value;
                option.setAttribute('value',this.valueList[i].value);
                option.innerHTML = this.valueList[i].text;
                
                if (this.valueList[i].selected || (option.value.length && option.value == value) || (Array.isArray(value) && value.includes(option.value))) {
                    option.setAttribute('selected',true);
                    option.selected = true;
                }
                select.append(option);
            }
        }

        this.removeAttribute('values');
    }

    resetValidation() {
        let elements = [...this.querySelectorAll(this._errorInputClass)];
        let element = null;

        while ((element = elements.shift())) {
            element.classList.remove(this._errorInputClass);
        }
    }

    setValidation() {
        this._runValidators(this.querySelector('select'), this.validators);
    }
}

customElements.define('dmb-select', DmbSelect);
class DmbTextArea extends DumboDirective {
    static get observedAttributes() { return ['valid','name', 'validate', 'dmb-name']; }

    constructor() {
        super();

        const template = '<label></label>' +
                        '<textarea transclude>' +
                        '</textarea>';

        this.setTemplate(template);
        this.isValid = false;
        this.validators = [];
        this._errorInputClass = '_error';
        this.validations = {
            _required: function (value) {
                let response = {
                    valid: true,
                    error: null
                };

                if (typeof value === 'undefined' || value === null || value === '') {
                    response.valid = false;
                }

                return response;
            },
            _numeric: function (value) {
                let response = {
                        valid: true,
                        error: null
                    },
                    re = /^[0-9]\d*/;

                if (value && !re.test(value)) {
                    response.valid = false;
                }

                return response;
            },
            _min: function(value, param) {
                let response = {
                    valid: true,
                    error: null
                };

                if (value && value.length < param) {
                    response.valid = false;
                }

                return response;
            },
            _max: function(value, param) {
                let response = {
                    valid: true,
                    error: null
                };

                if (value && value.length > param) {
                    response.valid = false;
                }

                return response;
            }
        };
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        const input = this.querySelector('textarea');

        switch(attr) {
        case 'valid':
            this.isValid = (newValue !== null);
            break;
        case 'name':
            if (input) input.setAttribute('name',newValue);
            break;
        case 'dmb-name':
            if (input) input.setAttribute('name',newValue);
            break;
        case 'validate':
            if (input) input.setAttribute('validate',newValue);
            break;
        }

    }

    init() {
        let input = this.getElementsByTagName('textarea').item(0);

        this.querySelector('label').innerText = this.getAttribute('label');
        input.setAttribute('aria-label',this.getAttribute('label') || '');
        input.setAttribute('masked',this.getAttribute('masked') || '');
        input.setAttribute('autocomplete',this.getAttribute('autocomplete') || '');
        input.setAttribute('class',this.getAttribute('dmb-class') || '');
        input.setAttribute('name',this.getAttribute('dmb-name') || '');
        input.setAttribute('validate',this.getAttribute('validate') || '');
        input.setAttribute('placeholder',this.getAttribute('placeholder') || '');
        input.setAttribute('valid','true');
        input.id = this.getAttribute('dmb-id')|| this.generateId();

        const maskInputUppercase = (e) => {
            e.target.value = e.target.value.toUpperCase();
        };

        if (input && this.getAttribute('validate')) {
            this.validators = this.buildValidators(input, this);
        }

        input.addEventListener('blur', (e) => {
            this._runValidators(e.target, this.validators);
        }, {capture: true, passive: true});

        const maskInputAlpha = (e) => {
            let char = e.which || e.keyCode;

            if ((char < 65 || char > 90) && (char < 97 || char > 122)) {
                return false;
            }
        };

        const maskInputNumeric = (e) => {
            let char = e.which || e.keyCode;

            if (char < 48 || char > 57) {
                return false;
            }
        };

        if (this.getAttribute('validate')) {
            this.validators = this.buildValidators(input, this);

            input.addEventListener('blur', (e) => {
                this._runValidators(e.target, this.validators);
            }, true);
        }

        if (this.getAttribute('masked')) {
            switch (this.getAttribute('masked')) {
            case 'alpha':
                input.onkeypress = maskInputAlpha;
                break;
            case 'numeric':
                input.onkeypress = maskInputNumeric;
                break;
            case 'uppercase':
                input.oninput = maskInputUppercase;
                break;
            }
        }
    }

    _runValidators (element, validators) {
        let unknownValidator = () => {
            return {valid: false, error: 'Unknown validator type: "' + (validator || {}).key + '"'};
        };
        let content = element.value.trim();
        let valid = true;
        let validator= null;
        let func = null;
        let result = null;

        element.value = content;
        for (var i = 0, len = validators.length; i < len; i++) {
            validator = validators[i];
            func = this.validations['_' + validator.key] || unknownValidator;

            result = func(content, validator.param);
            if (result.valid !== true) {
                valid = false;
                break;
            }
        }

        if (valid === true) {
            element.parentNode.classList.remove(this._errorInputClass);
        } else {
            element.parentNode.classList.add(this._errorInputClass);
        }
        this.isValid = valid;
        valid? element.setAttribute('valid','') : element.removeAttribute('valid');
    }

    buildValidators (element, scope) {
        let validators = [],
            validatorList = (scope.getAttribute('validate') || '').split(',');

        for (let i = 0, len = validatorList.length; i < len; i++) {
            let keyParam = validatorList[i].split(':');

            if (keyParam[0]) {
                validators.push({
                    key: keyParam[0],
                    param: keyParam.length === 2 ? keyParam[1] : null
                });

                if (keyParam[0] === 'required') {
                    element.parentNode.classList.add('required');
                    element.setAttribute('required','required');
                }
            }
        }

        return validators;
    }

    resetValidation() {
        let elements = this.getElementsByClassName(this._errorInputClass);
        for (let i = 0; elements.length; i++) {
            elements.item(0).classList.remove(this._errorInputClass);
        }
    }

    setValidation() {
        this._runValidators(this.querySelector('textarea'), this.validators);
    }
}

customElements.define('dmb-textarea', DmbTextArea);
class DmbToggle extends DumboDirective {
    static get observedAttributes() { return ['value']; }
    constructor() {
        super();

        const template = '<span class="switch"></span>';
        this.setTemplate(template);
        this.val = 0;
    }

    set value(val = 0) {
        this.val = val;
        this.setStatus();
    }

    get value() {
        return this.val;
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        switch(attr) {
        case 'value':
            this.val = parseInt(newValue);
            this.setStatus();
            break;
        }
    }

    init() {
        this.val = parseInt(this.getAttribute('value') || '0');
        this.setStatus();

        this.addEventListener('click', () => {
            this.val = 1 * !this.val;
            this.setStatus();
        });
    }

    setStatus() {
        if (this.val === 1) {
            this.classList.add('on');
        } else {
            this.classList.remove('on');
        }
    }

    /**
     * Attach a method to run when event click is fired.
     * @param {function} method
     */
    click(method) {
        if (typeof method === 'function') {
            this.addEventListener('click', method);
        }
    }
}

customElements.define('dmb-toggle', DmbToggle);
/**
 * Component handle Video uploader
 * Get the elements of principal issues, and sub issues
 */ 

class DmbVideoUploader extends DumboDirective {
    constructor() {
        super();

        /**
        * Creation of html
        */
        const template = '<dmb-input type="file" dmb-name="videofile" accept="video/*"></dmb-input>' +
                         '<div class="preview"><video controls></video></div>';
        this.setTemplate(template);
    }

    init() {
        const dmbVideoInput = this.querySelector('dmb-input[type="file"]');
        const videoInput = dmbVideoInput.querySelector('input[type="file"]');
        const willPreview = this.hasAttribute('preview') && !!this.getAttribute('preview').length;

        this.hasAttribute('validate') && dmbVideoInput.setAttribute('validate', this.getAttribute('validate'));
        this.hasAttribute('dmb-name') && dmbVideoInput.setAttribute('dmb-name', this.getAttribute('dmb-name'));
        this.hasAttribute('label') && dmbVideoInput.setAttribute('label', this.getAttribute('label'));

        willPreview && videoInput.addEventListener('change', e => {
            this.loadFile(e.target.files[0]);
        });

        willPreview || this.querySelector('.preview video').remove();
    }
    
    loadFile (file) {
        const videoComponent = this.querySelector('.preview video');
        const reader = new FileReader();
        const promise = new Promise((resolve) => {
            reader.onload = () => {
                resolve();
                videoComponent.setAttribute('src', reader.result.toString());
            };
        });
        reader.readAsDataURL(file);
        return promise;
    }
}

customElements.define('dmb-video-uploader', DmbVideoUploader);
/**
 * 
 */
class DmbView extends DumboDirective {
    constructor() {
        super();
    }
}
customElements.define('dmb-view', DmbView);

class DmbWysiwyg extends DumboDirective {
    static get observedAttributes() { return ['valid','name', 'validate', 'dmb-name']; }

    constructor() {
        super();

        const template = '<section class="dmb-wysiwyg" >' +
                            '<div class="dmb-wysiwyg__toolbar">' +
                                '<a href="#" title="Heading 2" class="dmb-wysiwyg__toolbar-button" data-command="h2">H2</a>' +
                                '<a href="#" title="Heading 3" class="dmb-wysiwyg__toolbar-button" data-command="h3">H3</a>' +
                                '<a href="#" title="Heading 4" class="dmb-wysiwyg__toolbar-button" data-command="h4">H4</a>' +
                                '<a href="#" title="Heading 5" class="dmb-wysiwyg__toolbar-button" data-command="h5">H5</a>' +
                                '<a href="#" title="Heading 6" class="dmb-wysiwyg__toolbar-button" data-command="h6">H6</a>' +
                                '<a href="#" title="Undo" class="icon icon-undo dmb-wysiwyg__toolbar-button" data-command="undo"></a>' +
                                '<a href="#" title="Redo" class="icon icon-redo dmb-wysiwyg__toolbar-button" data-command="redo"></a>' +
                                '<a href="#" title="Paragraph" class="icon icon-pilcrow dmb-wysiwyg__toolbar-button" data-command="p"></a>' +
                                '<a href="#" title="Link" class="icon icon-link dmb-wysiwyg__toolbar-button" data-command="createlink"></a>' +
                                '<a href="#" title="Left Align" class="icon icon-paragraph-left dmb-wysiwyg__toolbar-button" data-command="justifyLeft"></a>' +
                                '<a href="#" title="Center Align" class="icon icon-paragraph-center dmb-wysiwyg__toolbar-button" data-command="justifyCenter"></a>' +
                                '<a href="#" title="Justify Align" class="icon icon-paragraph-justify dmb-wysiwyg__toolbar-button" data-command="justifyFull"></a>' +
                                '<a href="#" title="right Align" class="icon icon-paragraph-right dmb-wysiwyg__toolbar-button" data-command="justifyRight"></a>' +
                                '<a href="#" title="Super" class="icon icon-superscript2 dmb-wysiwyg__toolbar-button" data-command="superscript"></a>' +
                                '<div title="Font Color" class="dmb-wysiwyg__toolbar-button palette">' +
                                    '<i class="icon icon-brush"></i>' +
                                    '<div class="fore-palette"></div>' +
                                '</div>' +
                                '<div title="Background Color" class="dmb-wysiwyg__toolbar-button back-palette">' +
                                    '<i class="icon icon-palette"></i>' +
                                    '<div class="fore-palette"></div>' +
                                '</div>' +
                                '<a href="#" title="View Source" class="dmb-wysiwyg__toolbar-button source-button" data-command="source" style="width: 4em;">Source</a>' +
                                '<a href="#" title="View compiled" class="dmb-wysiwyg__toolbar-button normal-button" data-command="normal" style="display:none;">Normal</a>' +
                            '</div>' +
                            '<textarea class="dmb-wysiwyg__content-content novalidate"></textarea>' +
                            '<section class="dmb-wysiwyg__content-content novalidate" contenteditable transclude>' +
                            '</section>' +
                            '<span class="error-container"></span>' +
                        '</section>';

        this.setTemplate(template);
        this.isValid = false;
        this._errorWysiwygClass = 'v_error';
        this.colorPalette = ['000000', 'FF9966', '6699FF', '99FF66','CC0000', '00CC00', '0000CC', '333333', '0066FF', 'FFFFFF'];
        this.toolbarElements = [];
        this.validations = {
            _required: function (value) {
                let response = {
                    valid: true,
                    error: null
                };
                if (typeof value === 'undefined' || value === null || value === '') {
                    response.valid = false;
                    response.error = 'Este campo es obligatorio';
                }
                return response;
            }
        };
    }

    init() {
        const forePalette = this.querySelector('.palette .fore-palette');
        const backPalette = this.querySelector('.back-palette .fore-palette');
        let hideButtons = null;
        let showButtons = null;
        let executeCommand = null;
        let a = document.createElement('a');
        let ap = document.createElement('a');
        let textArea = this.querySelector('textarea.dmb-wysiwyg__content-content');
        this.toolbarElements = this.querySelectorAll('.dmb-wysiwyg__toolbar-button');

        a.dataset.command = 'foreColor';
        ap.dataset.command = 'backColor';
        a.setAttribute('href','#');
        ap.setAttribute('href','#');
        a.classList.add('palette-item');
        ap.classList.add('palette-item');
        a.classList.add('dmb-wysiwyg__toolbar-button');
        ap.classList.add('dmb-wysiwyg__toolbar-button');

        for (let i = 0; i < this.colorPalette.length; i++) {
            a.dataset.value = `${this.colorPalette[i]}`;
            ap.dataset.value = `${this.colorPalette[i]}`;
            a.style.backgroundColor = `#${this.colorPalette[i]}`;
            ap.style.backgroundColor = `#${this.colorPalette[i]}`;
            forePalette.append(a.cloneNode(true));
            backPalette.append(ap.cloneNode(true));
        }

        textArea.setAttribute('hidden', true);
        textArea.value = this.querySelector('textArea.dmb-wysiwyg__content-content').innerHTML;
        textArea.setAttribute('name',this.getAttribute('dmb-name') || '');
        textArea.setAttribute('validate',this.getAttribute('validate') || '');
        textArea.setAttribute('valid','true');

        hideButtons = (toolbarElements) => {
            for (let j = 0; j < toolbarElements.length; j++) {
                toolbarElements[j].style.display = 'none';
            }
        };

        showButtons = (toolbarElements) => {
            for (let j = 0; j < toolbarElements.length; j++) {
                toolbarElements[j].style.display = 'flex';
            }
        };

        executeCommand = (e) => {
            const me = e.target;
            let command = me.dataset.command;
            let value = me.dataset.value;
            let url;
            let textArea;
            let editArea;

            e.stopImmediatePropagation();
            e.stopPropagation();
            e.preventDefault();

            switch (command) {
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
            case 'p':
                document.execCommand('formatBlock', true, command);
                break;
            case 'foreColor':
            case 'backColor':
                document.execCommand(command, true, value);
                break;
            case 'createlink':
            case 'insertimage':
                url = prompt('Enter the link here: ','');
                if (url && url.length) {
                    document.execCommand(command, false, url);
                }
                break;
            case 'source':
                hideButtons(this.toolbarElements);
                me.parentNode.querySelector('.normal-button').style.display = 'flex';
                textArea = me.parentNode.parentNode.querySelector('textarea.dmb-wysiwyg__content-content');
                editArea = me.parentNode.parentNode.querySelector('section.dmb-wysiwyg__content-content');

                textArea.value = editArea.innerHTML;
                textArea.setAttribute('hidden', false);
                textArea.removeAttribute('hidden');
                editArea.setAttribute('hidden', true);
                break;
            case 'normal':
                showButtons(this.toolbarElements);
                me.style.display = 'none';
                textArea = me.parentNode.parentNode.querySelector('textarea.dmb-wysiwyg__content-content');
                editArea = me.parentNode.parentNode.querySelector('section.dmb-wysiwyg__content-content');

                editArea.innerHTML = textArea.value;
                editArea.setAttribute('hidden', false);
                editArea.removeAttribute('hidden');
                textArea.setAttribute('hidden', true);
                break;
            default:
                document.execCommand(command, false, null);
                break;
            }

        };

        for (let i = 0; i < this.toolbarElements.length; i++) {
            this.toolbarElements[i].addEventListener('click', executeCommand);
        }

        if (this.getAttribute('validate') && this.getAttribute('validate').length) {
            this.setValidation();
        }
    }

    buildValidators () {
        let validators = [];
        let validatorList = (this.getAttribute('validate') || '').split(',');
        let textarea = null;
        let editArea = null;

        for (let i = 0, len = validatorList.length; i < len; i++) {
            let keyParam = validatorList[i].split(':');

            if (keyParam[0]) {
                validators.push({
                    key: keyParam[0],
                    param: keyParam.length === 2 ? keyParam[1] : null
                });

                if (keyParam[0] === 'required') {
                    textarea = this.querySelector('textarea');
                    this.classList.add('required');
                    textarea.setAttribute('required','required');
                }

                if (keyParam[0] === 'required') {
                    editArea = this.querySelector('section');
                    this.classList.add('required');
                    editArea.setAttribute('required','required');
                }
            }
        }
        return validators;
    }

    _runValidators(element, validators) {
        const unknownValidator = () => {
            return {valid: false, error: 'Unknown validator type: "' + (validator || {}).key + '"'};
        };
        let content = (element.value || element.innerHTML).trim();
        let valid = true;
        let validator= null;
        let func = null;
        let result = null;
        let message = null;

        for (let i = 0, len = validators.length; i < len; i++) {
            validator = validators[i];
            func = this.validations['_' + validator.key] || unknownValidator;

            result = func(content, validator.param);
            if (result.valid !== true) {
                valid = false;
                message = result.error;
                break;
            }
        }

        if (valid === true) {
            element.parentNode.classList.remove(this._errorWysiwygClass);
            element.parentNode.querySelectorAll('.error-container').item(0).innerHTML = '';
        } else {
            element.parentNode.classList.add(this._errorWysiwygClass);
            element.parentNode.querySelectorAll('.error-container').item(0).innerHTML = message;
        }
        this.isValid = valid;
        valid? element.setAttribute('valid','') : element.removeAttribute('valid');
    }

    setValidation() {
        let validators = [];
        const textarea = this.querySelector('textarea.dmb-wysiwyg__content-content');
        const editarea = this.querySelector('section.dmb-wysiwyg__content-content');
        validators = this.buildValidators();

        textarea.addEventListener('blur', () => {
            this._runValidators(textarea, validators);
        }, true);

        editarea.addEventListener('blur', () => {
            this._runValidators(editarea, validators);
        }, true);

        document.body.addEventListener(window.DmbEvents.validate.listener, () => {
            this._runValidators(textarea, validators);
            this._runValidators(editarea, validators);
        }, true);

        document.body.addEventListener(window.DmbEvents.resetValidation.listener, () => {
            let elements = this.getElementsByClassName(this._errorWysiwygClass);

            for (let i = 0; elements.length; i++) {
                elements.item(0).classList.remove(this._errorWysiwygClass);
            }
        }, true);
    }

    syncData() {
        let textArea = this.querySelector('textarea.dmb-wysiwyg__content-content');
        let editArea = this.querySelector('section.dmb-wysiwyg__content-content');

        if (textArea.hasAttribute('hidden')) {
            textArea.value = editArea.innerHTML;
        } else {
            editArea.innerHTML = textArea.value;
        }
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        const textarea = this.querySelector('textarea.dmb-wysiwyg__content-content');
        const editarea = this.querySelector('section.dmb-wysiwyg__content-content');

        switch(attr) {
        case 'valid':
            this.isValid = (newValue !== null);
            break;
        case 'name':
            if (textarea) textarea.setAttribute('name',newValue);
            break;
        case 'dmb-name':
            if (textarea) textarea.setAttribute('name',newValue);
            break;
        case 'validate':
            if (textarea) {
                textarea.setAttribute('validate',newValue);
                if (newValue && newValue.length) {
                    this.setValidation();
                }
            }
            if (editarea) {
                editarea.setAttribute('validate',newValue);
                if (newValue && newValue.length) {
                    this.setValidation();
                }
            }
            break;
        }
    }
}

customElements.define('dmb-wysiwyg', DmbWysiwyg);
