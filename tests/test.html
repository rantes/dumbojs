<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Dumbo UI tests</title>
    <style type="text/css">
    :root {
        --primary: #16253F;
        --primary-contrast: #FFFFFF;
        --primary-hover: #16253F99;
        --secondary: #182517;
        --secondary-contrast: #E7DAE7;
        --secondary-hover: #E8EBEF;
        --default: #27401D;
        --default-contrast: #FFFFFF;
        --default-hover: #99999999;
        --error: #F44336;
        --error-contrast: #FFFFFF;
        --error-hover: #F4433699;
        --success: #63AB71;
        --success-contrast: #15253E;
        --success-hover: #63AB7199;
        --warning: #E09B39;
        --warning-contrast: #FFFFFF;
        --warning-hover: #E09B3999;
        --information: #51697C;
        --information-contrast: #B8E2F5;
        --information-hover: #51697C;
        --hover-opacity: 0.5;
    }

    .button {
  border-radius: 0.5em;
  box-shadow: 3px 3px 0 0 #000000bb;
  box-sizing: border-box;
  color: var(--default);
  cursor: pointer;
  display: inline-block;
  padding: 0.5em 1em;
  position: relative;
  text-align: center;
}

.button * {
  pointer-events: none;
}

.col .button {
  width: 100%;
}

.button .text {
  display: inline-block;
}

.button:focus {
  outline: 0 none;
}

.button:before {
  color: var(--default);
}

.button:active {
  box-shadow: -1px -1px 1px 0 #000000bb;
  transform: translate(3px, 3px);
}

.button-default {
  background-color: var(--default);
  color: var(--default-contrast);
}

.button-default::before {
  color: var(--default-contrast);
}

.button-default:hover {
  background-color: var(--default-hover);
}

.button-default:visited {
  color: var(--default-contrast);
}

.button-primary {
  background-color: var(--primary);
  color: var(--primary-contrast);
}

.button-primary::before {
  color: var(--primary-contrast);
}

.button-primary:hover {
  background-color: var(--primary-hover);
}

.button-primary:visited {
  color: var(--primary-contrast);
}

.button-secondary {
  background-color: var(--secondary);
  color: var(--secondary-contrast);
}

.button-secondary::before {
  color: var(--secondary-contrast);
}

.button-secondary:hover {
  background-color: var(--secondary-hover);
}

.button-secondary:visited {
  color: var(--secondary-contrast);
}

.button-error {
  background-color: var(--error);
  color: var(--error-contrast);
}

.button-error::before {
  color: var(--error-contrast);
}

.button-error:hover {
  background-color: var(--error-hover);
}

.button-error:visited {
  color: var(--error-contrast);
}

.button-success {
  background-color: var(--success);
  color: var(--success-contrast);
}

.button-success::before {
  color: var(--success-contrast);
}

.button-success:hover {
  background-color: var(--success-hover);
}

.button-success:visited {
  color: var(--success-contrast);
}

.button-warning {
  background-color: var(--warning);
  color: var(--warning-contrast);
}

.button-warning::before {
  color: var(--warning-contrast);
}

.button-warning:hover {
  background-color: var(--warning-hover);
}

.button-warning:visited {
  color: var(--warning-contrast);
}

.button-information {
  background-color: var(--information);
  color: var(--information-contrast);
}

.button-information::before {
  color: var(--information-contrast);
}

.button-information:hover {
  background-color: var(--information-hover);
}

.button-information:visited {
  color: var(--information-contrast);
}

.button.icon {
  height: auto;
}

dmb-close-panel {
  cursor: pointer;
  position: absolute;
  top: 1em;
}

dmb-close-panel.right {
  left: 1em;
}

dmb-close-panel.left {
  right: 1em;
}

dmb-content {
  background-color: white;
  bottom: 0.6rem;
  display: block;
  height: auto;
  left: 0;
  overflow-x: auto;
  overflow-y: auto;
  padding: 1.6em 1em 1em 1em;
  position: absolute;
  right: 0;
  top: 4em;
}

dmb-content.padded-footer {
  height: calc(100% - 9em);
}

dmb-dialog {
  border: 0;
  bottom: 0;
  height: 100vh;
  left: 0;
  opacity: 0;
  padding: 0;
  position: fixed;
  right: 0;
  text-align: center;
  top: 0;
  transition: opacity 0.5s ease-in-out;
  width: 100vw;
  z-index: 999;
}

dmb-dialog .wrapper {
  background-color: white;
  border-radius: 0.6rem;
  box-shadow: 0 0 1em black;
  display: block;
  left: 50%;
  margin: 0;
  min-width: 300px;
  position: absolute;
  top: 150vh;
  transform: translate(-50%, -50%);
  transition: transform 0.5s ease-in-out;
  will-change: transform;
  z-index: 1000;
}

dmb-dialog .wrapper .dmb-header {
  border-radius: 0.6rem 0.6rem 0 0;
}

dmb-dialog .wrapper .dmb-footer {
  border-radius: 0 0 0.6rem 0.6rem;
}

dmb-dialog .wrapper .message {
  left: 50px;
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}

dmb-dialog .wrapper .icon:not(.close-modal-button) {
  left: 10px;
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}

dmb-dialog .wrapper .close-modal-button {
  cursor: pointer;
  position: absolute;
  right: 2em;
  top: 1em;
  z-index: 1;
}

dmb-dialog .wrapper .close-modal-button:before {
  font-size: 2em;
}

dmb-dialog::before {
  background-color: rgba(0, 0, 0, 0.4);
  bottom: 0;
  content: ' ';
  left: 0;
  right: 0;
  position: fixed;
  top: 0;
}

dmb-dialog.error .wrapper {
  height: 100px;
}

dmb-dialog.info .wrapper {
  min-height: 6em;
}

dmb-dialog.loader .wrapper {
  height: 250px;
}

dmb-dialog.drawer .wrapper {
  min-height: 27vh;
}

dmb-dialog.drawer.small .wrapper {
  width: 300px;
}

dmb-dialog.drawer.medium .wrapper {
  height: 60vh;
  width: 600px;
}

dmb-dialog.drawer.large .wrapper {
  height: 80vh;
  width: 90vw;
}

dmb-dialog[open] {
  opacity: 1;
}

dmb-dialog[open] .wrapper {
  transform: translate(-50%, -140vh);
}

dmb-footer, .dmb-footer {
  background-color: var(--primary);
  box-shadow: 0 -5px 5px grey;
  color: var(--primary-contrast);
  bottom: 0;
  height: 5em;
  left: 0;
  padding: 0.8em;
  position: absolute;
  right: 0;
  text-align: center;
}

dmb-header {
  box-shadow: 0 0 5px var(--primary-hover);
  border-bottom: solid 0.5em var(--primary);
  height: 4em;
  left: 0;
  padding: 0;
  position: absolute;
  right: 0;
  text-align: center;
  top: 0;
}

dmb-header h1 {
  margin: 0 auto;
}

dmb-header-title {
  margin-top: 1em;
}

dmb-image-uploader .preview img {
  width: 10em;
  height: auto;
}

dmb-info-pop {
  cursor: help;
  position: relative;
}

dmb-info-pop .float-content {
  background-color: var(--default-contrast);
  border: 1px solid var(--default);
  color: var(--default);
  display: inline-block;
  left: 2em;
  opacity: 0;
  padding: 1em;
  position: absolute;
  top: -2em;
  transition: 0.6s all;
  visibility: hidden;
  z-index: 3;
}

dmb-info-pop .float-content_large {
  width: 30em;
}

dmb-info-pop:hover .float-content, dmb-info-pop:active .float-content {
  opacity: 1;
  visibility: visible;
}

dmb-input {
  box-sizing: border-box;
  display: block;
  padding-bottom: 1em;
  position: relative;
}

dmb-input input {
  background-color: var(--default-contrast);
  border: 1px solid var(--default);
  border-radius: 0.5em;
  box-shadow: 1px 1px 2px 0 var(--default-hover) inset;
  box-sizing: border-box;
  color: var(--default);
  display: block;
  line-height: normal;
  margin: 0;
  padding: 0.5em 0.5em 0.3em;
  transition: all 0.5s ease-in-out;
  width: 100%;
}

dmb-input input:focus {
  border: 1px solid var(--success);
  box-shadow: 1px 1px 2px 0 var(--default-hover) inset, 0 1px 1px var(--default-hover) inset, 0 0 8px var(--success);
  color: black;
  outline: 0 none;
}

dmb-input input[type="checkbox"] {
  float: left;
  width: auto;
}

dmb-input input[type="checkbox"] ~ label {
  float: left;
  width: auto;
}

dmb-input label {
  box-sizing: border-box;
  display: inline-block;
  margin-bottom: 5px;
  overflow: hidden;
  padding-left: 6px;
  text-align: left;
  width: 99%;
}

._error dmb-input label {
  color: var(--error);
}

dmb-input.required label:after {
  content: "*";
}

dmb-input .error-container {
  color: var(--error);
  display: none;
  line-height: 1;
}

dmb-input._error input {
  border: 1px solid var(--error);
}

dmb-input._error .error-container {
  display: inline-block;
}

dmb-menu-button {
  cursor: pointer;
  height: 1em;
  left: 30px;
  position: absolute;
  top: 20px;
  vertical-align: middle;
}

dmb-menu-button .legend {
  display: inline-block;
  height: 1em;
  line-height: normal;
  margin: auto 10px;
  vertical-align: middle;
}

dmb-notification {
  border: 2px solid;
  float: left;
  margin-bottom: 0.5em;
  min-height: 1em;
  padding: 1em;
  position: relative;
  width: 100%;
}

dmb-notification .wrapper {
  height: 100%;
  width: 100%;
}

dmb-notification .close-notification-button {
  cursor: pointer;
  position: absolute;
  right: 2em;
  top: 1em;
  z-index: 1;
}

dmb-notification .close-notification-button:before {
  font-size: 2em;
}

dmb-notification.success {
  border-color: var(--success);
  background-color: var(--success-hover);
  color: var(--success-contrast);
}

dmb-notification.error {
  border-color: var(--error);
  background-color: var(--error-hover);
  color: var(--error-contrast);
}

dmb-notification.warning {
  border-color: var(--warning);
  background-color: var(--warning-hover);
  color: var(--warning-contrast);
}

dmb-page-loader {
  background-color: white;
  bottom: 0;
  display: none;
  height: 100%;
  left: 0;
  overflow: hidden;
  position: fixed;
  top: 0;
  width: 100%;
  z-index: 1000;
}

dmb-page-loader.active {
  display: block;
}

dmb-page-loader .wrapper {
  height: 50vh;
  left: 50%;
  position: absolute;
  transform: translate(-50%, -50%);
  top: 50%;
  width: 164px;
}

dmb-page-loader.transparent {
  background-color: #00000066;
}

dmb-pagination .paginate, .dmb-pagination .paginate {
  box-sizing: border-box;
  display: inline-block;
  margin: 0 5px;
  text-align: center;
}

dmb-pagination .paginate-page, .dmb-pagination .paginate-page {
  display: inline-block;
}

dmb-pagination .paginate-page-active, .dmb-pagination .paginate-page-active {
  border-bottom: solid 1px var(--default);
}

dmb-pagination .paginate-active-page, .dmb-pagination .paginate-active-page {
  border-bottom: solid 1px var(--default);
}

dmb-panel {
  border: 0;
  bottom: 0;
  height: 100%;
  left: 0;
  padding: 0;
  position: fixed;
  right: 0;
  text-align: center;
  top: 0;
  transition: visibility 0.6s linear;
  visibility: hidden;
  width: 100vw;
  z-index: 999;
}

dmb-panel .wrapper {
  background-color: white;
  border-radius: 0;
  bottom: 0;
  box-shadow: 0 0 1em black;
  display: block;
  height: 100%;
  margin: 0;
  position: absolute;
  top: 0;
  transition: left 0.5s ease-in-out, right 0.5s ease-in-out;
  z-index: 1000;
}

dmb-panel.right.small .wrapper {
  right: -350px;
}

dmb-panel.right.large .wrapper {
  right: -110vw;
}

dmb-panel.left.small .wrapper {
  left: -350px;
}

dmb-panel.left.large .wrapper {
  left: -110vw;
}

dmb-panel.small .wrapper {
  width: 320px;
}

dmb-panel.large .wrapper {
  width: 100vw;
}

dmb-panel::before {
  background-color: rgba(0, 0, 0, 0.4);
  bottom: 0;
  content: ' ';
  left: 0;
  opacity: 0;
  position: fixed;
  right: 0;
  top: 0;
  transition: opacity 0.5s ease-in-out;
}

dmb-panel .header {
  box-shadow: 0 0 5px grey;
  height: 40px;
  border-bottom: solid 1px grey;
  padding: 0 10px;
  width: 100%;
}

dmb-panel .header .dmb-panel-close {
  right: 10px;
  position: absolute;
  top: 10px;
}

dmb-panel .footer {
  box-shadow: 0 0 5px grey;
  height: 64px;
  border-top: solid 1px grey;
  padding: 0 10px;
  width: 100%;
}

dmb-panel[open] {
  visibility: visible;
}

dmb-panel[open]::before {
  opacity: 1;
}

dmb-panel[open].right .wrapper {
  right: 0;
}

dmb-panel[open].left .wrapper {
  left: 0;
}

dmb-select {
  box-sizing: border-box;
  display: block;
  padding-bottom: 1em;
  position: relative;
}

dmb-select select {
  background-color: var(--default-contrast);
  border: 1px solid var(--default);
  border-radius: 0.5em;
  box-shadow: 1px 1px 2px 0 rgba(0, 0, 0, 0.5) inset;
  box-sizing: border-box;
  color: var(--default);
  display: block;
  line-height: normal;
  margin: 0;
  padding: 0.5em 0.5em 0.3em;
  transition: all 0.5s ease-in-out;
  width: 100%;
}

dmb-select select:focus {
  border: 1px solid green;
  box-shadow: 1px 1px 2px 0 rgba(0, 0, 0, 0.5) inset, 0 1px 1px rgba(0, 0, 0, 0.075) inset, 0 0 8px rgba(0, 128, 0, 0.6);
  color: black;
  outline: 0 none;
}

dmb-select label {
  box-sizing: border-box;
  display: inline-block;
  margin-bottom: 5px;
  padding-left: 6px;
  text-align: left;
  width: 99%;
}

._error dmb-select label {
  color: var(--error);
}

dmb-select.required label:after {
  content: "*";
}

dmb-select .error-container {
  color: var(--error);
  display: none;
  line-height: normal;
}

dmb-select._error select {
  border: 1px solid var(--error);
}

dmb-select._error .error-container {
  display: inline-block;
}

.dmb-table {
  clear: both;
  float: none;
  margin: auto;
  overflow-x: auto;
  position: relative;
  width: 100%;
}

.dmb-table table {
  border-radius: 0.5em;
  border-spacing: 0;
  clear: both;
  width: 100%;
}

.dmb-table table th {
  padding: 0.5em;
}

.dmb-table table td {
  text-align: center;
  padding: 0.5em;
}

.dmb-table table thead tr th {
  background-color: var(--default-contrast);
  text-transform: uppercase;
}

.dmb-table table thead tr th:first-child {
  border-top-left-radius: 0.5em;
  border-bottom-left-radius: 0.5em;
}

.dmb-table table thead tr th:last-child {
  border-top-right-radius: 0.5em;
  border-bottom-right-radius: 0.5em;
}

.dmb-table table tbody tr td {
  border-right: 1px black dashed;
  color: blue;
  margin: 0;
}

.dmb-table table tbody tr td:first-child {
  border-top-left-radius: 0.5em;
  border-bottom-left-radius: 0.5em;
}

.dmb-table table tbody tr td:last-child {
  border-top-right-radius: 0.5em;
  border-bottom-right-radius: 0.5em;
  border-right: 0 none transparent;
}

.dmb-table table tbody tr td.truncated {
  overflow: hidden;
  text-overflow: ellipsis;
  width: 350px;
  white-space: nowrap;
}

.dmb-table table tbody tr td.actions {
  width: 2em;
  white-space: nowrap;
}

.dmb-table table tbody tr:nth-child(odd) {
  background-color: var(--default);
}

.dmb-table table tbody tr:hover {
  background-color: var(--default-hover);
}

.dmb-table table tfoot tr td {
  background-color: var(--default-hover);
  text-align: center;
}

.dmb-table table tfoot tr td:first-child {
  border-top-left-radius: 0.5em;
  border-bottom-left-radius: 0.5em;
}

.dmb-table table tfoot tr td:last-child {
  border-top-right-radius: 0.5em;
  border-bottom-right-radius: 0.5em;
}

dmb-textarea {
  box-sizing: border-box;
  display: block;
  padding-bottom: 1em;
  position: relative;
}

dmb-textarea textarea {
  background-color: var(--default-contrast);
  border: 1px solid var(--default);
  border-radius: 0.5em;
  box-shadow: 1px 1px 2px 0 rgba(0, 0, 0, 0.5) inset;
  box-sizing: border-box;
  color: var(--default);
  display: block;
  line-height: normal;
  margin: 0;
  padding: 0.5em 0.5em 0.3em;
  transition: all 0.5s ease-in-out;
  width: 100%;
}

dmb-textarea textarea:focus {
  border: 1px solid green;
  box-shadow: 1px 1px 2px 0 rgba(0, 0, 0, 0.5) inset, 0 1px 1px rgba(0, 0, 0, 0.075) inset, 0 0 8px rgba(0, 128, 0, 0.6);
  color: black;
  outline: 0 none;
}

dmb-textarea label {
  box-sizing: border-box;
  display: inline-block;
  margin-bottom: 5px;
  overflow: hidden;
  padding-left: 6px;
  text-align: left;
  width: 99%;
}

._error dmb-textarea label {
  color: var(--error);
}

dmb-textarea.required label:after {
  content: "*";
}

dmb-textarea .error-container {
  color: var(--error);
  display: none;
  line-height: 1;
}

dmb-textarea._error textarea {
  border: 1px solid var(--error);
}

dmb-textarea._error .error-container {
  display: inline-block;
}

dmb-toggle {
  background-color: var(--default-contrast);
  border-radius: 1em;
  cursor: pointer;
  display: inline-block;
  height: 2em;
  position: relative;
  width: 4em;
}

dmb-toggle .switch {
  background-color: var(--default);
  border-radius: 1em;
  height: calc(2em - 6px);
  position: absolute;
  left: 3px;
  top: 3px;
  transition: left 1s ease;
  width: calc(2em - 6px);
}

dmb-toggle.on {
  background-color: var(--success-hover);
}

dmb-toggle.on .switch {
  background-color: var(--success);
  left: auto;
  right: 3px;
}

[dmb-tooltip]::after {
  background-color: #000;
  border-top: 5px solid #000;
  border-right: 5px solid #000;
  border-left: 5px solid #000;
  border-bottom: 5px solid #000;
  border-radius: 3px;
  bottom: 2.5em;
  color: #fff;
  content: attr(dmb-tooltip);
  left: 50%;
  margin-bottom: 0;
  margin-left: 0;
  min-width: 1em;
  opacity: 0;
  padding: 0;
  pointer-events: none;
  position: absolute;
  transform: translateX(-50%);
  visibility: hidden;
  width: auto;
  z-index: 999999;
}

[dmb-tooltip]:hover::after {
  visibility: visible;
  opacity: 1;
}

dmb-video-uploader .preview video {
  width: 20em;
  height: auto;
}

dmb-wysiwyg .dmb-wysiwyg {
  border-radius: 0.2em;
  padding: 2.1em 0 0 0;
}

dmb-wysiwyg .dmb-wysiwyg__toolbar {
  border-left: 1px solid var(--default-hover);
  border-right: 1px solid var(--default-hover);
  border-top: 1px solid var(--default-hover);
  display: flex;
  margin: 0;
  padding: 0;
  position: relative;
}

dmb-wysiwyg .dmb-wysiwyg__toolbar-button {
  align-items: center;
  box-sizing: border-box;
  color: var(---default);
  cursor: pointer;
  display: flex;
  float: left;
  font-size: initial;
  height: 2em;
  justify-content: center;
  margin: 0;
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 5px;
  width: 2em;
}

dmb-wysiwyg .dmb-wysiwyg__toolbar-button:active {
  box-shadow: -1px -1px 1px 0 var(--default-hover);
}

dmb-wysiwyg .dmb-wysiwyg__toolbar-button svg {
  pointer-events: none;
}

dmb-wysiwyg .dmb-wysiwyg__toolbar .fore-palette {
  display: none;
  position: absolute;
  top: 2em;
  width: 10em;
  z-index: 10;
}

dmb-wysiwyg .dmb-wysiwyg__toolbar .palette {
  position: relative;
}

dmb-wysiwyg .dmb-wysiwyg__toolbar .palette:hover .fore-palette {
  display: block;
}

dmb-wysiwyg .dmb-wysiwyg__toolbar .back-palette {
  position: relative;
}

dmb-wysiwyg .dmb-wysiwyg__toolbar .back-palette:hover .fore-palette {
  display: block;
}

dmb-wysiwyg .dmb-wysiwyg__content-content {
  background-color: var(--default-contrast);
  border: 1px solid var(--default);
  min-height: 10em;
  width: 100%;
}

dmb-wysiwyg .dmb-wysiwyg__content-content[hidden] {
  height: 0;
  visibility: hidden;
  width: 0;
}

dmb-wysiwyg .dmb-wysiwyg.v_error textarea {
  border: 1px solid var(--error);
  box-shadow: 0px 0px 20px -0.6em var(--error);
}

dmb-wysiwyg .dmb-wysiwyg.v_error section {
  border: 1px solid var(--error);
  box-shadow: 0px 0px 20px -0.6em var(--error);
}

dmb-wysiwyg .dmb-wysiwyg .error-container {
  color: var(--error);
  display: inline-block;
  line-height: 1;
}

dmb-wysiwyg .dmb-wysiwyg textarea:focus {
  border: 1px solid var(--success);
  box-shadow: 1px 1px 2px 0 var(--default-hover) inset, 0 1px 1px var(--default-hover) inset, 0 0 8px var(--success);
  color: var(--default);
  outline: 0 none;
}

dmb-wysiwyg section:focus {
  border: 1px solid var(--success);
  box-shadow: 1px 1px 2px 0 var(--default-hover) inset, 0 1px 1px var(--default-hover) inset, 0 0 8px var(--success);
  color: var(--default);
  outline: 0 none;
}

dmb-wysiwyg .normal-button {
  border: 1px solid var(--default-hover);
  border-bottom: 0;
  position: absolute;
  right: 4em;
  top: -2em;
  width: 4em;
}

dmb-wysiwyg .source-button {
  border: 1px solid var(--default-hover);
  border-bottom: 0;
  position: absolute;
  right: -1px;
  top: -2em;
  width: 4em;
}

dmb-wysiwyg .icon:before {
  font-size: 1.5rem;
}


    @charset "UTF-8";
body { overflow-y: scroll; }

.jasmine_html-reporter { width: 100%; background-color: #eee; padding: 5px; margin: -8px; font-size: 11px; font-family: Monaco, "Lucida Console", monospace; line-height: 14px; color: #333; }

.jasmine_html-reporter a { text-decoration: none; }

.jasmine_html-reporter a:hover { text-decoration: underline; }

.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 { margin: 0; line-height: 14px; }

.jasmine_html-reporter .jasmine-banner, .jasmine_html-reporter .jasmine-symbol-summary, .jasmine_html-reporter .jasmine-summary, .jasmine_html-reporter .jasmine-result-message, .jasmine_html-reporter .jasmine-spec .jasmine-description, .jasmine_html-reporter .jasmine-spec-detail .jasmine-description, .jasmine_html-reporter .jasmine-alert .jasmine-bar, .jasmine_html-reporter .jasmine-stack-trace { padding-left: 9px; padding-right: 9px; }

.jasmine_html-reporter .jasmine-banner { position: relative; }

.jasmine_html-reporter .jasmine-banner .jasmine-title { background: url("data:image/png;base64,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") no-repeat; background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=") no-repeat, none; -moz-background-size: 100%; -o-background-size: 100%; -webkit-background-size: 100%; background-size: 100%; display: block; float: left; width: 90px; height: 25px; }

.jasmine_html-reporter .jasmine-banner .jasmine-version { margin-left: 14px; position: relative; top: 6px; }

.jasmine_html-reporter #jasmine_content { position: fixed; right: 100%; }

.jasmine_html-reporter .jasmine-version { color: #aaa; }

.jasmine_html-reporter .jasmine-banner { margin-top: 14px; }

.jasmine_html-reporter .jasmine-duration { color: #fff; float: right; line-height: 28px; padding-right: 9px; }

.jasmine_html-reporter .jasmine-symbol-summary { overflow: hidden; margin: 14px 0; }

.jasmine_html-reporter .jasmine-symbol-summary li { display: inline-block; height: 10px; width: 14px; font-size: 16px; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed { font-size: 14px; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed:before { color: #007069; content: "•"; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed { line-height: 9px; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed:before { color: #ca3a11; content: "×"; font-weight: bold; margin-left: -1px; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded { font-size: 14px; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded:before { color: #bababa; content: "•"; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-excluded-no-display { font-size: 14px; display: none; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending { line-height: 17px; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending:before { color: #ba9d37; content: "*"; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty { font-size: 14px; }

.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty:before { color: #ba9d37; content: "•"; }

.jasmine_html-reporter .jasmine-run-options { float: right; margin-right: 5px; border: 1px solid #8a4182; color: #8a4182; position: relative; line-height: 20px; }

.jasmine_html-reporter .jasmine-run-options .jasmine-trigger { cursor: pointer; padding: 8px 16px; }

.jasmine_html-reporter .jasmine-run-options .jasmine-payload { position: absolute; display: none; right: -1px; border: 1px solid #8a4182; background-color: #eee; white-space: nowrap; padding: 4px 8px; }

.jasmine_html-reporter .jasmine-run-options .jasmine-payload.jasmine-open { display: block; }

.jasmine_html-reporter .jasmine-bar { line-height: 28px; font-size: 14px; display: block; color: #eee; }

.jasmine_html-reporter .jasmine-bar.jasmine-failed, .jasmine_html-reporter .jasmine-bar.jasmine-errored { background-color: #ca3a11; border-bottom: 1px solid #eee; }

.jasmine_html-reporter .jasmine-bar.jasmine-passed { background-color: #007069; }

.jasmine_html-reporter .jasmine-bar.jasmine-incomplete { background-color: #bababa; }

.jasmine_html-reporter .jasmine-bar.jasmine-skipped { background-color: #bababa; }

.jasmine_html-reporter .jasmine-bar.jasmine-warning { background-color: #ba9d37; color: #333; }

.jasmine_html-reporter .jasmine-bar.jasmine-menu { background-color: #fff; color: #aaa; }

.jasmine_html-reporter .jasmine-bar.jasmine-menu a { color: #333; }

.jasmine_html-reporter .jasmine-bar a { color: white; }

.jasmine_html-reporter.jasmine-spec-list .jasmine-bar.jasmine-menu.jasmine-failure-list, .jasmine_html-reporter.jasmine-spec-list .jasmine-results .jasmine-failures { display: none; }

.jasmine_html-reporter.jasmine-failure-list .jasmine-bar.jasmine-menu.jasmine-spec-list, .jasmine_html-reporter.jasmine-failure-list .jasmine-summary { display: none; }

.jasmine_html-reporter .jasmine-results { margin-top: 14px; }

.jasmine_html-reporter .jasmine-summary { margin-top: 14px; }

.jasmine_html-reporter .jasmine-summary ul { list-style-type: none; margin-left: 14px; padding-top: 0; padding-left: 0; }

.jasmine_html-reporter .jasmine-summary ul.jasmine-suite { margin-top: 7px; margin-bottom: 7px; }

.jasmine_html-reporter .jasmine-summary li.jasmine-passed a { color: #007069; }

.jasmine_html-reporter .jasmine-summary li.jasmine-failed a { color: #ca3a11; }

.jasmine_html-reporter .jasmine-summary li.jasmine-empty a { color: #ba9d37; }

.jasmine_html-reporter .jasmine-summary li.jasmine-pending a { color: #ba9d37; }

.jasmine_html-reporter .jasmine-summary li.jasmine-excluded a { color: #bababa; }

.jasmine_html-reporter .jasmine-specs li.jasmine-passed a:before { content: "• "; }

.jasmine_html-reporter .jasmine-specs li.jasmine-failed a:before { content: "× "; }

.jasmine_html-reporter .jasmine-specs li.jasmine-empty a:before { content: "* "; }

.jasmine_html-reporter .jasmine-specs li.jasmine-pending a:before { content: "• "; }

.jasmine_html-reporter .jasmine-specs li.jasmine-excluded a:before { content: "• "; }

.jasmine_html-reporter .jasmine-description + .jasmine-suite { margin-top: 0; }

.jasmine_html-reporter .jasmine-suite { margin-top: 14px; }

.jasmine_html-reporter .jasmine-suite a { color: #333; }

.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail { margin-bottom: 28px; }

.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description { background-color: #ca3a11; color: white; }

.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description a { color: white; }

.jasmine_html-reporter .jasmine-result-message { padding-top: 14px; color: #333; white-space: pre-wrap; }

.jasmine_html-reporter .jasmine-result-message span.jasmine-result { display: block; }

.jasmine_html-reporter .jasmine-stack-trace { margin: 5px 0 0 0; max-height: 224px; overflow: auto; line-height: 18px; color: #666; border: 1px solid #ddd; background: white; white-space: pre; }

    </style>
</head>
<body>
        <div class="jasmine_html-reporter jasmine_failure-list">
            <div class="jasmine-banner"></div>
            <ul class="jasmine-symbol-summary"></ul>
            <div class="jasmine-alert"></div>
            <div class="jasmine-results"></div>
        </div>
        <div id="components">
        </div>
        <script type="text/javascript">
            Window.prototype.DmbEvents = {
    panelClose: {event: new Event('dmb-panel.close'), listener: 'dmb-panel.close'},
    panelOpen: {event: new Event('dmb-panel.open'), listener: 'dmb-panel.open'},
    panelClosed: {event: new Event('dmb-panel.closed'), listener: 'dmb-panel.closed'},
    panelOpened: {event: new Event('dmb-panel.opened'), listener: 'dmb-panel.opened'},
    resetValidation: {event: new Event('dmb-validation.reset'), listener: 'dmb-validation.reset'},
    validate: {event: new Event('dmb-validation.validate'), listener: 'dmb-validation.validate'},
    dialogClose: {event: new Event('dmb-dialog.close'), listener: 'dmb-dialog.close'},
    dialogOpen: {event: new Event('dmb-dialog.open'), listener: 'dmb-dialog.open'},
    pageLoaderClose: {event: new Event('dmb-page-loader.close'), listener: 'dmb-page-loader.close'},
    formSubmit: {event: new Event('dmb-form.submit'), listener: 'dmb-form.submit'},
    formBeforeValidate: {event: new Event('dmb-form.before-validate'), listener: 'dmb-form.before-validate'},
    formAfterValidate: {event: new Event('dmb-form.after-validate'), listener: 'dmb-form.after-validate'}
};

const vDom = document.cloneNode(true);

// eslint-disable-next-line no-unused-vars
class DumboFactory {
    setTemplate(template) {
        this.childrenTemplate = vDom.querySelector(`#${this.constructor.name}-template`);

        if (!this.childrenTemplate) {
            this.childrenTemplate = vDom.createElement('template');
            this.childrenTemplate.id = `${this.constructor.name}-template`;
            this.childrenTemplate.innerHTML = template;
            vDom.body.appendChild(this.childrenTemplate);
        }
    }
}

// eslint-disable-next-line no-unused-vars
class DumboDirective extends HTMLElement {
    constructor () {
        super();
    }

    setTemplate(template) {
        this.childrenTemplate = vDom.querySelector(`#${this.constructor.name}-template`);

        if (!this.childrenTemplate) {
            this.childrenTemplate = vDom.createElement('template');
            this.childrenTemplate.id = `${this.constructor.name}-template`;
            this.childrenTemplate.innerHTML = template;
            vDom.body.appendChild(this.childrenTemplate);
        }
    }

    connectedCallback() {
        let temp = null;
        let transclude = null;

        this.pre();

        if (!this.hasAttribute('rendered')) {
            if (this.childrenTemplate) {
                temp = this.childrenTemplate.content.cloneNode(true);
                transclude = temp.querySelector('[transclude]');
            }

            if (transclude) {
                transclude.innerHTML = this.innerHTML;
                this.innerHTML = null;
            }

            if (temp) {
                this.appendChild(temp);
            }

            this.setAttribute('rendered', 'true');
        }

        this.init();
    }

    pre() {}

    init() {}

    generateId(limit = 6) { return Math.random().toString(36).replace(/[^a-z]+/g, '').substring(0, limit - 1); }
}


        </script>
        <script type="text/javascript">
            class DmbDialogService {

    setMessage(dialog, msg) {
        const message = document.createElement('span');

        message.classList.add('message');
        message.textContent = msg;
        dialog.append(message);

        return true;
    }

    open() {
        const dialog = document.createElement('dmb-dialog', {is: 'dmb-dialog'});

        document.body.append(dialog);
        dialog.showModal();

        return dialog;
    }

    error(msg) {
        const dialog = document.createElement('dmb-dialog');

        document.body.append(dialog);
        dialog.error(msg);
        dialog.showModal();

        return dialog;
    }

    info(msg) {
        const dialog = document.createElement('dmb-dialog');

        document.body.append(dialog);
        dialog.info(msg);
        dialog.showModal();

        return dialog;
    }

    loader() {
        const dialog = document.createElement('dmb-dialog', {is: 'dmb-dialog'});

        dialog.classList.add('loader');
        document.body.append(dialog);
        dialog.showModal();

        return dialog;
    }

    drawer(content, size = 'small', setCloseButton = true) {
        const dialog = document.createElement('dmb-dialog', {is: 'dmb-dialog'});

        dialog.classList.add('drawer');
        dialog.classList.add(size);
        document.body.append(dialog);

        if (typeof content === 'string') {
            dialog.querySelector('.wrapper').innerHTML = content;
        } else {
            dialog.querySelector('.wrapper').append(content);
        }
        setCloseButton && dialog.setCloseButton();

        dialog.showModal();

        return dialog;
    }

    closeAll() {
        const dialogs = document.querySelectorAll('dmb-dialog');
        const items = dialogs.length;

        if (items) {
            for (let i = 0; i < items; i++) {
                dialogs[i].close('cancelled');
            }
        }

        return true;
    }
}

Window.prototype.dmbDialogService = new DmbDialogService();

class DmbNotificationService {

    success(container, msg) {
        const notification = document.createElement('dmb-notification');

        notification.classList.add('success');
        notification.innerHTML = msg;
        container.prepend(notification);

        return true;
    }

    warning(container, msg) {
        const notification = document.createElement('dmb-notification');

        notification.classList.add('warning');
        notification.innerHTML = msg;
        container.prepend(notification);

        return true;
    }

    error(container, msg) {
        const notification = document.createElement('dmb-notification');

        notification.classList.add('error');
        notification.innerHTML = msg;
        container.prepend(notification);

        return true;
    }
}

Window.prototype.dmbNotificationService = new DmbNotificationService();


        </script>
        <script type="text/javascript">
            /**
 * @dmbdoc Directive
 * @name dmbButton
 * @description Will render a button
 * @attribute type posible values: submit
 */
class DmbButton extends DumboDirective {
    constructor() {
        super();
    }

    _submitter(e) {
        const form = e.target.closest('dmb-form');
        const type = e.target.getAttribute('type');

        if (form) {
            switch (type) {
            case 'submit':
                form.submit();
                break;
            case 'reset':
                form.reset();
                break;
            }
        }
    }

    init() {
        this.addEventListener('click', this._submitter);
    }
    /**
     * Attach a method to run when event click is fired.
     * @param {function} method
     */
    click(method) {
        if (typeof method === 'function') {
            this.removeEventListener('click', this._submitter);
            this.addEventListener('click', method);
        }
    }
}
customElements.define('dmb-button', DmbButton);
class DmbClosePanel extends DumboDirective {
    constructor() {
        super();

        const template = '<i class="icon"></i>';
        
        this.setTemplate(template);
    }
    
    init() {
        const orientation = this.getAttribute('orientation') || 'right';
        const icon = this.querySelector('i.icon');
        let panel = null;

        this.classList.add(orientation);
        icon.classList.add(`icon-chevron-${orientation}`);


        this.addEventListener('click', () => {
            panel = this.closest('dmb-panel');
            panel.close();
        });
    }
}

customElements.define('dmb-close-panel', DmbClosePanel);

/**
 * 
 */
class DmbContent extends DumboDirective {
    constructor() {
        super();
    }
}
customElements.define('dmb-content', DmbContent);


class DmbDialog extends DumboDirective {
    static get observedAttributes() { return ['open']; }

    constructor() {
        super();

        const template = '<dmb-view class="wrapper" transclude>' +
                        '</dmb-view>';

        this.setTemplate(template);
        this.returnValue = null;
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        this.openValue = (newValue !== null);
    }

    close(value) {
        this.returnValue = value;
        this.removeAttribute('open');
        this.dispatchEvent(new Event('close'));
        (this.localName === 'dmb-dialog') && this.remove();
        this.dispatchEvent(new Event('close-dialog'));
        return true;
    }

    open() {
        this.hasAttribute('open') || this.setAttribute('open','');
        this.dispatchEvent(window.DmbEvents.dialogOpen.event);
    }

    showModal() {
        const buttons = this.querySelectorAll('[type="modal-answer"]');

        [].forEach.call(buttons, button => {
            button.addEventListener('click', e => {
                this.close(e.target.getAttribute('value'));
            });
        });
        this.open();
    }

    init() {
        let delay = 1000 * this.getAttribute('delay');
        this.hasAttribute('no-close') || this.setCloseButton();

        setTimeout(() => {
            this.open();
        }, delay);
    }

    setCloseButton() {
        let icon = null;

        if (!this.classList.contains('loader')) {
            icon = this.querySelector('.close-modal-button');
            if(!icon || !icon.length) {
                icon = document.createElement('i');
                icon.classList.add('icon');
                icon.classList.add('icon-cancel');
                icon.classList.add('close-modal-button');
                this.querySelector('.wrapper').prepend(icon);
                icon.addEventListener('click', (e) => {
                    e.target.closest('dmb-dialog').close('cancelled');
                });
            }
        }
    }

    isOpen() {
        return this.openValue;
    }

    setIcon(icon) {
        const iconElement = document.createElement('i');
        const wrapper = this.querySelector('.wrapper');

        iconElement.classList.add('icon');
        iconElement.classList.add(`icon-${icon}`);

        wrapper.prepend(iconElement);
    }

    error(msg) {
        const message = document.createElement('span');
        const wrapper = this.querySelector('.wrapper');

        this.setIcon('alert');
        msg = msg || '';
        this.classList.add('error');
        message.classList.add('message');
        if (typeof msg === 'string') {
            message.innerHTML = msg;
        } else {
            message.append(msg);
        }
        wrapper.append(message);
    }

    info(msg) {
        const message = document.createElement('span');
        const wrapper = this.querySelector('.wrapper');

        this.setCloseButton();
        this.setIcon('info');
        msg = msg || '';
        this.classList.add('info');
        message.classList.add('message');
        if (typeof msg === 'string') {
            message.innerHTML = msg;
        } else {
            message.append(msg);
        }
        wrapper.append(message);
    }

    prompt(options) {
        const message = document.createElement('span');
        const wrapper = this.querySelector('.wrapper');
        let msg = options.message || '';

        this.classList.add('question');
        message.classList.add('message');
        if (typeof msg === 'string') {
            message.innerHTML = msg;
        } else {
            message.append(msg);
        }
        wrapper.append(message);
    }

    onClose(fn) {
        if (typeof fn === 'function') {
            this.addEventListener('close-dialog', fn);
        }
    }
}
customElements.define('dmb-dialog', DmbDialog);
class DmbFooter extends DumboDirective {
    constructor() {
        super();
    }
    
    init() {
        const dmbview = this.parentNode.querySelector('dmb-content');

        if(dmbview) {
            dmbview.classList.add('padded-footer');
        }
    }
}

customElements.define('dmb-footer', DmbFooter);
class DmbForm extends DumboDirective {
    constructor() {
        super();
        this._valids = 0;

        this.setTemplate('<form arial-role="form" transclude></form>');
        this.form = null;
        this.callback = this.callback || null;
    }

    get valids() {
        return this._valids;
    }

    init() {
        let inputs = null;
        let item = null;

        this.form = this.querySelector('form');

        this.form.setAttribute('method', this.getAttribute('method') || 'POST');
        this.form.setAttribute('action', this.getAttribute('action') || '#');
        this.form.setAttribute('autocomplete', this.getAttribute('autocomplete') || 'on');
        this.form.setAttribute('name', this.getAttribute('dmb-name') || '');
        this.form.setAttribute('target', this.getAttribute('target') || '');
        this.form.setAttribute('id', this.getAttribute('dmb-id') || this.generateId());
        this.form.setAttribute('enctype', this.getAttribute('enctype') || 'application/x-www-form-urlencoded');

        inputs = [...this.querySelectorAll('input:not([type="submit"])')];
        if (this.querySelector('input[type="submit"]') === null || inputs.length > 1) {
            while ((item = inputs.shift())) {
                item.addEventListener('keypress', e => {
                    if (13 === e.keyCode) {
                        this.submit();
                    }
                });
            }
        }
    }

    reset() {
        this.form.reset();
    }

    validate(formElements, parentSelector) {
        let item = null;
        let hasInvalids = false;
        let parentItem = null;

        formElements.forEach(element => {
            element.closest(parentSelector).resetValidation();
        });

        this.dispatchEvent(window.DmbEvents.formBeforeValidate.event);
        while ((item = formElements.shift())) {
            if (item.closest('.novalidate') === null) {
                parentItem = item.closest(parentSelector);
                parentItem.setValidation();

                if (!item.hasAttribute('valid') && !item.hasAttribute('hidden')) {
                    item.reportValidity();
                    item.focus();
                    hasInvalids = true;
                } else {
                    this._valids++;
                }
            }
        }

        this.dispatchEvent(window.DmbEvents.formAfterValidate.event);

        return !hasInvalids;
    }

    submit() {
        this.dispatchEvent(window.DmbEvents.formSubmit.event);
        this.dispatchEvent(new Event('submit'));

        const isAsync = this.hasAttribute('async');
        const form = this.querySelector('form');
        const valid = this.validateForm();

        if(valid) {
            if (isAsync) {
                if(typeof this.callback === 'function') {
                    this.callback(this);
                }
                return false;
            } else {
                form.submit();
            }
            return true;
        }

        return false;
    }

    getFormData() {
        return new FormData(this.form);
    }

    validateForm() {
        const inputs = [...this.querySelectorAll('dmb-input[validate] input')];
        const selects = [...this.querySelectorAll('dmb-select[validate] select')];
        const textAreas = [...this.querySelectorAll('dmb-textarea[validate] textarea')];

        let totalvalidations = 0;

        this._valids = 0;
        totalvalidations = this.validate(inputs, 'dmb-input') + this.validate(selects, 'dmb-select') + this.validate(textAreas, 'dmb-textarea');

        return totalvalidations === 3;
    }
}

customElements.define('dmb-form', DmbForm);
class DmbHeader extends DumboDirective {
    constructor() {
        super();
    }

    init() {
        let titleDOM = null;

        if (this.title) {
            titleDOM = document.createElement('h2');
            titleDOM.classList.add('dmb-header-title');
            titleDOM.textContent = this.title;
            
            this.prepend(titleDOM);
        }
    }
}

customElements.define('dmb-header', DmbHeader);
/**
 * Component handle Imageloader
 * Get the elements of principal issues, and sub issues
 */ 

class DmbImageUploader extends DumboDirective {
    constructor() {
        super();

        /**
        * Creation of html
        */
        const template = '<dmb-input type="file" dmb-name="imgfile" accept="image/*"></dmb-input>' +
                         '<div class="preview"><img /></div>';

        this.setTemplate(template);
    }

    init() {
        /*
        * Get elements HTML and assing to a var
        */
        const dmbimgInput = this.querySelector('dmb-input[type="file"]');
        const imgInput = dmbimgInput.querySelector('input[type="file"]');
        const previewimg = this.querySelector('.preview img');
        
        previewimg.setAttribute('alt', this.getAttribute('img-alt') || 'Image Preview');
        this.hasAttribute('validate') && dmbimgInput.setAttribute('validate', this.getAttribute('validate'));
        this.hasAttribute('dmb-name') && dmbimgInput.setAttribute('dmb-name', this.getAttribute('dmb-name'));
        this.hasAttribute('label') && dmbimgInput.setAttribute('label', this.getAttribute('label'));
        /**
         * Check when the event change in Select Item, and create the options for display
         */
        imgInput.addEventListener('change', e => {
            this.loadFile(e.target.files[0]);
        });
    }

    loadFile (file) {
        const previewimg = this.querySelector('.preview img');
        const reader = new FileReader();
        const promise = new Promise((resolve) => {
            reader.onload = () => {
                resolve();
                previewimg.setAttribute('src', reader.result.toString());
            };
        });
        reader.readAsDataURL(file);
        return promise;
    }
}

customElements.define('dmb-image-uploader', DmbImageUploader);
class DmbInfoPop extends DumboDirective {
    constructor() {
        super();

        const template = '<div class="float-content" transclude></div>';
        
        this.setTemplate(template);
    }

    init() {
        const size = this.getAttribute('size') || 'small';

        this.querySelector('.float-content').classList.add(`float-content_${size}`);
    }

}

customElements.define('dmb-info-pop', DmbInfoPop);
class DmbInput extends DumboDirective {
    static get observedAttributes() { return ['valid','name', 'validate', 'dmb-name', 'label', 'dmb-value']; }

    constructor() {
        super();

        const template = '<label></label>' +
                        '<input type="text" placeholder="" />';

        this.setTemplate(template);
        this.isValid = false;
        this._errorInputClass = '_error';
        this.validations = {
            _required: function (value, param, input) {
                let response = {
                    valid: true,
                    error: null
                };
                param = null;

                if (typeof value === 'undefined' || value === null || value === '' || (input.getAttribute('type') === 'checkbox' && !input.checked)) {
                    response.valid = false;
                }

                return response;
            },
            _email: function (value) {
                let response = {
                        valid: true,
                        error: null
                    },
                    re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/;

                if (value && !re.test(value)) {
                    response.valid = false;
                }

                return response;
            },
            _numeric: function (value) {
                let response = {
                        valid: true,
                        error: null
                    },
                    re = /^[0-9]\d*/;

                if (value && !re.test(value)) {
                    response.valid = false;
                }

                return response;
            },
            _min: function(value, param) {
                let response = {
                    valid: true,
                    error: null
                };

                if (value && value.length < param) {
                    response.valid = false;
                }

                return response;
            },
            _max: function(value, param) {
                let response = {
                    valid: true,
                    error: null
                };

                if (value && value.length > param) {
                    response.valid = false;
                }

                return response;
            }
        };
    }

    set value(val) {
        if (this.type === 'checkbox') {
            this.checked = !!val;
        } else {
            this.querySelector('input').setAttribute('value', val);
            this.querySelector('input').value = val;
        }
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        const input = this.querySelector('input');

        switch(attr) {
        case 'valid':
            this.isValid = (newValue !== null);
            break;
        case 'name':
        case 'dmb-name':
            if (input) input.setAttribute('name', newValue);
            break;
        case 'validate':
            this.buildValidators();
            break;
        case 'label':
            if (input) {
                this.querySelector('label').innerText = newValue;
                input.setAttribute('aria-label', newValue);
                input.setAttribute('placeholder', newValue);
            }
            break;
        }
    }

    buildValidators () {
        let validators = [];
        let validatorList = (this.getAttribute('validate') || '').split(',');
        const input = this.querySelector('input');

        for (let i = 0, len = validatorList.length; i < len; i++) {
            let keyParam = validatorList[i].split(':');

            if (keyParam[0]) {
                validators.push({
                    key: keyParam[0],
                    param: keyParam.length === 2 ? keyParam[1] : null,
                    input
                });

                if (keyParam[0] === 'required' && input) {
                    this.classList.add('required');
                    input.setAttribute('required','required');
                }
            }
        }

        return validators;
    }

    _runValidators(element, validators) {
        const unknownValidator = () => {
            return {valid: false, error: 'Unknown validator type: "' + (validator || {}).key + '"'};
        };
        const type = element.getAttribute('type');
        let content = element.value.trim();
        let valid = true;
        let validator= null;
        let func = null;
        let result = null;

        if (type !== 'file') element.value = content;
        while((validator = validators.shift())) {
            func = this.validations['_' + validator.key] || unknownValidator;

            result = func(content, validator.param, validator.input);
            if (result.valid !== true) {
                valid = false;
                break;
            }
        }

        if (valid === true) {
            element.parentNode.classList.remove(this._errorInputClass);
        } else {
            element.parentNode.classList.add(this._errorInputClass);
        }

        this.isValid = valid;
        valid? element.setAttribute('valid','true') : element.removeAttribute('valid');
    }

    resetValidation() {
        let elements = this.getElementsByClassName(this._errorInputClass);
        for (let i = 0; elements.length; i++) {
            elements.item(0).classList.remove(this._errorInputClass);
        }
    }

    setValidation() {
        this._runValidators(this.querySelector('input'), this.buildValidators());
    }

    init() {
        const input = this.querySelector('input');
        const labelElement = this.querySelector('label');
        const label = this.getAttribute('label') || null;
        const placeholder = this.getAttribute('placeholder') || label;
        const masked = this.getAttribute('masked') || null;
        const autocomplete = this.getAttribute('autocomplete') || null;
        const classd = this.getAttribute('dmb-class') || null;
        const name = this.getAttribute('dmb-name') || null;
        const validate = this.getAttribute('validate') || null;
        const pattern = this.getAttribute('pattern') || null;
        const value = this.getAttribute('value') || this.getAttribute('dmb-value') || null;
        const step = this.getAttribute('step') || null;
        const type = this.getAttribute('type') || 'text';
        const checked = this.hasAttribute('checked');

        input.id = this.getAttribute('dmb-id') || this.generateId();
        input.setAttribute('type', type);

        if (label) {
            this.querySelector('label').innerText = label;
            input.setAttribute('aria-label', label);
        }
        if (placeholder) {
            input.setAttribute('placeholder', placeholder);
        }
        if (labelElement) {
            labelElement.setAttribute('for', input.id);
        }

        if (type === 'checkbox') {
            this.insertBefore(input, labelElement);
            if (checked) {
                input.setAttribute('checked', 'on');
            }
        }

        if (masked) input.setAttribute('masked', masked);
        if (autocomplete) input.setAttribute('autocomplete', autocomplete);
        if (classd) input.setAttribute('class', classd);
        if (name) input.setAttribute('name', name);
        if (validate) input.setAttribute('validate', validate);
        if (pattern) input.setAttribute('pattern', pattern);
        if (value) input.value = value;
        if (step) input.setAttribute('step', step);

        type === 'file' && this.hasAttribute('accept') && input.setAttribute('accept', this.getAttribute('accept'));

        const maskInputUppercase = (e) => {
            e.target.value = e.target.value.toUpperCase();
        };

        const maskInputAlpha = (e) => {
            const char = e.which || e.keyCode;

            if ((char < 65 || char > 90) && (char < 97 || char > 122)) {
                return false;
            }
        };

        const maskInputNumeric = (e) => {
            const char = e.which || e.keyCode;

            if (char < 48 || char > 57) {
                return false;
            }
        };

        if (this.getAttribute('masked')) {
            switch (this.getAttribute('masked')) {
            case 'alpha':
                input.onkeypress = maskInputAlpha;
                break;
            case 'numeric':
                input.onkeypress = maskInputNumeric;
                break;
            case 'uppercase':
                input.oninput = maskInputUppercase;
                break;
            }
        }

        this.buildValidators();

        input.addEventListener('blur', () => {
            this.setValidation();
        }, true);
    }
}

customElements.define('dmb-input', DmbInput);

class DmbMenuButton extends DumboDirective {
    constructor() {
        super();
        
        let template = '<i class="icon icon-bars"></i>' +
                        '<span class="legend" transclude></span>';

        this.setTemplate(template);

    }
    
    init() {
        this.addEventListener('click', () => {
            let menu = this.getAttribute('menu');
    
            if (menu.length) {
                document.querySelector(menu).showModal();
            }
        });
    }
}

customElements.define('dmb-menu-button',DmbMenuButton);

class DmbNotification extends DumboDirective {
    constructor() {
        super();

        const template = '<i class="icon icon-cancel close-notification-button"></i>' +
                        '<dmb-view class="wrapper" transclude>' +
                        '</dmb-view>';

        this.setTemplate(template);
    }

    close() {
        this.remove();
        return true;
    }

    init() {
        const icon = this.querySelector('.close-notification-button');
        icon.addEventListener('click', (e) => {
            e.target.closest('dmb-notification').close();
        });
    }
}
customElements.define('dmb-notification', DmbNotification);

class DmbPageLoader extends DumboDirective {
    constructor() {
        super();

        window.addEventListener('beforeunload', () => {
            this.classList.add('active');
        });

        document.addEventListener('readystatechange', () => setTimeout(
            () => {
                (document.readyState === 'complete') && this.classList.contains('active') && this.close();
            }, 100
        ));

        document.addEventListener('DOMContentLoaded', () => setTimeout(
            () => {
                this.classList.contains('active') && this.close();
            }, 100
        ));

        window.addEventListener(window.DmbEvents.pageLoaderClose.listener, () => this.close());
        window.addEventListener('load', () => this.close());
    }

    open() {
        !this.classList.contains('active') && this.classList.add('active');
        return true;
    }

    close() {
        this.classList.contains('active') && this.classList.remove('active');
        return true;
    }

}
customElements.define('dmb-page-loader', DmbPageLoader);

class DmbPagination extends DumboDirective {
    constructor() {
        super();
    }

    init() {
        const formTarget = this.getAttribute('filter-form') || '';
        let form = null;

        this.addEventListener('click', e => {
            const target = e.target;
            const classes = target.getAttribute('class');

            if(formTarget) {
                form = document.querySelector(formTarget);
            }

            if (/paginate-page(-\w+)?/gm.test(classes)) {
                if (form) {
                    e.preventDefault();
                    form.setAttribute('action', e.target.getAttribute('href'));
                    form.submit();
                }
            }
        });
    }
}

customElements.define('dmb-pagination', DmbPagination);

class DmbPanel extends DumboDirective {
    static get observedAttributes() { return ['source']; }

    constructor() {
        super();
        const template = '<dmb-view class="wrapper" transclude>' +
                        '</dmb-view>';

        this.setTemplate(template);
        this.returnValue = null;
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        !!newValue && newValue.length && this.loadExternalSource();
    }

    loadExternalSource() {
        const url = this.getAttribute('source');
        let wrapper = null;
        let sourceRequest = null;

        if (url && url.length) {
            sourceRequest = new Request(url);
            fetch(sourceRequest)
                .then(res => res.text())
                .then(data => {
                    wrapper = this.querySelector('.wrapper');
                    wrapper.innerHTML = data;
                });
        }

        return true;
    }

    close(value) {
        this.returnValue = value;
        this.removeAttribute('open');
        this.dispatchEvent(window.DmbEvents.panelClose.event);
        (this.localName === 'dmb-dialog') && this.remove();
        this.dispatchEvent(window.DmbEvents.dialogClose.event);
        this.dispatchEvent(window.DmbEvents.panelClosed.event);
    }

    open() {
        this.setAttribute('open','');
        this.dispatchEvent(window.DmbEvents.panelOpened.event);
        this.addEventListener('click', (e) => {
            if (this.openValue && e.target === this) {
                this.close('cancelled');
            }
        },true);
    }

    showModal() {
        const buttons = this.querySelectorAll('[type="modal-answer"]');

        [].forEach.call(buttons, button => {
            button.addEventListener('click', e => {
                this.close(e.target.getAttribute('value'));
            });
        });
        this.open();
    }

    setCloseButton() {
        let icon = null;

        if (!this.classList.contains('loader')) {
            icon = document.createElement('i');
            icon.classList.add('icon');
            icon.classList.add('icon-cancel');
            icon.classList.add('close-modal-button');
            icon.addEventListener('click', (e) => {
                e.target.closest('dmb-dialog').close('cancelled');
            });
            this.querySelector('.wrapper').prepend(icon);
        }
    }

    isOpen() {
        return this.openValue;
    }

    setIcon(icon) {
        const iconElement = document.createElement('i');
        const wrapper = this.querySelector('.wrapper');

        iconElement.classList.add('icon');
        iconElement.classList.add(`icon-${icon}`);

        wrapper.prepend(iconElement);
    }

    error(msg) {
        const message = document.createElement('span');
        const wrapper = this.querySelector('.wrapper');

        this.setCloseButton();
        this.setIcon('alert');
        msg = msg || '';
        this.classList.add('error');
        message.classList.add('message');
        message.textContent = msg;
        wrapper.append(message);
    }

    prompt(options) {
        const message = document.createElement('span');
        const wrapper = this.querySelector('.wrapper');
        let msg = options.message || '';

        this.classList.add('question');
        message.classList.add('message');
        message.textContent = msg;
        wrapper.append(message);
    }

    onClose(fn) {
        if (typeof fn === 'function') {
            this.addEventListener(window.DmbEvents.panelClose.listener, fn);
        }
    }

    init() {
        !this.classList.contains('right') && !this.classList.contains('left') && this.classList.add('right');
        !this.classList.contains('small') && !this.classList.contains('large') && this.classList.add('small');

        this.addEventListener('click', (e) => {
            e.target === this && this.close('cancelled');
        }, true);

        this.loadExternalSource();
    }
}

customElements.define('dmb-panel', DmbPanel);
class DmbSelect extends DumboDirective {
    static get observedAttributes() {
        return [
            'valid','values', 'dmb-name', 'label', 'dmb-class', 'validate', 'dmb-value'
        ];
    }

    constructor() {
        super();

        const template = '<label></label>' +
                        '<select transclude></select>';

        this.setTemplate(template);
        this.validations = {
            _required: value => {
                let response = {
                    valid: true,
                    error: null
                };

                if (typeof value === 'undefined' || value === null || value === '') {
                    response.valid = false;
                    response.error = '';
                }

                return response;
            }
        };
        this.isValid = false;
        this.valueList = [];
        this.validators = [];
        this._errorInputClass = '_error';
    }

    set values(newValues = []) {
        this.valueList = newValues;
        this.buildOptions();
    }

    get values() {
        return this.valueList;
    }

    set value(val) {
        this.querySelector('select').setAttribute('value', val);
        this.querySelector('select').value = val;
        this.dispatchEvent(new Event('change'));
    }

    init() {
        const select = this.querySelector('select');
        let value = null;
        let options = null;
        let option = null;
        let opval = null;

        this.hasAttribute('label') && (this.querySelector('label').innerText = this.getAttribute('label'));
        this.hasAttribute('label') && select.setAttribute('aria-label',this.getAttribute('label'));
        this.hasAttribute('dmb-class') && select.setAttribute('class', this.getAttribute('dmb-class'));
        select.setAttribute('name', this.getAttribute('dmb-name') || '');
        this.hasAttribute('validate') && select.setAttribute('validate',this.getAttribute('validate'));
        select.id = this.getAttribute('dmb-id') || this.generateId();
        select.multiple = this.hasAttribute('multiple');

        if (this.hasAttribute('dmb-value')) {
            value = this.getAttribute('dmb-value').trim();
            value = select.multiple ? JSON.parse(value) : value;
        }

        if (select && this.getAttribute('validate')) {
            this.validators = this.buildValidators(select, this.getAttribute('validate'));
        }

        select.addEventListener('blur', () => {
            // this._runValidators(e.target, this.validators);
            this.setValidation();
        }, {capture: true, passive: true});

        options = [...select.querySelectorAll('option')];
        if(options.length){
            while((option = options.shift())) {
                option.value = (option.getAttribute('value') || '').trim();
                opval = isNaN(option.value) ? option.value : parseInt(option.value);
                value = isNaN(value) ? value : parseInt(value);

                if ((!option.hasAttribute('selected') && opval == value) || (Array.isArray(value) && value.includes(opval))) {
                    option.setAttribute('selected',true);
                    option.selected = true;
                }

            }
        }
    }

    _runValidators(element, validators) {
        let unknownValidator = () => {
            return {valid: false, error: 'Unknown validator type: "' + (validator || {}).key + '"'};
        };
        let options = element.querySelectorAll('option');
        let content = [...options].filter(x=>x.selected).map(x=>x.value.trim() || '');
        let valid = true;
        let validator= null;
        let func = null;
        let result = null;

        !element.multiple && (content = content[0]);
        for (var i = 0, len = validators.length; i < len; i++) {
            validator = validators[i];
            func = this.validations['_' + validator.key] || unknownValidator;

            result = func(content, validator.param);
            if (result.valid !== true) {
                valid = false;
                break;
            }
        }

        if (valid === true) {
            element.parentNode.classList.remove(this._errorInputClass);
        } else {
            element.parentNode.classList.add(this._errorInputClass);
        }
        this.isValid = valid;
        valid? element.setAttribute('valid','') : element.removeAttribute('valid');
    }

    buildValidators(element, validations) {
        let validators = [];
        let validatorList = (validations || '').split(',');
        let keyParam = '';

        for (let i = 0, len = validatorList.length; i < len; i++) {
            keyParam = validatorList[i].split(':');

            if (keyParam[0]) {
                validators.push({
                    key: keyParam[0],
                    param: keyParam.length === 2 ? keyParam[1] : null
                });

                if (keyParam[0] === 'required') {
                    element.parentNode.classList.add('required');
                    element.setAttribute('required',true);
                }
            }
        }

        return validators;
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        const select = this.querySelector('select');
        const label = this.querySelector('label');

        switch(attr) {
        case 'valid':
            this.isValid = (newValue !== null);
            break;
        case 'values':
            if (!oldValue && newValue) {
                this.valueList = JSON.parse(newValue);
                this.buildOptions();
            }
            break;
        case 'dmb-name':
            if (select) select.setAttribute('name', newValue);
            break;
        case 'validate':
            if (select) this.validators = this.buildValidators(select, newValue);
            break;
        case 'dmb-value':
            if (!oldValue && newValue && select) {
                this.buildOptions();
            }
            break;
        case 'label':
            if (label) label.innerText = newValue;
            break;
        }

    }

    buildOptions() {
        let i = 0;
        let total = this.valueList.length || 0;
        let option = null;
        let value = this.getAttribute('dmb-value') || null;
        const select = this.querySelector('select');

        if (select) {
            select.innerHTML = '';
            select.multiple && value && (value = JSON.parse(value));
    
            for (i = 0; i < total; i++) {
                option = document.createElement('option');
                option.value, this.valueList[i].value;
                option.setAttribute('value',this.valueList[i].value);
                option.innerHTML = this.valueList[i].text;
                
                if (this.valueList[i].selected || (option.value.length && option.value == value) || (Array.isArray(value) && value.includes(option.value))) {
                    option.setAttribute('selected',true);
                    option.selected = true;
                }
                select.append(option);
            }
        }

        this.removeAttribute('values');
    }

    resetValidation() {
        let elements = [...this.querySelectorAll(this._errorInputClass)];
        let element = null;

        while ((element = elements.shift())) {
            element.classList.remove(this._errorInputClass);
        }
    }

    setValidation() {
        this._runValidators(this.querySelector('select'), this.validators);
    }
}

customElements.define('dmb-select', DmbSelect);
class DmbTextArea extends DumboDirective {
    static get observedAttributes() { return ['valid','name', 'validate', 'dmb-name']; }

    constructor() {
        super();

        const template = '<label></label>' +
                        '<textarea transclude>' +
                        '</textarea>';

        this.setTemplate(template);
        this.isValid = false;
        this.validators = [];
        this._errorInputClass = '_error';
        this.validations = {
            _required: function (value) {
                let response = {
                    valid: true,
                    error: null
                };

                if (typeof value === 'undefined' || value === null || value === '') {
                    response.valid = false;
                }

                return response;
            },
            _numeric: function (value) {
                let response = {
                        valid: true,
                        error: null
                    },
                    re = /^[0-9]\d*/;

                if (value && !re.test(value)) {
                    response.valid = false;
                }

                return response;
            },
            _min: function(value, param) {
                let response = {
                    valid: true,
                    error: null
                };

                if (value && value.length < param) {
                    response.valid = false;
                }

                return response;
            },
            _max: function(value, param) {
                let response = {
                    valid: true,
                    error: null
                };

                if (value && value.length > param) {
                    response.valid = false;
                }

                return response;
            }
        };
    }

    set value(val) {
        this.querySelector('textarea').innerText(val);
        this.querySelector('textarea').value = val;
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        const input = this.querySelector('textarea');

        switch(attr) {
        case 'valid':
            this.isValid = (newValue !== null);
            break;
        case 'name':
            if (input) input.setAttribute('name',newValue);
            break;
        case 'dmb-name':
            if (input) input.setAttribute('name',newValue);
            break;
        case 'validate':
            if (input) input.setAttribute('validate',newValue);
            break;
        }

    }

    init() {
        let input = this.getElementsByTagName('textarea').item(0);

        this.querySelector('label').innerText = this.getAttribute('label');
        input.setAttribute('aria-label',this.getAttribute('label') || '');
        input.setAttribute('masked',this.getAttribute('masked') || '');
        input.setAttribute('autocomplete',this.getAttribute('autocomplete') || '');
        input.setAttribute('class',this.getAttribute('dmb-class') || '');
        input.setAttribute('name',this.getAttribute('dmb-name') || '');
        input.setAttribute('validate',this.getAttribute('validate') || '');
        input.setAttribute('placeholder',this.getAttribute('placeholder') || '');
        input.setAttribute('valid','true');
        input.id = this.getAttribute('dmb-id')|| this.generateId();

        const maskInputUppercase = (e) => {
            e.target.value = e.target.value.toUpperCase();
        };

        if (input && this.getAttribute('validate')) {
            this.validators = this.buildValidators(input, this);
        }

        input.addEventListener('blur', (e) => {
            this._runValidators(e.target, this.validators);
        }, {capture: true, passive: true});

        const maskInputAlpha = (e) => {
            let char = e.which || e.keyCode;

            if ((char < 65 || char > 90) && (char < 97 || char > 122)) {
                return false;
            }
        };

        const maskInputNumeric = (e) => {
            let char = e.which || e.keyCode;

            if (char < 48 || char > 57) {
                return false;
            }
        };

        if (this.getAttribute('validate')) {
            this.validators = this.buildValidators(input, this);

            input.addEventListener('blur', (e) => {
                this._runValidators(e.target, this.validators);
            }, true);
        }

        if (this.getAttribute('masked')) {
            switch (this.getAttribute('masked')) {
            case 'alpha':
                input.onkeypress = maskInputAlpha;
                break;
            case 'numeric':
                input.onkeypress = maskInputNumeric;
                break;
            case 'uppercase':
                input.oninput = maskInputUppercase;
                break;
            }
        }
    }

    _runValidators (element, validators) {
        let unknownValidator = () => {
            return {valid: false, error: 'Unknown validator type: "' + (validator || {}).key + '"'};
        };
        let content = element.value.trim();
        let valid = true;
        let validator= null;
        let func = null;
        let result = null;

        element.value = content;
        for (var i = 0, len = validators.length; i < len; i++) {
            validator = validators[i];
            func = this.validations['_' + validator.key] || unknownValidator;

            result = func(content, validator.param);
            if (result.valid !== true) {
                valid = false;
                break;
            }
        }

        if (valid === true) {
            element.parentNode.classList.remove(this._errorInputClass);
        } else {
            element.parentNode.classList.add(this._errorInputClass);
        }
        this.isValid = valid;
        valid? element.setAttribute('valid','') : element.removeAttribute('valid');
    }

    buildValidators (element, scope) {
        let validators = [],
            validatorList = (scope.getAttribute('validate') || '').split(',');

        for (let i = 0, len = validatorList.length; i < len; i++) {
            let keyParam = validatorList[i].split(':');

            if (keyParam[0]) {
                validators.push({
                    key: keyParam[0],
                    param: keyParam.length === 2 ? keyParam[1] : null
                });

                if (keyParam[0] === 'required') {
                    element.parentNode.classList.add('required');
                    element.setAttribute('required','required');
                }
            }
        }

        return validators;
    }

    resetValidation() {
        let elements = this.getElementsByClassName(this._errorInputClass);
        for (let i = 0; elements.length; i++) {
            elements.item(0).classList.remove(this._errorInputClass);
        }
    }

    setValidation() {
        this._runValidators(this.querySelector('textarea'), this.validators);
    }
}

customElements.define('dmb-textarea', DmbTextArea);
class DmbToggle extends DumboDirective {
    static get observedAttributes() { return ['value']; }
    constructor() {
        super();

        const template = '<span class="switch"></span>';
        this.setTemplate(template);
        this.val = 0;
    }

    set value(val = 0) {
        this.val = val;
        this.setStatus();
    }

    get value() {
        return this.val;
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        switch(attr) {
        case 'value':
            this.val = parseInt(newValue);
            this.setStatus();
            break;
        }
    }

    init() {
        this.val = parseInt(this.getAttribute('value') || '0');
        this.setStatus();

        this.addEventListener('click', () => {
            this.val = 1 * !this.val;
            this.setStatus();
        });
    }

    setStatus() {
        if (this.val === 1) {
            this.classList.add('on');
        } else {
            this.classList.remove('on');
        }
    }

    /**
     * Attach a method to run when event click is fired.
     * @param {function} method
     */
    click(method) {
        if (typeof method === 'function') {
            this.addEventListener('click', method);
        }
    }
}

customElements.define('dmb-toggle', DmbToggle);
/**
 * Component handle Video uploader
 * Get the elements of principal issues, and sub issues
 */ 

class DmbVideoUploader extends DumboDirective {
    constructor() {
        super();

        /**
        * Creation of html
        */
        const template = '<dmb-input type="file" dmb-name="videofile" accept="video/*"></dmb-input>' +
                         '<div class="preview"><video controls></video></div>';
        this.setTemplate(template);
    }

    init() {
        const dmbVideoInput = this.querySelector('dmb-input[type="file"]');
        const videoInput = dmbVideoInput.querySelector('input[type="file"]');
        const willPreview = this.hasAttribute('preview') && !!this.getAttribute('preview').length;

        this.hasAttribute('validate') && dmbVideoInput.setAttribute('validate', this.getAttribute('validate'));
        this.hasAttribute('dmb-name') && dmbVideoInput.setAttribute('dmb-name', this.getAttribute('dmb-name'));
        this.hasAttribute('label') && dmbVideoInput.setAttribute('label', this.getAttribute('label'));

        willPreview && videoInput.addEventListener('change', e => {
            this.loadFile(e.target.files[0]);
        });

        willPreview || this.querySelector('.preview video').remove();
    }
    
    loadFile (file) {
        const videoComponent = this.querySelector('.preview video');
        const reader = new FileReader();
        const promise = new Promise((resolve) => {
            reader.onload = () => {
                resolve();
                videoComponent.setAttribute('src', reader.result.toString());
            };
        });
        reader.readAsDataURL(file);
        return promise;
    }
}

customElements.define('dmb-video-uploader', DmbVideoUploader);
/**
 * 
 */
class DmbView extends DumboDirective {
    constructor() {
        super();
    }
}
customElements.define('dmb-view', DmbView);

class DmbWysiwyg extends DumboDirective {
    static get observedAttributes() { return ['valid','name', 'validate', 'dmb-name']; }

    constructor() {
        super();
        const h1Icon = '<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><g><path d="M11 7h2v10h-2v-4H7v4H5V7h2v4h4V7zm6.57 0c-.594.95-1.504 1.658-2.57 2v1h2v7h2V7h-1.43z"/></g></svg>';
        const h2Icon = '<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><g><path d="M9 7h2v10H9v-4H5v4H3V7h2v4h4V7zm8 8c.51-.41.6-.62 1.06-1.05.437-.4.848-.828 1.23-1.28.334-.39.62-.82.85-1.28.2-.39.305-.822.31-1.26.005-.44-.087-.878-.27-1.28-.177-.385-.437-.726-.76-1-.346-.283-.743-.497-1.17-.63-.485-.153-.99-.227-1.5-.22-.36 0-.717.033-1.07.1-.343.06-.678.158-1 .29-.304.13-.593.295-.86.49-.287.21-.56.437-.82.68l1.24 1.22c.308-.268.643-.502 1-.7.35-.2.747-.304 1.15-.3.455-.03.906.106 1.27.38.31.278.477.684.45 1.1-.014.396-.14.78-.36 1.11-.285.453-.62.872-1 1.25-.44.43-.98.92-1.59 1.43-.61.51-1.41 1.06-2.16 1.65V17h8v-2h-4z"/></g></svg>';
        const h3Icon = '<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><g><path d="M14.11 14.218c.355.287.75.523 1.17.7.434.18.9.273 1.37.27.484.017.965-.086 1.4-.3.333-.146.55-.476.55-.84.003-.203-.05-.403-.15-.58-.123-.19-.3-.34-.51-.43-.32-.137-.655-.228-1-.27-.503-.073-1.012-.106-1.52-.1v-1.57c.742.052 1.485-.07 2.17-.36.37-.164.615-.525.63-.93.026-.318-.12-.627-.38-.81-.34-.203-.734-.3-1.13-.28-.395.013-.784.108-1.14.28-.375.167-.73.375-1.06.62l-1.22-1.39c.5-.377 1.053-.68 1.64-.9.608-.224 1.252-.336 1.9-.33.525-.007 1.05.05 1.56.17.43.1.84.277 1.21.52.325.21.595.495.79.83.19.342.287.73.28 1.12.01.48-.177.943-.52 1.28-.417.39-.916.685-1.46.86v.06c.61.14 1.175.425 1.65.83.437.382.68.94.66 1.52.005.42-.113.835-.34 1.19-.23.357-.538.657-.9.88-.408.253-.853.44-1.32.55-.514.128-1.04.192-1.57.19-.786.02-1.57-.106-2.31-.37-.59-.214-1.126-.556-1.57-1l1.12-1.41zM9 11H5V7H3v10h2v-4h4v4h2V7H9v4z"/></g></svg>';
        const h4Icon = '<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><g><path d="M11 17H9v-4H5v4H3V7h2v4h4V7h2v10zm10-2h-1v2h-2v-2h-5v-2l4.05-6H20v6h1v2zm-3-2V9l-2.79 4H18z"/></g></svg>';
        const h5Icon = '<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><g><path d="M14.09 14.19c.352.27.73.5 1.13.69.42.196.877.296 1.34.29.51.014 1.01-.125 1.44-.4.378-.253.594-.686.57-1.14.02-.45-.197-.877-.57-1.13-.406-.274-.89-.41-1.38-.39h-.47c-.135.014-.27.04-.4.08l-.41.15-.48.23-1.02-.57.28-5h6.4v1.92h-4.31L16 10.76c.222-.077.45-.138.68-.18.235-.037.472-.054.71-.05.463-.004.924.057 1.37.18.41.115.798.305 1.14.56.33.248.597.57.78.94.212.422.322.888.32 1.36.007.497-.11.99-.34 1.43-.224.417-.534.782-.91 1.07-.393.3-.837.527-1.31.67-.497.164-1.016.252-1.54.26-.788.023-1.573-.11-2.31-.39-.584-.238-1.122-.577-1.59-1l1.09-1.42zM11 17H9v-4H5v4H3V7h2v4h4V7h2v10z"/></g></svg>';
        const h6Icon = '<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><g><path d="M11 17H9v-4H5v4H3V7h2v4h4V7h2v10zm8.58-7.508c-.248-.204-.524-.37-.82-.49-.625-.242-1.317-.242-1.94 0-.3.11-.566.287-.78.52-.245.27-.432.586-.55.93-.16.46-.243.943-.25 1.43.367-.33.79-.59 1.25-.77.405-.17.84-.262 1.28-.27.415-.006.83.048 1.23.16.364.118.704.304 1 .55.295.253.528.57.68.93.193.403.302.843.32 1.29.01.468-.094.93-.3 1.35-.206.387-.49.727-.83 1-.357.287-.764.504-1.2.64-.98.31-2.033.293-3-.05-.507-.182-.968-.472-1.35-.85-.437-.416-.778-.92-1-1.48-.243-.693-.352-1.426-.32-2.16-.02-.797.11-1.59.38-2.34.215-.604.556-1.156 1-1.62.406-.416.897-.74 1.44-.95.54-.21 1.118-.314 1.7-.31.682-.02 1.36.096 2 .34.5.19.962.464 1.37.81l-1.31 1.34zm-2.39 5.84c.202 0 .405-.03.6-.09.183-.046.356-.128.51-.24.15-.136.27-.303.35-.49.092-.225.136-.467.13-.71.037-.405-.123-.804-.43-1.07-.328-.23-.72-.347-1.12-.33-.346-.002-.687.07-1 .21-.383.17-.724.418-1 .73.046.346.143.683.29 1 .108.23.257.44.44.62.152.15.337.26.54.33.225.055.46.068.69.04z"/></g></svg>';
        const undoIcon = '<svg width="100%" height="100%" role="img" xmlns="http://www.w3.org/2000/svg" aria-labelledby="undoIconTitle" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none" color="#000000"> <title id="undo">Undo last action</title> <path d="M8 15H3v-5"/> <path d="M5 13c5-5 12.575-4.275 16 1"/> <path stroke-linecap="round" d="M3 15l2-2"/> </svg>';
        const redoIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6" /><path d="M3 17a9 9 0 019-9 9 9 0 016 2.3l3 2.7" /></svg>';
        const pIcon = '<svg width="100%" height="100%" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-paragraph"><path d="M10.5 15a.5.5 0 0 1-.5-.5V2H9v12.5a.5.5 0 0 1-1 0V9H7a4 4 0 1 1 0-8h5.5a.5.5 0 0 1 0 1H11v12.5a.5.5 0 0 1-.5.5z"/></svg>';
        const linkIcon = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
        viewBox="0 0 493 493" style="enable-background:new 0 0 493 493;" xml:space="preserve">
   <g>
       <g>
           <path d="M215.6,314.05c6.8,6.6,14.7,12.4,23.5,16.4c2.1,1.2,4.4,1.9,6.7,2.8c2.2,0.9,4.5,1.7,6.9,2.2c2.4,0.6,4.5,1.3,7.1,1.7
               c2.6,0.4,5.2,0.8,7.8,1.1c2,0.2,3.3,0.2,4.9,0.3l2.4,0.1h1.2h2l9.5-0.1l19-0.3l38.1-0.9l38.1-1.1l9.5-0.3l4.8-0.1
               c1.6,0,3.7-0.2,5.5-0.4c7.5-0.4,14.8-2.2,21.9-4.4c26.3-5.2,50.8-24.7,61.6-51.4l2-5l1.5-5.2c1.1-3.3,1.8-7.3,2.4-11.2l0.4-2.9
               l0.2-2.2l0.3-4.3l0.1-1.1v-1.3v-0.3v-0.7l-0.1-2.7l-0.2-5.4c-1.2-14.5-6-28.7-13.6-41.1c-7.6-12.4-18.2-23-30.6-30.6l-4.7-2.8
               c-1.6-0.8-3.3-1.6-4.9-2.4c-3.2-1.7-6.7-2.9-10.1-4.1c-3.4-1.3-7-2-10.5-2.9c-3.7-0.8-8-1.3-11.7-1.7l-4.3-0.2l-2.2-0.1l-2.1-0.1
               h-1.1h-8.7h-17.3c-11.5-0.1-23.1-0.2-34.6-0.5c-4.1-0.1-10.5,3.4-12.6,5.8c-4,4.9,1.2,9,9,12.1c12.9,5.2,27.1,8.9,42.1,11.4
               c7.5,1.3,15.2,2.3,23,3h0.2c0.6,0-0.7,0-0.6,0l0,0l0,0h0.1l0.4,0.1l0.7,0.1l1.5,0.2l2.9,0.4c2.2,0.2,3.4,0.7,4.8,1
               c2.7,0.5,6,1.7,9,2.7c14.7,5.4,26.8,16.6,33.3,30.2c3.3,6.8,5.2,14.1,5.8,21.4c0.6,7.1-0.4,15.8-2.4,21.8
               c-4.1,13.9-13.6,26-25.8,33.5c-6.1,3.8-12.8,6.5-19.9,7.9c-1.8,0.2-3.5,0.8-5.4,0.8l-2.7,0.3c-0.9,0.1-1.7,0.2-3,0.2l-14.4,0.5
               c-9.5-0.4-19-0.7-28.5-1.1c-15.1-0.4-30.2-0.8-45.2-1l-22.6-0.2h-5.7h-2.7h-0.5l-1.4-0.1l-5.5-0.3c-1.1-0.2-2.2-0.4-3.3-0.6
               c-5-1-10.6-2.5-15.5-5c-4.9-2.5-9.6-5.6-13.8-9.3c-4.1-3.8-7.8-8.2-10.9-12.9c-3-4.9-5.3-10.1-7-15.7c-0.4-1.6-0.8-3.2-1.3-4.7
               s-0.7-3.1-1.2-4.5c-1-2.9-1.7-5.7-2.8-8.1c-2-4.8-4.6-8.4-9.2-8.7c-4.1-0.3-8.5,2.3-11.6,8.1c-1.6,2.9-2.8,6.5-3.3,10.7
               c-0.8,4.2-0.6,9,0.1,14.1C193.1,283.05,201.8,300.75,215.6,314.05z"/>
           <path d="M65.7,198.45c6.1-3.8,12.8-6.5,19.9-7.9c1.8-0.2,3.5-0.8,5.4-0.8l2.7-0.2c0.9-0.1,1.7-0.2,3-0.2l14.4-0.5
               c9.5,0.4,19,0.7,28.5,1.1c15.1,0.4,30.2,0.8,45.2,1l22.6,0.2h5.7h2.7h0.5l1.4,0.1l5.5,0.3c1.1,0.2,2.2,0.4,3.3,0.6
               c5,1,10.6,2.5,15.5,5s9.6,5.6,13.8,9.3c4.1,3.8,7.8,8.2,10.9,12.9c3,4.9,5.3,10.1,7,15.7c0.4,1.6,0.8,3.2,1.3,4.7s0.7,3.1,1.2,4.5
               c1,2.9,1.7,5.7,2.8,8.1c2,4.8,4.6,8.4,9.2,8.7c4.1,0.3,8.5-2.3,11.6-8.1c1.6-2.9,2.8-6.5,3.3-10.7c0.8-4.2,0.6-9-0.1-14.1
               c-3-18.2-11.8-36-25.6-49.2c-6.8-6.6-14.7-12.4-23.5-16.4c-2.1-1.2-4.4-1.9-6.7-2.8c-2.2-0.9-4.5-1.7-6.9-2.2
               c-2.4-0.6-4.5-1.3-7.1-1.7s-5.2-0.8-7.8-1.1c-2-0.2-3.3-0.2-5-0.3l-2.4-0.1h-1.2h-2l-9.5,0.1l-19,0.3l-38.1,0.9l-38.1,1.1
               l-9.5,0.3l-4.8,0.1c-1.6,0-3.7,0.2-5.4,0.4c-7.5,0.4-14.8,2.2-21.9,4.4c-26.3,5.2-50.8,24.7-61.6,51.4l-2,5l-1.5,5.2
               c-1.1,3.3-1.8,7.3-2.4,11.2l-0.4,2.9l-0.2,2.2l-0.3,4.3l-0.1,1.1v1.3v0.3v0.7l0.1,2.7l0.2,5.4c1.2,14.5,6,28.7,13.6,41.1
               s18.2,23,30.6,30.6l4.7,2.8c1.6,0.8,3.3,1.6,4.9,2.4c3.2,1.7,6.7,2.9,10.1,4.1c3.4,1.3,7,2,10.5,2.9c3.7,0.8,8,1.3,11.7,1.7
               l4.3,0.2l2.2,0.1l2.1,0.1h1.1h8.7h17.3c11.5,0.1,23.1,0.2,34.6,0.5c4.1,0.1,10.5-3.4,12.6-5.8c4-4.9-1.2-9-9-12.1
               c-12.9-5.2-27.1-8.9-42.1-11.4c-7.5-1.3-15.2-2.3-23-3H95c-0.6,0,0.7,0,0.6,0l0,0l0,0h-0.1l-0.4-0.1l-0.7-0.1l-1.5-0.2l-2.9-0.4
               c-2.2-0.2-3.4-0.7-4.8-1c-2.7-0.5-6-1.7-9-2.7c-14.7-5.4-26.8-16.6-33.3-30.2c-3.3-6.8-5.2-14.1-5.8-21.4
               c-0.6-7.1,0.4-15.8,2.4-21.8C44.1,218.05,53.5,206.05,65.7,198.45z"/>
       </g>
   </g>
</svg>`;
        const justifyCenterIcon = '<svg width="100%" height="100%" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><rect width="480" height="32" x="16" y="63.998" fill="var(--primary)"/><rect width="480" height="32" x="16" y="151.998" fill="var(--primary)"/><rect width="480" height="32" x="16" y="239.998" fill="var(--primary)"/><rect width="480" height="32" x="16" y="327.998" fill="var(--primary)"/><rect width="320" height="32" x="96" y="415.998" fill="var(--primary)"/></svg>';
        const justifyLeftIcon = '<svg width="100%" height="100%" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><rect width="480" height="32" x="16" y="63.998" fill="var(--primary)"/><rect width="480" height="32" x="16" y="151.998" fill="var(--primary)"/><rect width="480" height="32" x="16" y="239.998" fill="var(--primary)"/><rect width="480" height="32" x="16" y="327.998" fill="var(--primary)"/><rect width="320" height="32" x="16" y="415.998" fill="var(--primary)"/></svg>';
        const justifyRightIcon = '<svg width="100%" height="100%" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><rect width="480" height="32" x="16" y="63.998" fill="var(--primary)"/><rect width="480" height="32" x="16" y="151.998" fill="var(--primary)"/><rect width="480" height="32" x="16" y="239.998" fill="var(--primary)"/><rect width="480" height="32" x="16" y="327.998" fill="var(--primary)"/><rect width="320" height="32" x="176" y="415.998" fill="var(--primary)"/></svg>';
        const justifyFullIcon = '<svg width="100%" height="100%" viewBox="0 0 32 32" id="icon" xmlns="http://www.w3.org/2000/svg"><defs><style>.cls-1{fill:none;}</style></defs><title>text--align--justify</title><rect x="6" y="6" width="20" height="2"/><rect x="6" y="12" width="20" height="2"/><rect x="6" y="18" width="20" height="2"/><rect x="6" y="24" width="20" height="2"/><rect id="_Transparent_Rectangle_" data-name="&lt;Transparent Rectangle&gt;" class="cls-1" width="32" height="32"/></svg>';
        const superIcon = '<svg width="100%" height="100%" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g><path fill="none" d="M0 0h24v24H0z"/><path d="M11 7v13H9V7H3V5h12v2h-4zm8.55-.42a.8.8 0 1 0-1.32-.36l-1.154.33A2.001 2.001 0 0 1 19 4a2 2 0 0 1 1.373 3.454L18.744 9H21v1h-4V9l2.55-2.42z"/></g></svg>';
        const backgroundIcon = `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve">
    <g>
        <path d="M29,27H3c-0.6,0-1,0.4-1,1s0.4,1,1,1h26c0.6,0,1-0.4,1-1S29.6,27,29,27z"/>
        <path d="M6.4,16.7C6.4,16.7,6.4,16.7,6.4,16.7l7,7c0.2,0.2,0.4,0.3,0.7,0.3s0.5-0.1,0.7-0.3l6.9-6.9c0,0,0,0,0,0l1.5-1.5
            c0.4-0.4,0.4-1,0-1.4l-8.9-9c0,0,0,0,0,0l-2.5-2.5c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l1.8,1.8l-7.7,7.7c-0.4,0.4-0.4,1,0,1.4
            L6.4,16.7z M13.6,7L14,7.5c0,0,0,0,0,0l7,7L20.6,15H7.5l-1-1L13.6,7z"/>
        <path d="M25,24c1.7,0,3-1.3,3-3c0-1.4-1.8-3.2-2.3-3.7c-0.4-0.4-1-0.4-1.4,0C23.8,17.8,22,19.6,22,21C22,22.7,23.3,24,25,24z"/>
    </g>
</svg>`;
        const fontColorIcon = `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
        viewBox="0 0 485 485" style="enable-background:new 0 0 485 485;" xml:space="preserve">
   <g>
       <path d="M413.974,71.026C368.171,25.225,307.274,0,242.5,0C177.726,0,116.829,25.225,71.027,71.026
           C25.225,116.829,0,177.726,0,242.5c0,64.774,25.225,125.671,71.027,171.473S177.726,485,242.5,485H288
           c33.359,0,60.5-27.14,60.5-60.5c0-33.359-27.14-60.499-60.5-60.5c-16.817,0-30.5-13.682-30.5-30.5c0-16.817,13.683-30.5,30.5-30.5
           h136.5c33.359,0,60.5-27.14,60.5-60.5C485,177.726,459.775,116.829,413.974,71.026z M424.5,273H288c-33.359,0-60.5,27.14-60.5,60.5
           c0,33.36,27.141,60.5,60.499,60.5c16.818,0,30.501,13.683,30.501,30.5c0,16.818-13.683,30.5-30.5,30.5h-45.5
           C125.327,455,30,359.673,30,242.5S125.327,30,242.5,30S455,125.327,455,242.5C455,259.318,441.317,273,424.5,273z"/>
       <path d="M105,207.5c-19.299,0-35,15.701-35,35s15.701,35,35,35s35-15.701,35-35S124.299,207.5,105,207.5z"/>
       <path d="M328.75,93.111c-5.316-3.07-11.362-4.693-17.481-4.693c-12.475,0-24.097,6.707-30.329,17.503
           c-4.675,8.096-5.917,17.529-3.497,26.56c2.42,9.03,8.211,16.577,16.308,21.252c5.317,3.07,11.361,4.692,17.48,4.692
           c12.476,0,24.098-6.707,30.33-17.503c4.675-8.096,5.917-17.529,3.497-26.559S336.847,97.786,328.75,93.111z"/>
       <path d="M173.731,88.418c-6.119,0-12.165,1.623-17.481,4.693c-8.096,4.674-13.888,12.222-16.308,21.252
           c-2.419,9.03-1.178,18.462,3.497,26.558c6.233,10.797,17.855,17.504,30.33,17.504c6.119,0,12.164-1.623,17.481-4.692
           c8.097-4.674,13.888-12.222,16.308-21.252c2.419-9.03,1.178-18.462-3.497-26.558C197.828,95.125,186.207,88.418,173.731,88.418z"/>
   </g>
</svg>`;

        const template = '<section class="dmb-wysiwyg" >' +
                            '<div class="dmb-wysiwyg__toolbar">' +
                                `<a href="#" title="Heading 1" class="dmb-wysiwyg__toolbar-button" data-command="h1">${h1Icon}</a>` +
                                `<a href="#" title="Heading 2" class="dmb-wysiwyg__toolbar-button" data-command="h2">${h2Icon}</a>` +
                                `<a href="#" title="Heading 3" class="dmb-wysiwyg__toolbar-button" data-command="h3">${h3Icon}</a>` +
                                `<a href="#" title="Heading 4" class="dmb-wysiwyg__toolbar-button" data-command="h4">${h4Icon}</a>` +
                                `<a href="#" title="Heading 5" class="dmb-wysiwyg__toolbar-button" data-command="h5">${h5Icon}</a>` +
                                `<a href="#" title="Heading 6" class="dmb-wysiwyg__toolbar-button" data-command="h6">${h6Icon}</a>` +
                                `<a href="#" title="Undo" class="icon icon-undo dmb-wysiwyg__toolbar-button" data-command="undo">${undoIcon}</a>` +
                                `<a href="#" title="Redo" class="icon icon-redo dmb-wysiwyg__toolbar-button" data-command="redo">${redoIcon}</a>` +
                                `<a href="#" title="Paragraph" class="icon icon-pilcrow dmb-wysiwyg__toolbar-button" data-command="p">${pIcon}</a>` +
                                `<a href="#" title="Link" class="icon icon-link dmb-wysiwyg__toolbar-button" data-command="createlink">${linkIcon}</a>` +
                                `<a href="#" title="Left Align" class="icon icon-paragraph-left dmb-wysiwyg__toolbar-button" data-command="justifyLeft">${justifyLeftIcon}</a>` +
                                `<a href="#" title="Center Align" class="icon icon-paragraph-center dmb-wysiwyg__toolbar-button" data-command="justifyCenter">${justifyCenterIcon}</a>` +
                                `<a href="#" title="Justify Align" class="icon icon-paragraph-justify dmb-wysiwyg__toolbar-button" data-command="justifyFull">${justifyFullIcon}</a>` +
                                `<a href="#" title="right Align" class="icon icon-paragraph-right dmb-wysiwyg__toolbar-button" data-command="justifyRight">${justifyRightIcon}</a>` +
                                `<a href="#" title="Super" class="icon icon-superscript2 dmb-wysiwyg__toolbar-button" data-command="superscript">${superIcon}</a>` +
                                '<div title="Font Color" class="dmb-wysiwyg__toolbar-button palette">' +
                                    `${fontColorIcon}` +
                                    '<div class="fore-palette"></div>' +
                                '</div>' +
                                '<div title="Background Color" class="dmb-wysiwyg__toolbar-button back-palette">' +
                                    `${backgroundIcon}` +
                                    '<div class="fore-palette"></div>' +
                                '</div>' +
                                '<a href="#" title="View Source" class="dmb-wysiwyg__toolbar-button source-button" data-command="source" style="width: 4em;">Source</a>' +
                                '<a href="#" title="View compiled" class="dmb-wysiwyg__toolbar-button normal-button" data-command="normal" style="display:none;">Normal</a>' +
                            '</div>' +
                            '<textarea class="dmb-wysiwyg__content-content novalidate"></textarea>' +
                            '<section class="dmb-wysiwyg__content-content novalidate" contenteditable transclude>' +
                            '</section>' +
                            '<span class="error-container"></span>' +
                        '</section>';

        this.setTemplate(template);
        this.isValid = false;
        this._errorWysiwygClass = 'v_error';
        this.colorPalette = ['000000', 'FF9966', '6699FF', '99FF66','CC0000', '00CC00', '0000CC', '333333', '0066FF', 'FFFFFF'];
        this.toolbarElements = [];
        this.validations = {
            _required: function (value) {
                let response = {
                    valid: true,
                    error: null
                };
                if (typeof value === 'undefined' || value === null || value === '') {
                    response.valid = false;
                    response.error = 'Este campo es obligatorio';
                }
                return response;
            }
        };
    }

    init() {
        const forePalette = this.querySelector('.palette .fore-palette');
        const backPalette = this.querySelector('.back-palette .fore-palette');
        let hideButtons = null;
        let showButtons = null;
        let executeCommand = null;
        let a = document.createElement('a');
        let ap = document.createElement('a');
        let textArea = this.querySelector('textarea.dmb-wysiwyg__content-content');
        let form = this.closest('dmb-form') || this.closest('form');

        this.toolbarElements = this.querySelectorAll('.dmb-wysiwyg__toolbar-button');
        if (form) {
            form.addEventListener('submit', () => {
                this.syncData();
            });
        }

        a.dataset.command = 'foreColor';
        ap.dataset.command = 'backColor';
        a.setAttribute('href','#');
        ap.setAttribute('href','#');
        a.classList.add('palette-item');
        ap.classList.add('palette-item');
        a.classList.add('dmb-wysiwyg__toolbar-button');
        ap.classList.add('dmb-wysiwyg__toolbar-button');

        for (let i = 0; i < this.colorPalette.length; i++) {
            a.dataset.value = `${this.colorPalette[i]}`;
            ap.dataset.value = `${this.colorPalette[i]}`;
            a.style.backgroundColor = `#${this.colorPalette[i]}`;
            ap.style.backgroundColor = `#${this.colorPalette[i]}`;
            forePalette.append(a.cloneNode(true));
            backPalette.append(ap.cloneNode(true));
        }

        textArea.setAttribute('hidden', true);
        textArea.value = this.querySelector('textArea.dmb-wysiwyg__content-content').innerHTML;
        textArea.setAttribute('name',this.getAttribute('dmb-name') || '');
        textArea.setAttribute('validate',this.getAttribute('validate') || '');
        textArea.setAttribute('valid','true');

        hideButtons = (toolbarElements) => {
            for (let j = 0; j < toolbarElements.length; j++) {
                toolbarElements[j].style.display = 'none';
            }
        };

        showButtons = (toolbarElements) => {
            for (let j = 0; j < toolbarElements.length; j++) {
                toolbarElements[j].style.display = 'flex';
            }
        };

        executeCommand = (e) => {
            const me = e.target;
            let command = me.dataset.command;
            let value = me.dataset.value;
            let url;
            let textArea;
            let editArea;
            let selection = null;

            e.stopImmediatePropagation();
            e.stopPropagation();
            e.preventDefault();

            switch (command) {
            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
            case 'p':
                document.execCommand('formatBlock', true, command);
                break;
            case 'foreColor':
            case 'backColor':
                document.execCommand(command, true, `#${value}`);
                break;
            case 'createlink':
            case 'insertimage':
                url = prompt('Enter the link here: ','');
                if (url && url.length) {
                    document.execCommand(command, false, url);
                }
                break;
            case 'source':
                hideButtons(this.toolbarElements);
                me.parentNode.querySelector('.normal-button').style.display = 'flex';
                textArea = me.parentNode.parentNode.querySelector('textarea.dmb-wysiwyg__content-content');
                editArea = me.parentNode.parentNode.querySelector('section.dmb-wysiwyg__content-content');

                textArea.value = editArea.innerHTML;
                textArea.setAttribute('hidden', false);
                textArea.removeAttribute('hidden');
                editArea.setAttribute('hidden', true);
                break;
            case 'normal':
                showButtons(this.toolbarElements);
                me.style.display = 'none';
                textArea = me.parentNode.parentNode.querySelector('textarea.dmb-wysiwyg__content-content');
                editArea = me.parentNode.parentNode.querySelector('section.dmb-wysiwyg__content-content');

                editArea.innerHTML = textArea.value;
                editArea.setAttribute('hidden', false);
                editArea.removeAttribute('hidden');
                textArea.setAttribute('hidden', true);
                break;
            default:
                document.execCommand(command, false, null);
                break;
            }

        };

        for (let i = 0; i < this.toolbarElements.length; i++) {
            this.toolbarElements[i].addEventListener('click', executeCommand);
        }

        if (this.getAttribute('validate') && this.getAttribute('validate').length) {
            this.setValidation();
        }
    }

    buildValidators () {
        let validators = [];
        let validatorList = (this.getAttribute('validate') || '').split(',');
        let textarea = null;
        let editArea = null;

        for (let i = 0, len = validatorList.length; i < len; i++) {
            let keyParam = validatorList[i].split(':');

            if (keyParam[0]) {
                validators.push({
                    key: keyParam[0],
                    param: keyParam.length === 2 ? keyParam[1] : null
                });

                if (keyParam[0] === 'required') {
                    textarea = this.querySelector('textarea');
                    this.classList.add('required');
                    textarea.setAttribute('required','required');
                }

                if (keyParam[0] === 'required') {
                    editArea = this.querySelector('section');
                    this.classList.add('required');
                    editArea.setAttribute('required','required');
                }
            }
        }
        return validators;
    }

    _runValidators(element, validators) {
        const unknownValidator = () => {
            return {valid: false, error: 'Unknown validator type: "' + (validator || {}).key + '"'};
        };
        let content = (element.value || element.innerHTML).trim();
        let valid = true;
        let validator= null;
        let func = null;
        let result = null;
        let message = null;

        for (let i = 0, len = validators.length; i < len; i++) {
            validator = validators[i];
            func = this.validations['_' + validator.key] || unknownValidator;

            result = func(content, validator.param);
            if (result.valid !== true) {
                valid = false;
                message = result.error;
                break;
            }
        }

        if (valid === true) {
            element.parentNode.classList.remove(this._errorWysiwygClass);
            element.parentNode.querySelectorAll('.error-container').item(0).innerHTML = '';
        } else {
            element.parentNode.classList.add(this._errorWysiwygClass);
            element.parentNode.querySelectorAll('.error-container').item(0).innerHTML = message;
        }
        this.isValid = valid;
        valid? element.setAttribute('valid','') : element.removeAttribute('valid');
    }

    setValidation() {
        let validators = [];
        const textarea = this.querySelector('textarea.dmb-wysiwyg__content-content');
        const editarea = this.querySelector('section.dmb-wysiwyg__content-content');
        validators = this.buildValidators();

        textarea.addEventListener('blur', () => {
            this._runValidators(textarea, validators);
        }, true);

        editarea.addEventListener('blur', () => {
            this._runValidators(editarea, validators);
        }, true);

        document.body.addEventListener(window.DmbEvents.validate.listener, () => {
            this._runValidators(textarea, validators);
            this._runValidators(editarea, validators);
        }, true);

        document.body.addEventListener(window.DmbEvents.resetValidation.listener, () => {
            let elements = this.getElementsByClassName(this._errorWysiwygClass);

            for (let i = 0; elements.length; i++) {
                elements.item(0).classList.remove(this._errorWysiwygClass);
            }
        }, true);
    }

    syncData() {
        let textArea = this.querySelector('textarea.dmb-wysiwyg__content-content');
        let editArea = this.querySelector('section.dmb-wysiwyg__content-content');

        if (textArea.hasAttribute('hidden')) {
            textArea.value = editArea.innerHTML;
        } else {
            editArea.innerHTML = textArea.value;
        }
    }

    attributeChangedCallback(attr, oldValue, newValue) {
        const textarea = this.querySelector('textarea.dmb-wysiwyg__content-content');
        const editarea = this.querySelector('section.dmb-wysiwyg__content-content');

        switch(attr) {
        case 'valid':
            this.isValid = (newValue !== null);
            break;
        case 'name':
            if (textarea) textarea.setAttribute('name',newValue);
            break;
        case 'dmb-name':
            if (textarea) textarea.setAttribute('name',newValue);
            break;
        case 'validate':
            if (textarea) {
                textarea.setAttribute('validate',newValue);
                if (newValue && newValue.length) {
                    this.setValidation();
                }
            }
            if (editarea) {
                editarea.setAttribute('validate',newValue);
                if (newValue && newValue.length) {
                    this.setValidation();
                }
            }
            break;
        }
    }
}

customElements.define('dmb-wysiwyg', DmbWysiwyg);

        </script>

        <script type="text/javascript">
        /*
Copyright (c) 2008-2020 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// eslint-disable-next-line no-unused-vars
var getJasmineRequireObj = (function(jasmineGlobal) {
  var jasmineRequire;

  if (
    typeof module !== 'undefined' &&
    module.exports &&
    typeof exports !== 'undefined'
  ) {
    if (typeof global !== 'undefined') {
      jasmineGlobal = global;
    } else {
      jasmineGlobal = {};
    }
    jasmineRequire = exports;
  } else {
    if (
      typeof window !== 'undefined' &&
      typeof window.toString === 'function' &&
      window.toString() === '[object GjsGlobal]'
    ) {
      jasmineGlobal = window;
    }
    jasmineRequire = jasmineGlobal.jasmineRequire = {};
  }

  function getJasmineRequire() {
    return jasmineRequire;
  }

  getJasmineRequire().core = function(jRequire) {
    var j$ = {};

    jRequire.base(j$, jasmineGlobal);
    j$.util = jRequire.util(j$);
    j$.errors = jRequire.errors();
    j$.formatErrorMsg = jRequire.formatErrorMsg();
    j$.Any = jRequire.Any(j$);
    j$.Anything = jRequire.Anything(j$);
    j$.CallTracker = jRequire.CallTracker(j$);
    j$.MockDate = jRequire.MockDate();
    j$.getClearStack = jRequire.clearStack(j$);
    j$.Clock = jRequire.Clock();
    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler(j$);
    j$.Env = jRequire.Env(j$);
    j$.StackTrace = jRequire.StackTrace(j$);
    j$.ExceptionFormatter = jRequire.ExceptionFormatter(j$);
    j$.ExpectationFilterChain = jRequire.ExpectationFilterChain();
    j$.Expector = jRequire.Expector(j$);
    j$.Expectation = jRequire.Expectation(j$);
    j$.buildExpectationResult = jRequire.buildExpectationResult(j$);
    j$.JsApiReporter = jRequire.JsApiReporter(j$);
    j$.asymmetricEqualityTesterArgCompatShim = jRequire.asymmetricEqualityTesterArgCompatShim(
      j$
    );
    j$.makePrettyPrinter = jRequire.makePrettyPrinter(j$);
    j$.pp = j$.makePrettyPrinter();
    j$.MatchersUtil = jRequire.MatchersUtil(j$);
    j$.matchersUtil = new j$.MatchersUtil({
      customTesters: [],
      pp: j$.pp
    });

    j$.ObjectContaining = jRequire.ObjectContaining(j$);
    j$.ArrayContaining = jRequire.ArrayContaining(j$);
    j$.ArrayWithExactContents = jRequire.ArrayWithExactContents(j$);
    j$.MapContaining = jRequire.MapContaining(j$);
    j$.SetContaining = jRequire.SetContaining(j$);
    j$.QueueRunner = jRequire.QueueRunner(j$);
    j$.ReportDispatcher = jRequire.ReportDispatcher(j$);
    j$.Spec = jRequire.Spec(j$);
    j$.Spy = jRequire.Spy(j$);
    j$.SpyFactory = jRequire.SpyFactory(j$);
    j$.SpyRegistry = jRequire.SpyRegistry(j$);
    j$.SpyStrategy = jRequire.SpyStrategy(j$);
    j$.StringMatching = jRequire.StringMatching(j$);
    j$.UserContext = jRequire.UserContext(j$);
    j$.Suite = jRequire.Suite(j$);
    j$.Timer = jRequire.Timer();
    j$.TreeProcessor = jRequire.TreeProcessor();
    j$.version = jRequire.version();
    j$.Order = jRequire.Order();
    j$.DiffBuilder = jRequire.DiffBuilder(j$);
    j$.NullDiffBuilder = jRequire.NullDiffBuilder(j$);
    j$.ObjectPath = jRequire.ObjectPath(j$);
    j$.MismatchTree = jRequire.MismatchTree(j$);
    j$.GlobalErrors = jRequire.GlobalErrors(j$);

    j$.Truthy = jRequire.Truthy(j$);
    j$.Falsy = jRequire.Falsy(j$);
    j$.Empty = jRequire.Empty(j$);
    j$.NotEmpty = jRequire.NotEmpty(j$);

    j$.matchers = jRequire.requireMatchers(jRequire, j$);
    j$.asyncMatchers = jRequire.requireAsyncMatchers(jRequire, j$);

    return j$;
  };

  return getJasmineRequire;
})(this);

getJasmineRequireObj().requireMatchers = function(jRequire, j$) {
  var availableMatchers = [
      'nothing',
      'toBe',
      'toBeCloseTo',
      'toBeDefined',
      'toBeInstanceOf',
      'toBeFalse',
      'toBeFalsy',
      'toBeGreaterThan',
      'toBeGreaterThanOrEqual',
      'toBeLessThan',
      'toBeLessThanOrEqual',
      'toBeNaN',
      'toBeNegativeInfinity',
      'toBeNull',
      'toBePositiveInfinity',
      'toBeTrue',
      'toBeTruthy',
      'toBeUndefined',
      'toContain',
      'toEqual',
      'toHaveSize',
      'toHaveBeenCalled',
      'toHaveBeenCalledBefore',
      'toHaveBeenCalledOnceWith',
      'toHaveBeenCalledTimes',
      'toHaveBeenCalledWith',
      'toHaveClass',
      'toMatch',
      'toThrow',
      'toThrowError',
      'toThrowMatching'
    ],
    matchers = {};

  for (var i = 0; i < availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
};

getJasmineRequireObj().base = function(j$, jasmineGlobal) {
  j$.unimplementedMethod_ = function() {
    throw new Error('unimplemented method');
  };

  /**
   * Maximum object depth the pretty printer will print to.
   * Set this to a lower value to speed up pretty printing if you have large objects.
   * @name jasmine.MAX_PRETTY_PRINT_DEPTH
   * @since 1.3.0
   */
  j$.MAX_PRETTY_PRINT_DEPTH = 8;
  /**
   * Maximum number of array elements to display when pretty printing objects.
   * This will also limit the number of keys and values displayed for an object.
   * Elements past this number will be ellipised.
   * @name jasmine.MAX_PRETTY_PRINT_ARRAY_LENGTH
   * @since 2.7.0
   */
  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 50;
  /**
   * Maximum number of characters to display when pretty printing objects.
   * Characters past this number will be ellipised.
   * @name jasmine.MAX_PRETTY_PRINT_CHARS
   * @since 2.9.0
   */
  j$.MAX_PRETTY_PRINT_CHARS = 1000;
  /**
   * Default number of milliseconds Jasmine will wait for an asynchronous spec to complete.
   * @name jasmine.DEFAULT_TIMEOUT_INTERVAL
   * @since 1.3.0
   */
  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;

  j$.getGlobal = function() {
    return jasmineGlobal;
  };

  /**
   * Get the currently booted Jasmine Environment.
   *
   * @name jasmine.getEnv
   * @since 1.3.0
   * @function
   * @return {Env}
   */
  j$.getEnv = function(options) {
    var env = (j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options));
    //jasmine. singletons in here (setTimeout blah blah).
    return env;
  };

  j$.isArray_ = function(value) {
    return j$.isA_('Array', value);
  };

  j$.isObject_ = function(value) {
    return (
      !j$.util.isUndefined(value) && value !== null && j$.isA_('Object', value)
    );
  };

  j$.isString_ = function(value) {
    return j$.isA_('String', value);
  };

  j$.isNumber_ = function(value) {
    return j$.isA_('Number', value);
  };

  j$.isFunction_ = function(value) {
    return j$.isA_('Function', value);
  };

  j$.isAsyncFunction_ = function(value) {
    return j$.isA_('AsyncFunction', value);
  };

  j$.isTypedArray_ = function(value) {
    return (
      j$.isA_('Float32Array', value) ||
      j$.isA_('Float64Array', value) ||
      j$.isA_('Int16Array', value) ||
      j$.isA_('Int32Array', value) ||
      j$.isA_('Int8Array', value) ||
      j$.isA_('Uint16Array', value) ||
      j$.isA_('Uint32Array', value) ||
      j$.isA_('Uint8Array', value) ||
      j$.isA_('Uint8ClampedArray', value)
    );
  };

  j$.isA_ = function(typeName, value) {
    return j$.getType_(value) === '[object ' + typeName + ']';
  };

  j$.isError_ = function(value) {
    if (value instanceof Error) {
      return true;
    }
    if (value && value.constructor && value.constructor.constructor) {
      var valueGlobal = value.constructor.constructor('return this');
      if (j$.isFunction_(valueGlobal)) {
        valueGlobal = valueGlobal();
      }

      if (valueGlobal.Error && value instanceof valueGlobal.Error) {
        return true;
      }
    }
    return false;
  };

  j$.isAsymmetricEqualityTester_ = function(obj) {
    return obj ? j$.isA_('Function', obj.asymmetricMatch) : false;
  };

  j$.getType_ = function(value) {
    return Object.prototype.toString.apply(value);
  };

  j$.isDomNode = function(obj) {
    // Node is a function, because constructors
    return typeof jasmineGlobal.Node !== 'undefined'
      ? obj instanceof jasmineGlobal.Node
      : obj !== null &&
          typeof obj === 'object' &&
          typeof obj.nodeType === 'number' &&
          typeof obj.nodeName === 'string';
    // return obj.nodeType > 0;
  };

  j$.isMap = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      typeof jasmineGlobal.Map !== 'undefined' &&
      obj.constructor === jasmineGlobal.Map
    );
  };

  j$.isSet = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      typeof jasmineGlobal.Set !== 'undefined' &&
      obj.constructor === jasmineGlobal.Set
    );
  };

  j$.isWeakMap = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      typeof jasmineGlobal.WeakMap !== 'undefined' &&
      obj.constructor === jasmineGlobal.WeakMap
    );
  };

  j$.isDataView = function(obj) {
    return (
      obj !== null &&
      typeof obj !== 'undefined' &&
      typeof jasmineGlobal.DataView !== 'undefined' &&
      obj.constructor === jasmineGlobal.DataView
    );
  };

  j$.isPromise = function(obj) {
    return (
      typeof jasmineGlobal.Promise !== 'undefined' &&
      !!obj &&
      obj.constructor === jasmineGlobal.Promise
    );
  };

  j$.isPromiseLike = function(obj) {
    return !!obj && j$.isFunction_(obj.then);
  };

  j$.fnNameFor = function(func) {
    if (func.name) {
      return func.name;
    }

    var matches =
      func.toString().match(/^\s*function\s*(\w+)\s*\(/) ||
      func.toString().match(/^\s*\[object\s*(\w+)Constructor\]/);

    return matches ? matches[1] : '<anonymous>';
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is an instance of the specified class/constructor.
   * @name jasmine.any
   * @since 1.3.0
   * @function
   * @param {Constructor} clazz - The constructor to check against.
   */
  j$.any = function(clazz) {
    return new j$.Any(clazz);
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is not `null` and not `undefined`.
   * @name jasmine.anything
   * @since 2.2.0
   * @function
   */
  j$.anything = function() {
    return new j$.Anything();
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is `true` or anything truthy.
   * @name jasmine.truthy
   * @since 3.1.0
   * @function
   */
  j$.truthy = function() {
    return new j$.Truthy();
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is  `null`, `undefined`, `0`, `false` or anything falsey.
   * @name jasmine.falsy
   * @since 3.1.0
   * @function
   */
  j$.falsy = function() {
    return new j$.Falsy();
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is empty.
   * @name jasmine.empty
   * @since 3.1.0
   * @function
   */
  j$.empty = function() {
    return new j$.Empty();
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is not empty.
   * @name jasmine.notEmpty
   * @since 3.1.0
   * @function
   */
  j$.notEmpty = function() {
    return new j$.NotEmpty();
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared contains at least the keys and values.
   * @name jasmine.objectContaining
   * @since 1.3.0
   * @function
   * @param {Object} sample - The subset of properties that _must_ be in the actual.
   */
  j$.objectContaining = function(sample) {
    return new j$.ObjectContaining(sample);
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is a `String` that matches the `RegExp` or `String`.
   * @name jasmine.stringMatching
   * @since 2.2.0
   * @function
   * @param {RegExp|String} expected
   */
  j$.stringMatching = function(expected) {
    return new j$.StringMatching(expected);
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is an `Array` that contains at least the elements in the sample.
   * @name jasmine.arrayContaining
   * @since 2.2.0
   * @function
   * @param {Array} sample
   */
  j$.arrayContaining = function(sample) {
    return new j$.ArrayContaining(sample);
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is an `Array` that contains all of the elements in the sample in any order.
   * @name jasmine.arrayWithExactContents
   * @since 2.8.0
   * @function
   * @param {Array} sample
   */
  j$.arrayWithExactContents = function(sample) {
    return new j$.ArrayWithExactContents(sample);
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if every key/value pair in the sample passes the deep equality comparison
   * with at least one key/value pair in the actual value being compared
   * @name jasmine.mapContaining
   * @since 3.5.0
   * @function
   * @param {Map} sample - The subset of items that _must_ be in the actual.
   */
  j$.mapContaining = function(sample) {
    return new j$.MapContaining(sample);
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if every item in the sample passes the deep equality comparison
   * with at least one item in the actual value being compared
   * @name jasmine.setContaining
   * @since 3.5.0
   * @function
   * @param {Set} sample - The subset of items that _must_ be in the actual.
   */
  j$.setContaining = function(sample) {
    return new j$.SetContaining(sample);
  };

  j$.isSpy = function(putativeSpy) {
    if (!putativeSpy) {
      return false;
    }
    return (
      putativeSpy.and instanceof j$.SpyStrategy &&
      putativeSpy.calls instanceof j$.CallTracker
    );
  };
};

getJasmineRequireObj().util = function(j$) {
  var util = {};

  util.inherit = function(childClass, parentClass) {
    var Subclass = function() {};
    Subclass.prototype = parentClass.prototype;
    childClass.prototype = new Subclass();
  };

  util.htmlEscape = function(str) {
    if (!str) {
      return str;
    }
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  };

  util.argsToArray = function(args) {
    var arrayOfArgs = [];
    for (var i = 0; i < args.length; i++) {
      arrayOfArgs.push(args[i]);
    }
    return arrayOfArgs;
  };

  util.isUndefined = function(obj) {
    return obj === void 0;
  };

  util.arrayContains = function(array, search) {
    var i = array.length;
    while (i--) {
      if (array[i] === search) {
        return true;
      }
    }
    return false;
  };

  util.clone = function(obj) {
    if (Object.prototype.toString.apply(obj) === '[object Array]') {
      return obj.slice();
    }

    var cloned = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        cloned[prop] = obj[prop];
      }
    }

    return cloned;
  };

  util.cloneArgs = function(args) {
    var clonedArgs = [];
    var argsAsArray = j$.util.argsToArray(args);
    for (var i = 0; i < argsAsArray.length; i++) {
      var str = Object.prototype.toString.apply(argsAsArray[i]),
        primitives = /^\[object (Boolean|String|RegExp|Number)/;

      // All falsey values are either primitives, `null`, or `undefined.
      if (!argsAsArray[i] || str.match(primitives)) {
        clonedArgs.push(argsAsArray[i]);
      } else {
        clonedArgs.push(j$.util.clone(argsAsArray[i]));
      }
    }
    return clonedArgs;
  };

  util.getPropertyDescriptor = function(obj, methodName) {
    var descriptor,
      proto = obj;

    do {
      descriptor = Object.getOwnPropertyDescriptor(proto, methodName);
      proto = Object.getPrototypeOf(proto);
    } while (!descriptor && proto);

    return descriptor;
  };

  util.objectDifference = function(obj, toRemove) {
    var diff = {};

    for (var key in obj) {
      if (util.has(obj, key) && !util.has(toRemove, key)) {
        diff[key] = obj[key];
      }
    }

    return diff;
  };

  util.has = function(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };

  util.errorWithStack = function errorWithStack() {
    // Don't throw and catch if we don't have to, because it makes it harder
    // for users to debug their code with exception breakpoints.
    var error = new Error();

    if (error.stack) {
      return error;
    }

    // But some browsers (e.g. Phantom) only provide a stack trace if we throw.
    try {
      throw new Error();
    } catch (e) {
      return e;
    }
  };

  function callerFile() {
    var trace = new j$.StackTrace(util.errorWithStack());
    return trace.frames[2].file;
  }

  util.jasmineFile = (function() {
    var result;

    return function() {
      if (!result) {
        result = callerFile();
      }

      return result;
    };
  })();

  function StopIteration() {}
  StopIteration.prototype = Object.create(Error.prototype);
  StopIteration.prototype.constructor = StopIteration;

  // useful for maps and sets since `forEach` is the only IE11-compatible way to iterate them
  util.forEachBreakable = function(iterable, iteratee) {
    function breakLoop() {
      throw new StopIteration();
    }

    try {
      iterable.forEach(function(value, key) {
        iteratee(breakLoop, value, key, iterable);
      });
    } catch (error) {
      if (!(error instanceof StopIteration)) throw error;
    }
  };

  return util;
};

getJasmineRequireObj().Spec = function(j$) {
  function Spec(attrs) {
    this.expectationFactory = attrs.expectationFactory;
    this.asyncExpectationFactory = attrs.asyncExpectationFactory;
    this.resultCallback = attrs.resultCallback || function() {};
    this.id = attrs.id;
    this.description = attrs.description || '';
    this.queueableFn = attrs.queueableFn;
    this.beforeAndAfterFns =
      attrs.beforeAndAfterFns ||
      function() {
        return { befores: [], afters: [] };
      };
    this.userContext =
      attrs.userContext ||
      function() {
        return {};
      };
    this.onStart = attrs.onStart || function() {};
    this.getSpecName =
      attrs.getSpecName ||
      function() {
        return '';
      };
    this.expectationResultFactory =
      attrs.expectationResultFactory || function() {};
    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};
    this.catchingExceptions =
      attrs.catchingExceptions ||
      function() {
        return true;
      };
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;
    this.timer = attrs.timer || new j$.Timer();

    if (!this.queueableFn.fn) {
      this.pend();
    }

    /**
     * @typedef SpecResult
     * @property {Int} id - The unique id of this spec.
     * @property {String} description - The description passed to the {@link it} that created this spec.
     * @property {String} fullName - The full description including all ancestors of this spec.
     * @property {Expectation[]} failedExpectations - The list of expectations that failed during execution of this spec.
     * @property {Expectation[]} passedExpectations - The list of expectations that passed during execution of this spec.
     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred during execution this spec.
     * @property {String} pendingReason - If the spec is {@link pending}, this will be the reason.
     * @property {String} status - Once the spec has completed, this string represents the pass/fail status of this spec.
     * @property {number} duration - The time in ms used by the spec execution, including any before/afterEach.
     * @property {Object} properties - User-supplied properties, if any, that were set using {@link Env#setSpecProperty}
     */
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      deprecationWarnings: [],
      pendingReason: '',
      duration: null,
      properties: null
    };
  }

  Spec.prototype.addExpectationResult = function(passed, data, isError) {
    var expectationResult = this.expectationResultFactory(data);
    if (passed) {
      this.result.passedExpectations.push(expectationResult);
    } else {
      this.result.failedExpectations.push(expectationResult);

      if (this.throwOnExpectationFailure && !isError) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Spec.prototype.setSpecProperty = function(key, value) {
    this.result.properties = this.result.properties || {};
    this.result.properties[key] = value;
  };

  Spec.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Spec.prototype.expectAsync = function(actual) {
    return this.asyncExpectationFactory(actual, this);
  };

  Spec.prototype.execute = function(onComplete, excluded, failSpecWithNoExp) {
    var self = this;

    var onStart = {
      fn: function(done) {
        self.timer.start();
        self.onStart(self, done);
      }
    };

    var complete = {
      fn: function(done) {
        self.queueableFn.fn = null;
        self.result.status = self.status(excluded, failSpecWithNoExp);
        self.result.duration = self.timer.elapsed();
        self.resultCallback(self.result, done);
      }
    };

    var fns = this.beforeAndAfterFns();
    var regularFns = fns.befores.concat(this.queueableFn);

    var runnerConfig = {
      isLeaf: true,
      queueableFns: regularFns,
      cleanupFns: fns.afters,
      onException: function() {
        self.onException.apply(self, arguments);
      },
      onComplete: function() {
        onComplete(
          self.result.status === 'failed' &&
            new j$.StopExecutionError('spec failed')
        );
      },
      userContext: this.userContext()
    };

    if (this.markedPending || excluded === true) {
      runnerConfig.queueableFns = [];
      runnerConfig.cleanupFns = [];
    }

    runnerConfig.queueableFns.unshift(onStart);
    runnerConfig.cleanupFns.push(complete);

    this.queueRunnerFactory(runnerConfig);
  };

  Spec.prototype.onException = function onException(e) {
    if (Spec.isPendingSpecException(e)) {
      this.pend(extractCustomPendingMessage(e));
      return;
    }

    if (e instanceof j$.errors.ExpectationFailed) {
      return;
    }

    this.addExpectationResult(
      false,
      {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        error: e
      },
      true
    );
  };

  Spec.prototype.pend = function(message) {
    this.markedPending = true;
    if (message) {
      this.result.pendingReason = message;
    }
  };

  Spec.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Spec.prototype.status = function(excluded, failSpecWithNoExpectations) {
    if (excluded === true) {
      return 'excluded';
    }

    if (this.markedPending) {
      return 'pending';
    }

    if (
      this.result.failedExpectations.length > 0 ||
      (failSpecWithNoExpectations &&
        this.result.failedExpectations.length +
          this.result.passedExpectations.length ===
          0)
    ) {
      return 'failed';
    }

    return 'passed';
  };

  Spec.prototype.getFullName = function() {
    return this.getSpecName(this);
  };

  Spec.prototype.addDeprecationWarning = function(deprecation) {
    if (typeof deprecation === 'string') {
      deprecation = { message: deprecation };
    }
    this.result.deprecationWarnings.push(
      this.expectationResultFactory(deprecation)
    );
  };

  var extractCustomPendingMessage = function(e) {
    var fullMessage = e.toString(),
      boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),
      boilerplateEnd =
        boilerplateStart + Spec.pendingSpecExceptionMessage.length;

    return fullMessage.substr(boilerplateEnd);
  };

  Spec.pendingSpecExceptionMessage = '=> marked Pending';

  Spec.isPendingSpecException = function(e) {
    return !!(
      e &&
      e.toString &&
      e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1
    );
  };

  return Spec;
};

if (typeof window == void 0 && typeof exports == 'object') {
  /* globals exports */
  exports.Spec = jasmineRequire.Spec;
}

/*jshint bitwise: false*/

getJasmineRequireObj().Order = function() {
  function Order(options) {
    this.random = 'random' in options ? options.random : true;
    var seed = (this.seed = options.seed || generateSeed());
    this.sort = this.random ? randomOrder : naturalOrder;

    function naturalOrder(items) {
      return items;
    }

    function randomOrder(items) {
      var copy = items.slice();
      copy.sort(function(a, b) {
        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);
      });
      return copy;
    }

    function generateSeed() {
      return String(Math.random()).slice(-5);
    }

    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function
    // used to get a different output when the key changes slightly.
    // We use your return to sort the children randomly in a consistent way when
    // used in conjunction with a seed

    function jenkinsHash(key) {
      var hash, i;
      for (hash = i = 0; i < key.length; ++i) {
        hash += key.charCodeAt(i);
        hash += hash << 10;
        hash ^= hash >> 6;
      }
      hash += hash << 3;
      hash ^= hash >> 11;
      hash += hash << 15;
      return hash;
    }
  }

  return Order;
};

getJasmineRequireObj().Env = function(j$) {
  /**
   * _Note:_ Do not construct this directly, Jasmine will make one during booting.
   * @name Env
   * @since 2.0.0
   * @classdesc The Jasmine environment
   * @constructor
   */
  function Env(options) {
    options = options || {};

    var self = this;
    var global = options.global || j$.getGlobal();
    var customPromise;

    var totalSpecsDefined = 0;

    var realSetTimeout = global.setTimeout;
    var realClearTimeout = global.clearTimeout;
    var clearStack = j$.getClearStack(global);
    this.clock = new j$.Clock(
      global,
      function() {
        return new j$.DelayedFunctionScheduler();
      },
      new j$.MockDate(global)
    );

    var runnableResources = {};

    var currentSpec = null;
    var currentlyExecutingSuites = [];
    var currentDeclarationSuite = null;
    var hasFailures = false;

    /**
     * This represents the available options to configure Jasmine.
     * Options that are not provided will use their default values
     * @interface Configuration
     * @since 3.3.0
     */
    var config = {
      /**
       * Whether to randomize spec execution order
       * @name Configuration#random
       * @since 3.3.0
       * @type Boolean
       * @default true
       */
      random: true,
      /**
       * Seed to use as the basis of randomization.
       * Null causes the seed to be determined randomly at the start of execution.
       * @name Configuration#seed
       * @since 3.3.0
       * @type function
       * @default null
       */
      seed: null,
      /**
       * Whether to stop execution of the suite after the first spec failure
       * @name Configuration#failFast
       * @since 3.3.0
       * @type Boolean
       * @default false
       */
      failFast: false,
      /**
       * Whether to fail the spec if it ran no expectations. By default
       * a spec that ran no expectations is reported as passed. Setting this
       * to true will report such spec as a failure.
       * @name Configuration#failSpecWithNoExpectations
       * @since 3.5.0
       * @type Boolean
       * @default false
       */
      failSpecWithNoExpectations: false,
      /**
       * Whether to cause specs to only have one expectation failure.
       * @name Configuration#oneFailurePerSpec
       * @since 3.3.0
       * @type Boolean
       * @default false
       */
      oneFailurePerSpec: false,
      /**
       * Function to use to filter specs
       * @name Configuration#specFilter
       * @since 3.3.0
       * @type function
       * @default true
       */
      specFilter: function() {
        return true;
      },
      /**
       * Whether or not reporters should hide disabled specs from their output.
       * Currently only supported by Jasmine's HTMLReporter
       * @name Configuration#hideDisabled
       * @since 3.3.0
       * @type Boolean
       * @default false
       */
      hideDisabled: false,
      /**
       * Set to provide a custom promise library that Jasmine will use if it needs
       * to create a promise. If not set, it will default to whatever global Promise
       * library is available (if any).
       * @name Configuration#Promise
       * @since 3.5.0
       * @type function
       * @default undefined
       */
      Promise: undefined
    };

    var currentSuite = function() {
      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];
    };

    var currentRunnable = function() {
      return currentSpec || currentSuite();
    };

    var globalErrors = null;

    var installGlobalErrors = function() {
      if (globalErrors) {
        return;
      }

      globalErrors = new j$.GlobalErrors();
      globalErrors.install();
    };

    if (!options.suppressLoadErrors) {
      installGlobalErrors();
      globalErrors.pushListener(function(
        message,
        filename,
        lineno,
        colNo,
        err
      ) {
        topSuite.result.failedExpectations.push({
          passed: false,
          globalErrorType: 'load',
          message: message,
          stack: err && err.stack,
          filename: filename,
          lineno: lineno
        });
      });
    }

    /**
     * Configure your jasmine environment
     * @name Env#configure
     * @since 3.3.0
     * @argument {Configuration} configuration
     * @function
     */
    this.configure = function(configuration) {
      if (configuration.specFilter) {
        config.specFilter = configuration.specFilter;
      }

      if (configuration.hasOwnProperty('random')) {
        config.random = !!configuration.random;
      }

      if (configuration.hasOwnProperty('seed')) {
        config.seed = configuration.seed;
      }

      if (configuration.hasOwnProperty('failFast')) {
        config.failFast = configuration.failFast;
      }

      if (configuration.hasOwnProperty('failSpecWithNoExpectations')) {
        config.failSpecWithNoExpectations =
          configuration.failSpecWithNoExpectations;
      }

      if (configuration.hasOwnProperty('oneFailurePerSpec')) {
        config.oneFailurePerSpec = configuration.oneFailurePerSpec;
      }

      if (configuration.hasOwnProperty('hideDisabled')) {
        config.hideDisabled = configuration.hideDisabled;
      }

      // Don't use hasOwnProperty to check for Promise existence because Promise
      // can be initialized to undefined, either explicitly or by using the
      // object returned from Env#configuration. In particular, Karma does this.
      if (configuration.Promise) {
        if (
          typeof configuration.Promise.resolve === 'function' &&
          typeof configuration.Promise.reject === 'function'
        ) {
          customPromise = configuration.Promise;
        } else {
          throw new Error(
            'Custom promise library missing `resolve`/`reject` functions'
          );
        }
      }
    };

    /**
     * Get the current configuration for your jasmine environment
     * @name Env#configuration
     * @since 3.3.0
     * @function
     * @returns {Configuration}
     */
    this.configuration = function() {
      var result = {};
      for (var property in config) {
        result[property] = config[property];
      }
      return result;
    };

    Object.defineProperty(this, 'specFilter', {
      get: function() {
        self.deprecated(
          'Getting specFilter directly from Env is deprecated and will be removed in a future version of Jasmine, please check the specFilter option from `configuration`'
        );
        return config.specFilter;
      },
      set: function(val) {
        self.deprecated(
          'Setting specFilter directly on Env is deprecated and will be removed in a future version of Jasmine, please use the specFilter option in `configure`'
        );
        config.specFilter = val;
      }
    });

    this.setDefaultSpyStrategy = function(defaultStrategyFn) {
      if (!currentRunnable()) {
        throw new Error(
          'Default spy strategy must be set in a before function or a spec'
        );
      }
      runnableResources[
        currentRunnable().id
      ].defaultStrategyFn = defaultStrategyFn;
    };

    this.addSpyStrategy = function(name, fn) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom spy strategies must be added in a before function or a spec'
        );
      }
      runnableResources[currentRunnable().id].customSpyStrategies[name] = fn;
    };

    this.addCustomEqualityTester = function(tester) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom Equalities must be added in a before function or a spec'
        );
      }
      runnableResources[currentRunnable().id].customEqualityTesters.push(
        tester
      );
    };

    this.addMatchers = function(matchersToAdd) {
      if (!currentRunnable()) {
        throw new Error(
          'Matchers must be added in a before function or a spec'
        );
      }
      var customMatchers =
        runnableResources[currentRunnable().id].customMatchers;

      for (var matcherName in matchersToAdd) {
        customMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    this.addAsyncMatchers = function(matchersToAdd) {
      if (!currentRunnable()) {
        throw new Error(
          'Async Matchers must be added in a before function or a spec'
        );
      }
      var customAsyncMatchers =
        runnableResources[currentRunnable().id].customAsyncMatchers;

      for (var matcherName in matchersToAdd) {
        customAsyncMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    this.addCustomObjectFormatter = function(formatter) {
      if (!currentRunnable()) {
        throw new Error(
          'Custom object formatters must be added in a before function or a spec'
        );
      }

      runnableResources[currentRunnable().id].customObjectFormatters.push(
        formatter
      );
    };

    j$.Expectation.addCoreMatchers(j$.matchers);
    j$.Expectation.addAsyncCoreMatchers(j$.asyncMatchers);

    var nextSpecId = 0;
    var getNextSpecId = function() {
      return 'spec' + nextSpecId++;
    };

    var nextSuiteId = 0;
    var getNextSuiteId = function() {
      return 'suite' + nextSuiteId++;
    };

    var makePrettyPrinter = function() {
      var customObjectFormatters =
        runnableResources[currentRunnable().id].customObjectFormatters;
      return j$.makePrettyPrinter(customObjectFormatters);
    };

    var makeMatchersUtil = function() {
      var customEqualityTesters =
        runnableResources[currentRunnable().id].customEqualityTesters;
      return new j$.MatchersUtil({
        customTesters: customEqualityTesters,
        pp: makePrettyPrinter()
      });
    };

    var expectationFactory = function(actual, spec) {
      var customEqualityTesters =
        runnableResources[spec.id].customEqualityTesters;

      return j$.Expectation.factory({
        matchersUtil: makeMatchersUtil(),
        customEqualityTesters: customEqualityTesters,
        customMatchers: runnableResources[spec.id].customMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        return spec.addExpectationResult(passed, result);
      }
    };

    function recordLateExpectation(runable, runableType, result) {
      var delayedExpectationResult = {};
      Object.keys(result).forEach(function(k) {
        delayedExpectationResult[k] = result[k];
      });
      delayedExpectationResult.passed = false;
      delayedExpectationResult.globalErrorType = 'lateExpectation';
      delayedExpectationResult.message =
        runableType +
        ' "' +
        runable.getFullName() +
        '" ran a "' +
        result.matcherName +
        '" expectation after it finished.\n';

      if (result.message) {
        delayedExpectationResult.message +=
          'Message: "' + result.message + '"\n';
      }

      delayedExpectationResult.message +=
        'Did you forget to return or await the result of expectAsync?';

      topSuite.result.failedExpectations.push(delayedExpectationResult);
    }

    var asyncExpectationFactory = function(actual, spec, runableType) {
      return j$.Expectation.asyncFactory({
        matchersUtil: makeMatchersUtil(),
        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,
        customAsyncMatchers: runnableResources[spec.id].customAsyncMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        if (currentRunnable() !== spec) {
          recordLateExpectation(spec, runableType, result);
        }
        return spec.addExpectationResult(passed, result);
      }
    };
    var suiteAsyncExpectationFactory = function(actual, suite) {
      return asyncExpectationFactory(actual, suite, 'Suite');
    };

    var specAsyncExpectationFactory = function(actual, suite) {
      return asyncExpectationFactory(actual, suite, 'Spec');
    };

    var defaultResourcesForRunnable = function(id, parentRunnableId) {
      var resources = {
        spies: [],
        customEqualityTesters: [],
        customMatchers: {},
        customAsyncMatchers: {},
        customSpyStrategies: {},
        defaultStrategyFn: undefined,
        customObjectFormatters: []
      };

      if (runnableResources[parentRunnableId]) {
        resources.customEqualityTesters = j$.util.clone(
          runnableResources[parentRunnableId].customEqualityTesters
        );
        resources.customMatchers = j$.util.clone(
          runnableResources[parentRunnableId].customMatchers
        );
        resources.customAsyncMatchers = j$.util.clone(
          runnableResources[parentRunnableId].customAsyncMatchers
        );
        resources.defaultStrategyFn =
          runnableResources[parentRunnableId].defaultStrategyFn;
      }

      runnableResources[id] = resources;
    };

    var clearResourcesForRunnable = function(id) {
      spyRegistry.clearSpies();
      delete runnableResources[id];
    };

    var beforeAndAfterFns = function(suite) {
      return function() {
        var befores = [],
          afters = [];

        while (suite) {
          befores = befores.concat(suite.beforeFns);
          afters = afters.concat(suite.afterFns);

          suite = suite.parentSuite;
        }

        return {
          befores: befores.reverse(),
          afters: afters
        };
      };
    };

    var getSpecName = function(spec, suite) {
      var fullName = [spec.description],
        suiteFullName = suite.getFullName();

      if (suiteFullName !== '') {
        fullName.unshift(suiteFullName);
      }
      return fullName.join(' ');
    };

    // TODO: we may just be able to pass in the fn instead of wrapping here
    var buildExpectationResult = j$.buildExpectationResult,
      exceptionFormatter = new j$.ExceptionFormatter(),
      expectationResultFactory = function(attrs) {
        attrs.messageFormatter = exceptionFormatter.message;
        attrs.stackFormatter = exceptionFormatter.stack;

        return buildExpectationResult(attrs);
      };

    /**
     * Sets whether Jasmine should throw an Error when an expectation fails.
     * This causes a spec to only have one expectation failure.
     * @name Env#throwOnExpectationFailure
     * @since 2.3.0
     * @function
     * @param {Boolean} value Whether to throw when a expectation fails
     * @deprecated Use the `oneFailurePerSpec` option with {@link Env#configure}
     */
    this.throwOnExpectationFailure = function(value) {
      this.deprecated(
        'Setting throwOnExpectationFailure directly on Env is deprecated and will be removed in a future version of Jasmine, please use the oneFailurePerSpec option in `configure`'
      );
      this.configure({ oneFailurePerSpec: !!value });
    };

    this.throwingExpectationFailures = function() {
      this.deprecated(
        'Getting throwingExpectationFailures directly from Env is deprecated and will be removed in a future version of Jasmine, please check the oneFailurePerSpec option from `configuration`'
      );
      return config.oneFailurePerSpec;
    };

    /**
     * Set whether to stop suite execution when a spec fails
     * @name Env#stopOnSpecFailure
     * @since 2.7.0
     * @function
     * @param {Boolean} value Whether to stop suite execution when a spec fails
     * @deprecated Use the `failFast` option with {@link Env#configure}
     */
    this.stopOnSpecFailure = function(value) {
      this.deprecated(
        'Setting stopOnSpecFailure directly is deprecated and will be removed in a future version of Jasmine, please use the failFast option in `configure`'
      );
      this.configure({ failFast: !!value });
    };

    this.stoppingOnSpecFailure = function() {
      this.deprecated(
        'Getting stoppingOnSpecFailure directly from Env is deprecated and will be removed in a future version of Jasmine, please check the failFast option from `configuration`'
      );
      return config.failFast;
    };

    /**
     * Set whether to randomize test execution order
     * @name Env#randomizeTests
     * @since 2.4.0
     * @function
     * @param {Boolean} value Whether to randomize execution order
     * @deprecated Use the `random` option with {@link Env#configure}
     */
    this.randomizeTests = function(value) {
      this.deprecated(
        'Setting randomizeTests directly is deprecated and will be removed in a future version of Jasmine, please use the random option in `configure`'
      );
      config.random = !!value;
    };

    this.randomTests = function() {
      this.deprecated(
        'Getting randomTests directly from Env is deprecated and will be removed in a future version of Jasmine, please check the random option from `configuration`'
      );
      return config.random;
    };

    /**
     * Set the random number seed for spec randomization
     * @name Env#seed
     * @since 2.4.0
     * @function
     * @param {Number} value The seed value
     * @deprecated Use the `seed` option with {@link Env#configure}
     */
    this.seed = function(value) {
      this.deprecated(
        'Setting seed directly is deprecated and will be removed in a future version of Jasmine, please use the seed option in `configure`'
      );
      if (value) {
        config.seed = value;
      }
      return config.seed;
    };

    this.hidingDisabled = function(value) {
      this.deprecated(
        'Getting hidingDisabled directly from Env is deprecated and will be removed in a future version of Jasmine, please check the hideDisabled option from `configuration`'
      );
      return config.hideDisabled;
    };

    /**
     * @name Env#hideDisabled
     * @since 3.2.0
     * @function
     */
    this.hideDisabled = function(value) {
      this.deprecated(
        'Setting hideDisabled directly is deprecated and will be removed in a future version of Jasmine, please use the hideDisabled option in `configure`'
      );
      config.hideDisabled = !!value;
    };

    this.deprecated = function(deprecation) {
      var runnable = currentRunnable() || topSuite;
      runnable.addDeprecationWarning(deprecation);
      if (
        typeof console !== 'undefined' &&
        typeof console.error === 'function'
      ) {
        console.error('DEPRECATION:', deprecation);
      }
    };

    var queueRunnerFactory = function(options, args) {
      var failFast = false;
      if (options.isLeaf) {
        failFast = config.oneFailurePerSpec;
      } else if (!options.isReporter) {
        failFast = config.failFast;
      }
      options.clearStack = options.clearStack || clearStack;
      options.timeout = {
        setTimeout: realSetTimeout,
        clearTimeout: realClearTimeout
      };
      options.fail = self.fail;
      options.globalErrors = globalErrors;
      options.completeOnFirstError = failFast;
      options.onException =
        options.onException ||
        function(e) {
          (currentRunnable() || topSuite).onException(e);
        };
      options.deprecated = self.deprecated;

      new j$.QueueRunner(options).execute(args);
    };

    var topSuite = new j$.Suite({
      env: this,
      id: getNextSuiteId(),
      description: 'Jasmine__TopLevel__Suite',
      expectationFactory: expectationFactory,
      asyncExpectationFactory: suiteAsyncExpectationFactory,
      expectationResultFactory: expectationResultFactory
    });
    defaultResourcesForRunnable(topSuite.id);
    currentDeclarationSuite = topSuite;

    this.topSuite = function() {
      return topSuite;
    };

    /**
     * This represents the available reporter callback for an object passed to {@link Env#addReporter}.
     * @interface Reporter
     * @see custom_reporter
     */
    var reporter = new j$.ReportDispatcher(
      [
        /**
         * `jasmineStarted` is called after all of the specs have been loaded, but just before execution starts.
         * @function
         * @name Reporter#jasmineStarted
         * @param {JasmineStartedInfo} suiteInfo Information about the full Jasmine suite that is being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'jasmineStarted',
        /**
         * When the entire suite has finished execution `jasmineDone` is called
         * @function
         * @name Reporter#jasmineDone
         * @param {JasmineDoneInfo} suiteInfo Information about the full Jasmine suite that just finished running.
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'jasmineDone',
        /**
         * `suiteStarted` is invoked when a `describe` starts to run
         * @function
         * @name Reporter#suiteStarted
         * @param {SuiteResult} result Information about the individual {@link describe} being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'suiteStarted',
        /**
         * `suiteDone` is invoked when all of the child specs and suites for a given suite have been run
         *
         * While jasmine doesn't require any specific functions, not defining a `suiteDone` will make it impossible for a reporter to know when a suite has failures in an `afterAll`.
         * @function
         * @name Reporter#suiteDone
         * @param {SuiteResult} result
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'suiteDone',
        /**
         * `specStarted` is invoked when an `it` starts to run (including associated `beforeEach` functions)
         * @function
         * @name Reporter#specStarted
         * @param {SpecResult} result Information about the individual {@link it} being run
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'specStarted',
        /**
         * `specDone` is invoked when an `it` and its associated `beforeEach` and `afterEach` functions have been run.
         *
         * While jasmine doesn't require any specific functions, not defining a `specDone` will make it impossible for a reporter to know when a spec has failed.
         * @function
         * @name Reporter#specDone
         * @param {SpecResult} result
         * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
         * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
         * @see async
         */
        'specDone'
      ],
      queueRunnerFactory
    );

    this.execute = function(runnablesToRun) {
      installGlobalErrors();

      if (!runnablesToRun) {
        if (focusedRunnables.length) {
          runnablesToRun = focusedRunnables;
        } else {
          runnablesToRun = [topSuite.id];
        }
      }

      var order = new j$.Order({
        random: config.random,
        seed: config.seed
      });

      var processor = new j$.TreeProcessor({
        tree: topSuite,
        runnableIds: runnablesToRun,
        queueRunnerFactory: queueRunnerFactory,
        failSpecWithNoExpectations: config.failSpecWithNoExpectations,
        nodeStart: function(suite, next) {
          currentlyExecutingSuites.push(suite);
          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);
          reporter.suiteStarted(suite.result, next);
          suite.startTimer();
        },
        nodeComplete: function(suite, result, next) {
          if (suite !== currentSuite()) {
            throw new Error('Tried to complete the wrong suite');
          }

          clearResourcesForRunnable(suite.id);
          currentlyExecutingSuites.pop();

          if (result.status === 'failed') {
            hasFailures = true;
          }
          suite.endTimer();
          reporter.suiteDone(result, next);
        },
        orderChildren: function(node) {
          return order.sort(node.children);
        },
        excludeNode: function(spec) {
          return !config.specFilter(spec);
        }
      });

      if (!processor.processTree().valid) {
        throw new Error(
          'Invalid order: would cause a beforeAll or afterAll to be run multiple times'
        );
      }

      var jasmineTimer = new j$.Timer();
      jasmineTimer.start();

      /**
       * Information passed to the {@link Reporter#jasmineStarted} event.
       * @typedef JasmineStartedInfo
       * @property {Int} totalSpecsDefined - The total number of specs defined in this suite.
       * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.
       */
      reporter.jasmineStarted(
        {
          totalSpecsDefined: totalSpecsDefined,
          order: order
        },
        function() {
          currentlyExecutingSuites.push(topSuite);

          processor.execute(function() {
            clearResourcesForRunnable(topSuite.id);
            currentlyExecutingSuites.pop();
            var overallStatus, incompleteReason;

            if (hasFailures || topSuite.result.failedExpectations.length > 0) {
              overallStatus = 'failed';
            } else if (focusedRunnables.length > 0) {
              overallStatus = 'incomplete';
              incompleteReason = 'fit() or fdescribe() was found';
            } else if (totalSpecsDefined === 0) {
              overallStatus = 'incomplete';
              incompleteReason = 'No specs found';
            } else {
              overallStatus = 'passed';
            }

            /**
             * Information passed to the {@link Reporter#jasmineDone} event.
             * @typedef JasmineDoneInfo
             * @property {OverallStatus} overallStatus - The overall result of the suite: 'passed', 'failed', or 'incomplete'.
             * @property {Int} totalTime - The total time (in ms) that it took to execute the suite
             * @property {IncompleteReason} incompleteReason - Explanation of why the suite was incomplete.
             * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.
             * @property {Expectation[]} failedExpectations - List of expectations that failed in an {@link afterAll} at the global level.
             * @property {Expectation[]} deprecationWarnings - List of deprecation warnings that occurred at the global level.
             */
            reporter.jasmineDone(
              {
                overallStatus: overallStatus,
                totalTime: jasmineTimer.elapsed(),
                incompleteReason: incompleteReason,
                order: order,
                failedExpectations: topSuite.result.failedExpectations,
                deprecationWarnings: topSuite.result.deprecationWarnings
              },
              function() {}
            );
          });
        }
      );
    };

    /**
     * Add a custom reporter to the Jasmine environment.
     * @name Env#addReporter
     * @since 2.0.0
     * @function
     * @param {Reporter} reporterToAdd The reporter to be added.
     * @see custom_reporter
     */
    this.addReporter = function(reporterToAdd) {
      reporter.addReporter(reporterToAdd);
    };

    /**
     * Provide a fallback reporter if no other reporters have been specified.
     * @name Env#provideFallbackReporter
     * @since 2.5.0
     * @function
     * @param {Reporter} reporterToAdd The reporter
     * @see custom_reporter
     */
    this.provideFallbackReporter = function(reporterToAdd) {
      reporter.provideFallbackReporter(reporterToAdd);
    };

    /**
     * Clear all registered reporters
     * @name Env#clearReporters
     * @since 2.5.2
     * @function
     */
    this.clearReporters = function() {
      reporter.clearReporters();
    };

    var spyFactory = new j$.SpyFactory(
      function getCustomStrategies() {
        var runnable = currentRunnable();

        if (runnable) {
          return runnableResources[runnable.id].customSpyStrategies;
        }

        return {};
      },
      function getDefaultStrategyFn() {
        var runnable = currentRunnable();

        if (runnable) {
          return runnableResources[runnable.id].defaultStrategyFn;
        }

        return undefined;
      },
      function getPromise() {
        return customPromise || global.Promise;
      }
    );

    var spyRegistry = new j$.SpyRegistry({
      currentSpies: function() {
        if (!currentRunnable()) {
          throw new Error(
            'Spies must be created in a before function or a spec'
          );
        }
        return runnableResources[currentRunnable().id].spies;
      },
      createSpy: function(name, originalFn) {
        return self.createSpy(name, originalFn);
      }
    });

    this.allowRespy = function(allow) {
      spyRegistry.allowRespy(allow);
    };

    this.spyOn = function() {
      return spyRegistry.spyOn.apply(spyRegistry, arguments);
    };

    this.spyOnProperty = function() {
      return spyRegistry.spyOnProperty.apply(spyRegistry, arguments);
    };

    this.spyOnAllFunctions = function() {
      return spyRegistry.spyOnAllFunctions.apply(spyRegistry, arguments);
    };

    this.createSpy = function(name, originalFn) {
      if (arguments.length === 1 && j$.isFunction_(name)) {
        originalFn = name;
        name = originalFn.name;
      }

      return spyFactory.createSpy(name, originalFn);
    };

    this.createSpyObj = function(baseName, methodNames, propertyNames) {
      return spyFactory.createSpyObj(baseName, methodNames, propertyNames);
    };

    var ensureIsFunction = function(fn, caller) {
      if (!j$.isFunction_(fn)) {
        throw new Error(
          caller + ' expects a function argument; received ' + j$.getType_(fn)
        );
      }
    };

    var ensureIsFunctionOrAsync = function(fn, caller) {
      if (!j$.isFunction_(fn) && !j$.isAsyncFunction_(fn)) {
        throw new Error(
          caller + ' expects a function argument; received ' + j$.getType_(fn)
        );
      }
    };

    function ensureIsNotNested(method) {
      var runnable = currentRunnable();
      if (runnable !== null && runnable !== undefined) {
        throw new Error(
          "'" + method + "' should only be used in 'describe' function"
        );
      }
    }

    var suiteFactory = function(description) {
      var suite = new j$.Suite({
        env: self,
        id: getNextSuiteId(),
        description: description,
        parentSuite: currentDeclarationSuite,
        timer: new j$.Timer(),
        expectationFactory: expectationFactory,
        asyncExpectationFactory: suiteAsyncExpectationFactory,
        expectationResultFactory: expectationResultFactory,
        throwOnExpectationFailure: config.oneFailurePerSpec
      });

      return suite;
    };

    this.describe = function(description, specDefinitions) {
      ensureIsNotNested('describe');
      ensureIsFunction(specDefinitions, 'describe');
      var suite = suiteFactory(description);
      if (specDefinitions.length > 0) {
        throw new Error('describe does not expect any arguments');
      }
      if (currentDeclarationSuite.markedPending) {
        suite.pend();
      }
      addSpecsToSuite(suite, specDefinitions);
      return suite;
    };

    this.xdescribe = function(description, specDefinitions) {
      ensureIsNotNested('xdescribe');
      ensureIsFunction(specDefinitions, 'xdescribe');
      var suite = suiteFactory(description);
      suite.pend();
      addSpecsToSuite(suite, specDefinitions);
      return suite;
    };

    var focusedRunnables = [];

    this.fdescribe = function(description, specDefinitions) {
      ensureIsNotNested('fdescribe');
      ensureIsFunction(specDefinitions, 'fdescribe');
      var suite = suiteFactory(description);
      suite.isFocused = true;

      focusedRunnables.push(suite.id);
      unfocusAncestor();
      addSpecsToSuite(suite, specDefinitions);

      return suite;
    };

    function addSpecsToSuite(suite, specDefinitions) {
      var parentSuite = currentDeclarationSuite;
      parentSuite.addChild(suite);
      currentDeclarationSuite = suite;

      var declarationError = null;
      try {
        specDefinitions.call(suite);
      } catch (e) {
        declarationError = e;
      }

      if (declarationError) {
        suite.onException(declarationError);
      }

      currentDeclarationSuite = parentSuite;
    }

    function findFocusedAncestor(suite) {
      while (suite) {
        if (suite.isFocused) {
          return suite.id;
        }
        suite = suite.parentSuite;
      }

      return null;
    }

    function unfocusAncestor() {
      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);
      if (focusedAncestor) {
        for (var i = 0; i < focusedRunnables.length; i++) {
          if (focusedRunnables[i] === focusedAncestor) {
            focusedRunnables.splice(i, 1);
            break;
          }
        }
      }
    }

    var specFactory = function(description, fn, suite, timeout) {
      totalSpecsDefined++;
      var spec = new j$.Spec({
        id: getNextSpecId(),
        beforeAndAfterFns: beforeAndAfterFns(suite),
        expectationFactory: expectationFactory,
        asyncExpectationFactory: specAsyncExpectationFactory,
        resultCallback: specResultCallback,
        getSpecName: function(spec) {
          return getSpecName(spec, suite);
        },
        onStart: specStarted,
        description: description,
        expectationResultFactory: expectationResultFactory,
        queueRunnerFactory: queueRunnerFactory,
        userContext: function() {
          return suite.clonedSharedUserContext();
        },
        queueableFn: {
          fn: fn,
          timeout: timeout || 0
        },
        throwOnExpectationFailure: config.oneFailurePerSpec,
        timer: new j$.Timer()
      });
      return spec;

      function specResultCallback(result, next) {
        clearResourcesForRunnable(spec.id);
        currentSpec = null;

        if (result.status === 'failed') {
          hasFailures = true;
        }

        reporter.specDone(result, next);
      }

      function specStarted(spec, next) {
        currentSpec = spec;
        defaultResourcesForRunnable(spec.id, suite.id);
        reporter.specStarted(spec.result, next);
      }
    };

    this.it = function(description, fn, timeout) {
      ensureIsNotNested('it');
      // it() sometimes doesn't have a fn argument, so only check the type if
      // it's given.
      if (arguments.length > 1 && typeof fn !== 'undefined') {
        ensureIsFunctionOrAsync(fn, 'it');
      }
      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      if (currentDeclarationSuite.markedPending) {
        spec.pend();
      }
      currentDeclarationSuite.addChild(spec);
      return spec;
    };

    this.xit = function(description, fn, timeout) {
      ensureIsNotNested('xit');
      // xit(), like it(), doesn't always have a fn argument, so only check the
      // type when needed.
      if (arguments.length > 1 && typeof fn !== 'undefined') {
        ensureIsFunctionOrAsync(fn, 'xit');
      }
      var spec = this.it.apply(this, arguments);
      spec.pend('Temporarily disabled with xit');
      return spec;
    };

    this.fit = function(description, fn, timeout) {
      ensureIsNotNested('fit');
      ensureIsFunctionOrAsync(fn, 'fit');
      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      currentDeclarationSuite.addChild(spec);
      focusedRunnables.push(spec.id);
      unfocusAncestor();
      return spec;
    };

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SpecResult}
     * @name Env#setSpecProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    this.setSpecProperty = function(key, value) {
      if (!currentRunnable() || currentRunnable() == currentSuite()) {
        throw new Error(
          "'setSpecProperty' was used when there was no current spec"
        );
      }
      currentRunnable().setSpecProperty(key, value);
    };

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SuiteResult}
     * @name Env#setSuiteProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    this.setSuiteProperty = function(key, value) {
      if (!currentSuite()) {
        throw new Error(
          "'setSuiteProperty' was used when there was no current suite"
        );
      }
      currentSuite().setSuiteProperty(key, value);
    };

    this.expect = function(actual) {
      if (!currentRunnable()) {
        throw new Error(
          "'expect' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      return currentRunnable().expect(actual);
    };

    this.expectAsync = function(actual) {
      if (!currentRunnable()) {
        throw new Error(
          "'expectAsync' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      return currentRunnable().expectAsync(actual);
    };

    this.beforeEach = function(beforeEachFunction, timeout) {
      ensureIsNotNested('beforeEach');
      ensureIsFunctionOrAsync(beforeEachFunction, 'beforeEach');
      currentDeclarationSuite.beforeEach({
        fn: beforeEachFunction,
        timeout: timeout || 0
      });
    };

    this.beforeAll = function(beforeAllFunction, timeout) {
      ensureIsNotNested('beforeAll');
      ensureIsFunctionOrAsync(beforeAllFunction, 'beforeAll');
      currentDeclarationSuite.beforeAll({
        fn: beforeAllFunction,
        timeout: timeout || 0
      });
    };

    this.afterEach = function(afterEachFunction, timeout) {
      ensureIsNotNested('afterEach');
      ensureIsFunctionOrAsync(afterEachFunction, 'afterEach');
      afterEachFunction.isCleanup = true;
      currentDeclarationSuite.afterEach({
        fn: afterEachFunction,
        timeout: timeout || 0
      });
    };

    this.afterAll = function(afterAllFunction, timeout) {
      ensureIsNotNested('afterAll');
      ensureIsFunctionOrAsync(afterAllFunction, 'afterAll');
      currentDeclarationSuite.afterAll({
        fn: afterAllFunction,
        timeout: timeout || 0
      });
    };

    this.pending = function(message) {
      var fullMessage = j$.Spec.pendingSpecExceptionMessage;
      if (message) {
        fullMessage += message;
      }
      throw fullMessage;
    };

    this.fail = function(error) {
      if (!currentRunnable()) {
        throw new Error(
          "'fail' was used when there was no current spec, this could be because an asynchronous test timed out"
        );
      }

      var message = 'Failed';
      if (error) {
        message += ': ';
        if (error.message) {
          message += error.message;
        } else if (j$.isString_(error)) {
          message += error;
        } else {
          // pretty print all kind of objects. This includes arrays.
          message += makePrettyPrinter()(error);
        }
      }

      currentRunnable().addExpectationResult(false, {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        message: message,
        error: error && error.message ? error : null
      });

      if (config.oneFailurePerSpec) {
        throw new Error(message);
      }
    };

    this.cleanup_ = function() {
      if (globalErrors) {
        globalErrors.uninstall();
      }
    };
  }

  return Env;
};

getJasmineRequireObj().JsApiReporter = function(j$) {
  /**
   * @name jsApiReporter
   * @classdesc {@link Reporter} added by default in `boot.js` to record results for retrieval in javascript code. An instance is made available as `jsApiReporter` on the global object.
   * @class
   * @hideconstructor
   */
  function JsApiReporter(options) {
    var timer = options.timer || new j$.Timer(),
      status = 'loaded';

    this.started = false;
    this.finished = false;
    this.runDetails = {};

    this.jasmineStarted = function() {
      this.started = true;
      status = 'started';
      timer.start();
    };

    var executionTime;

    this.jasmineDone = function(runDetails) {
      this.finished = true;
      this.runDetails = runDetails;
      executionTime = timer.elapsed();
      status = 'done';
    };

    /**
     * Get the current status for the Jasmine environment.
     * @name jsApiReporter#status
     * @since 2.0.0
     * @function
     * @return {String} - One of `loaded`, `started`, or `done`
     */
    this.status = function() {
      return status;
    };

    var suites = [],
      suites_hash = {};

    this.suiteStarted = function(result) {
      suites_hash[result.id] = result;
    };

    this.suiteDone = function(result) {
      storeSuite(result);
    };

    /**
     * Get the results for a set of suites.
     *
     * Retrievable in slices for easier serialization.
     * @name jsApiReporter#suiteResults
     * @since 2.1.0
     * @function
     * @param {Number} index - The position in the suites list to start from.
     * @param {Number} length - Maximum number of suite results to return.
     * @return {SuiteResult[]}
     */
    this.suiteResults = function(index, length) {
      return suites.slice(index, index + length);
    };

    function storeSuite(result) {
      suites.push(result);
      suites_hash[result.id] = result;
    }

    /**
     * Get all of the suites in a single object, with their `id` as the key.
     * @name jsApiReporter#suites
     * @since 2.0.0
     * @function
     * @return {Object} - Map of suite id to {@link SuiteResult}
     */
    this.suites = function() {
      return suites_hash;
    };

    var specs = [];

    this.specDone = function(result) {
      specs.push(result);
    };

    /**
     * Get the results for a set of specs.
     *
     * Retrievable in slices for easier serialization.
     * @name jsApiReporter#specResults
     * @since 2.0.0
     * @function
     * @param {Number} index - The position in the specs list to start from.
     * @param {Number} length - Maximum number of specs results to return.
     * @return {SpecResult[]}
     */
    this.specResults = function(index, length) {
      return specs.slice(index, index + length);
    };

    /**
     * Get all spec results.
     * @name jsApiReporter#specs
     * @since 2.0.0
     * @function
     * @return {SpecResult[]}
     */
    this.specs = function() {
      return specs;
    };

    /**
     * Get the number of milliseconds it took for the full Jasmine suite to run.
     * @name jsApiReporter#executionTime
     * @since 2.0.0
     * @function
     * @return {Number}
     */
    this.executionTime = function() {
      return executionTime;
    };
  }

  return JsApiReporter;
};

getJasmineRequireObj().Any = function(j$) {

  function Any(expectedObject) {
    if (typeof expectedObject === 'undefined') {
      throw new TypeError(
        'jasmine.any() expects to be passed a constructor function. ' +
        'Please pass one or use jasmine.anything() to match any object.'
      );
    }
    this.expectedObject = expectedObject;
  }

  Any.prototype.asymmetricMatch = function(other) {
    if (this.expectedObject == String) {
      return typeof other == 'string' || other instanceof String;
    }

    if (this.expectedObject == Number) {
      return typeof other == 'number' || other instanceof Number;
    }

    if (this.expectedObject == Function) {
      return typeof other == 'function' || other instanceof Function;
    }

    if (this.expectedObject == Object) {
      return other !== null && typeof other == 'object';
    }

    if (this.expectedObject == Boolean) {
      return typeof other == 'boolean';
    }

    /* jshint -W122 */
    /* global Symbol */
    if (typeof Symbol != 'undefined' && this.expectedObject == Symbol) {
      return typeof other == 'symbol';
    }
    /* jshint +W122 */

    return other instanceof this.expectedObject;
  };

  Any.prototype.jasmineToString = function() {
    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';
  };

  return Any;
};

getJasmineRequireObj().Anything = function(j$) {

  function Anything() {}

  Anything.prototype.asymmetricMatch = function(other) {
    return !j$.util.isUndefined(other) && other !== null;
  };

  Anything.prototype.jasmineToString = function() {
    return '<jasmine.anything>';
  };

  return Anything;
};

getJasmineRequireObj().ArrayContaining = function(j$) {
  function ArrayContaining(sample) {
    this.sample = sample;
  }

  ArrayContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isArray_(this.sample)) {
      throw new Error('You must provide an array to arrayContaining, not ' + j$.pp(this.sample) + '.');
    }

    // If the actual parameter is not an array, we can fail immediately, since it couldn't
    // possibly be an "array containing" anything. However, we also want an empty sample
    // array to match anything, so we need to double-check we aren't in that case
    if (!j$.isArray_(other) && this.sample.length > 0) {
      return false;
    }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayContaining.prototype.jasmineToString = function (pp) {
    return '<jasmine.arrayContaining(' + pp(this.sample) +')>';
  };

  return ArrayContaining;
};

getJasmineRequireObj().ArrayWithExactContents = function(j$) {

  function ArrayWithExactContents(sample) {
    this.sample = sample;
  }

  ArrayWithExactContents.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isArray_(this.sample)) {
      throw new Error('You must provide an array to arrayWithExactContents, not ' + j$.pp(this.sample) + '.');
    }

    if (this.sample.length !== other.length) {
      return false;
    }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayWithExactContents.prototype.jasmineToString = function(pp) {
    return '<jasmine.arrayWithExactContents(' + pp(this.sample) + ')>';
  };

  return ArrayWithExactContents;
};

getJasmineRequireObj().Empty = function (j$) {

  function Empty() {}

  Empty.prototype.asymmetricMatch = function (other) {
    if (j$.isString_(other) || j$.isArray_(other) || j$.isTypedArray_(other)) {
      return other.length === 0;
    }

    if (j$.isMap(other) || j$.isSet(other)) {
      return other.size === 0;
    }

    if (j$.isObject_(other)) {
      return Object.keys(other).length === 0;
    }
    return false;
  };

  Empty.prototype.jasmineToString = function () {
    return '<jasmine.empty>';
  };

  return Empty;
};

getJasmineRequireObj().Falsy = function(j$) {

  function Falsy() {}

  Falsy.prototype.asymmetricMatch = function(other) {
    return !other;
  };

  Falsy.prototype.jasmineToString = function() {
    return '<jasmine.falsy>';
  };

  return Falsy;
};

getJasmineRequireObj().MapContaining = function(j$) {
  function MapContaining(sample) {
    if (!j$.isMap(sample)) {
      throw new Error('You must provide a map to `mapContaining`, not ' + j$.pp(sample));
    }

    this.sample = sample;
  }

  MapContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isMap(other)) return false;

    var hasAllMatches = true;
    j$.util.forEachBreakable(this.sample, function(breakLoop, value, key) {
      // for each key/value pair in `sample`
      // there should be at least one pair in `other` whose key and value both match
      var hasMatch = false;
      j$.util.forEachBreakable(other, function(oBreakLoop, oValue, oKey) {
        if (
          matchersUtil.equals(oKey, key)
          && matchersUtil.equals(oValue, value)
        ) {
          hasMatch = true;
          oBreakLoop();
        }
      });
      if (!hasMatch) {
        hasAllMatches = false;
        breakLoop();
      }
    });

    return hasAllMatches;
  };

  MapContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.mapContaining(' + pp(this.sample) + ')>';
  };

  return MapContaining;
};

getJasmineRequireObj().NotEmpty = function (j$) {

  function NotEmpty() {}

  NotEmpty.prototype.asymmetricMatch = function (other) {
    if (j$.isString_(other) || j$.isArray_(other) || j$.isTypedArray_(other)) {
      return other.length !== 0;
    }

    if (j$.isMap(other) || j$.isSet(other)) {
      return other.size !== 0;
    }

    if (j$.isObject_(other)) {
      return Object.keys(other).length !== 0;
    }

    return false;
  };

  NotEmpty.prototype.jasmineToString = function () {
    return '<jasmine.notEmpty>';
  };

  return NotEmpty;
};

getJasmineRequireObj().ObjectContaining = function(j$) {

  function ObjectContaining(sample) {
    this.sample = sample;
  }

  function getPrototype(obj) {
    if (Object.getPrototypeOf) {
      return Object.getPrototypeOf(obj);
    }

    if (obj.constructor.prototype == obj) {
      return null;
    }

    return obj.constructor.prototype;
  }

  function hasProperty(obj, property) {
    if (!obj || typeof(obj) !== 'object') {
      return false;
    }

    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      return true;
    }

    return hasProperty(getPrototype(obj), property);
  }

  ObjectContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (typeof(this.sample) !== 'object') { throw new Error('You must provide an object to objectContaining, not \''+this.sample+'\'.'); }
    if (typeof(other) !== 'object') { return false; }

    for (var property in this.sample) {
      if (!hasProperty(other, property) ||
          !matchersUtil.equals(this.sample[property], other[property])) {
        return false;
      }
    }

    return true;
  };

  ObjectContaining.prototype.valuesForDiff_ = function(other, pp) {
    if (!j$.isObject_(other)) {
      return {
        self: this.jasmineToString(pp),
        other: other
      };
    }

    var filteredOther = {};
    Object.keys(this.sample).forEach(function (k) {
      // eq short-circuits comparison of objects that have different key sets,
      // so include all keys even if undefined.
      filteredOther[k] = other[k];
    });

    return {
      self: this.sample,
      other: filteredOther
    };
  };

  ObjectContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.objectContaining(' + pp(this.sample) + ')>';
  };

  return ObjectContaining;
};

getJasmineRequireObj().SetContaining = function(j$) {
  function SetContaining(sample) {
    if (!j$.isSet(sample)) {
      throw new Error('You must provide a set to `setContaining`, not ' + j$.pp(sample));
    }

    this.sample = sample;
  }

  SetContaining.prototype.asymmetricMatch = function(other, matchersUtil) {
    if (!j$.isSet(other)) return false;

    var hasAllMatches = true;
    j$.util.forEachBreakable(this.sample, function(breakLoop, item) {
      // for each item in `sample` there should be at least one matching item in `other`
      // (not using `matchersUtil.contains` because it compares set members by reference,
      // not by deep value equality)
      var hasMatch = false;
      j$.util.forEachBreakable(other, function(oBreakLoop, oItem) {
        if (matchersUtil.equals(oItem, item)) {
          hasMatch = true;
          oBreakLoop();
        }
      });
      if (!hasMatch) {
        hasAllMatches = false;
        breakLoop();
      }
    });

    return hasAllMatches;
  };

  SetContaining.prototype.jasmineToString = function(pp) {
    return '<jasmine.setContaining(' + pp(this.sample) + ')>';
  };

  return SetContaining;
};

getJasmineRequireObj().StringMatching = function(j$) {

  function StringMatching(expected) {
    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
      throw new Error('Expected is not a String or a RegExp');
    }

    this.regexp = new RegExp(expected);
  }

  StringMatching.prototype.asymmetricMatch = function(other) {
    return this.regexp.test(other);
  };

  StringMatching.prototype.jasmineToString = function() {
    return '<jasmine.stringMatching(' + this.regexp + ')>';
  };

  return StringMatching;
};

getJasmineRequireObj().Truthy = function(j$) {

  function Truthy() {}

  Truthy.prototype.asymmetricMatch = function(other) {
    return !!other;
  };

  Truthy.prototype.jasmineToString = function() {
    return '<jasmine.truthy>';
  };

  return Truthy;
};

getJasmineRequireObj().asymmetricEqualityTesterArgCompatShim = function(j$) {
  /*
    Older versions of Jasmine passed an array of custom equality testers as the
    second argument to each asymmetric equality tester's `asymmetricMatch`
    method. Newer versions will pass a `MatchersUtil` instance. The
    asymmetricEqualityTesterArgCompatShim allows for a graceful migration from
    the old interface to the new by "being" both an array of custom equality
    testers and a `MatchersUtil` at the same time.

    This code should be removed in the next major release.
   */

  var likelyArrayProps = [
    'concat',
    'constructor',
    'copyWithin',
    'entries',
    'every',
    'fill',
    'filter',
    'find',
    'findIndex',
    'flat',
    'flatMap',
    'forEach',
    'includes',
    'indexOf',
    'join',
    'keys',
    'lastIndexOf',
    'length',
    'map',
    'pop',
    'push',
    'reduce',
    'reduceRight',
    'reverse',
    'shift',
    'slice',
    'some',
    'sort',
    'splice',
    'toLocaleString',
    'toSource',
    'toString',
    'unshift',
    'values'
  ];

  function asymmetricEqualityTesterArgCompatShim(
    matchersUtil,
    customEqualityTesters
  ) {
    var self = Object.create(matchersUtil),
      props,
      i,
      k;

    copy(self, customEqualityTesters, 'length');

    for (i = 0; i < customEqualityTesters.length; i++) {
      copy(self, customEqualityTesters, i);
    }

    var props = arrayProps();

    for (i = 0; i < props.length; i++) {
      k = props[i];
      if (k !== 'length') {
        copy(self, Array.prototype, k);
      }
    }

    return self;
  }

  function copy(dest, src, propName) {
    Object.defineProperty(dest, propName, {
      get: function() {
        return src[propName];
      }
    });
  }

  function arrayProps() {
    var props, a, k;

    if (!Object.getOwnPropertyDescriptors) {
      return likelyArrayProps.filter(function(k) {
        return Array.prototype.hasOwnProperty(k);
      });
    }

    props = Object.getOwnPropertyDescriptors(Array.prototype); // eslint-disable-line compat/compat
    a = [];

    for (k in props) {
      a.push(k);
    }

    return a;
  }

  return asymmetricEqualityTesterArgCompatShim;
};

getJasmineRequireObj().CallTracker = function(j$) {
  /**
   * @namespace Spy#calls
   * @since 2.0.0
   */
  function CallTracker() {
    var calls = [];
    var opts = {};

    this.track = function(context) {
      if (opts.cloneArgs) {
        context.args = j$.util.cloneArgs(context.args);
      }
      calls.push(context);
    };

    /**
     * Check whether this spy has been invoked.
     * @name Spy#calls#any
     * @since 2.0.0
     * @function
     * @return {Boolean}
     */
    this.any = function() {
      return !!calls.length;
    };

    /**
     * Get the number of invocations of this spy.
     * @name Spy#calls#count
     * @since 2.0.0
     * @function
     * @return {Integer}
     */
    this.count = function() {
      return calls.length;
    };

    /**
     * Get the arguments that were passed to a specific invocation of this spy.
     * @name Spy#calls#argsFor
     * @since 2.0.0
     * @function
     * @param {Integer} index The 0-based invocation index.
     * @return {Array}
     */
    this.argsFor = function(index) {
      var call = calls[index];
      return call ? call.args : [];
    };

    /**
     * Get the raw calls array for this spy.
     * @name Spy#calls#all
     * @since 2.0.0
     * @function
     * @return {Spy.callData[]}
     */
    this.all = function() {
      return calls;
    };

    /**
     * Get all of the arguments for each invocation of this spy in the order they were received.
     * @name Spy#calls#allArgs
     * @since 2.0.0
     * @function
     * @return {Array}
     */
    this.allArgs = function() {
      var callArgs = [];
      for (var i = 0; i < calls.length; i++) {
        callArgs.push(calls[i].args);
      }

      return callArgs;
    };

    /**
     * Get the first invocation of this spy.
     * @name Spy#calls#first
     * @since 2.0.0
     * @function
     * @return {ObjecSpy.callData}
     */
    this.first = function() {
      return calls[0];
    };

    /**
     * Get the most recent invocation of this spy.
     * @name Spy#calls#mostRecent
     * @since 2.0.0
     * @function
     * @return {ObjecSpy.callData}
     */
    this.mostRecent = function() {
      return calls[calls.length - 1];
    };

    /**
     * Reset this spy as if it has never been called.
     * @name Spy#calls#reset
     * @since 2.0.0
     * @function
     */
    this.reset = function() {
      calls = [];
    };

    /**
     * Set this spy to do a shallow clone of arguments passed to each invocation.
     * @name Spy#calls#saveArgumentsByValue
     * @since 2.5.0
     * @function
     */
    this.saveArgumentsByValue = function() {
      opts.cloneArgs = true;
    };
  }

  return CallTracker;
};

getJasmineRequireObj().clearStack = function(j$) {
  var maxInlineCallCount = 10;

  function messageChannelImpl(global, setTimeout) {
    var channel = new global.MessageChannel(),
      head = {},
      tail = head;

    var taskRunning = false;
    channel.port1.onmessage = function() {
      head = head.next;
      var task = head.task;
      delete head.task;

      if (taskRunning) {
        global.setTimeout(task, 0);
      } else {
        try {
          taskRunning = true;
          task();
        } finally {
          taskRunning = false;
        }
      }
    };

    var currentCallCount = 0;
    return function clearStack(fn) {
      currentCallCount++;

      if (currentCallCount < maxInlineCallCount) {
        tail = tail.next = { task: fn };
        channel.port2.postMessage(0);
      } else {
        currentCallCount = 0;
        setTimeout(fn);
      }
    };
  }

  function getClearStack(global) {
    var currentCallCount = 0;
    var realSetTimeout = global.setTimeout;
    var setTimeoutImpl = function clearStack(fn) {
      Function.prototype.apply.apply(realSetTimeout, [global, [fn, 0]]);
    };

    if (j$.isFunction_(global.setImmediate)) {
      var realSetImmediate = global.setImmediate;
      return function(fn) {
        currentCallCount++;

        if (currentCallCount < maxInlineCallCount) {
          realSetImmediate(fn);
        } else {
          currentCallCount = 0;

          setTimeoutImpl(fn);
        }
      };
    } else if (!j$.util.isUndefined(global.MessageChannel)) {
      return messageChannelImpl(global, setTimeoutImpl);
    } else {
      return setTimeoutImpl;
    }
  }

  return getClearStack;
};

getJasmineRequireObj().Clock = function() {
  /* global process */
  var NODE_JS =
    typeof process !== 'undefined' &&
    process.versions &&
    typeof process.versions.node === 'string';

  /**
   * _Note:_ Do not construct this directly, Jasmine will make one during booting. You can get the current clock with {@link jasmine.clock}.
   * @class Clock
   * @classdesc Jasmine's mock clock is used when testing time dependent code.
   */
  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {
    var self = this,
      realTimingFunctions = {
        setTimeout: global.setTimeout,
        clearTimeout: global.clearTimeout,
        setInterval: global.setInterval,
        clearInterval: global.clearInterval
      },
      fakeTimingFunctions = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setInterval: setInterval,
        clearInterval: clearInterval
      },
      installed = false,
      delayedFunctionScheduler,
      timer;

    self.FakeTimeout = FakeTimeout;

    /**
     * Install the mock clock over the built-in methods.
     * @name Clock#install
     * @since 2.0.0
     * @function
     * @return {Clock}
     */
    self.install = function() {
      if (!originalTimingFunctionsIntact()) {
        throw new Error(
          'Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?'
        );
      }
      replace(global, fakeTimingFunctions);
      timer = fakeTimingFunctions;
      delayedFunctionScheduler = delayedFunctionSchedulerFactory();
      installed = true;

      return self;
    };

    /**
     * Uninstall the mock clock, returning the built-in methods to their places.
     * @name Clock#uninstall
     * @since 2.0.0
     * @function
     */
    self.uninstall = function() {
      delayedFunctionScheduler = null;
      mockDate.uninstall();
      replace(global, realTimingFunctions);

      timer = realTimingFunctions;
      installed = false;
    };

    /**
     * Execute a function with a mocked Clock
     *
     * The clock will be {@link Clock#install|install}ed before the function is called and {@link Clock#uninstall|uninstall}ed in a `finally` after the function completes.
     * @name Clock#withMock
     * @since 2.3.0
     * @function
     * @param {Function} closure The function to be called.
     */
    self.withMock = function(closure) {
      this.install();
      try {
        closure();
      } finally {
        this.uninstall();
      }
    };

    /**
     * Instruct the installed Clock to also mock the date returned by `new Date()`
     * @name Clock#mockDate
     * @since 2.1.0
     * @function
     * @param {Date} [initialDate=now] The `Date` to provide.
     */
    self.mockDate = function(initialDate) {
      mockDate.install(initialDate);
    };

    self.setTimeout = function(fn, delay, params) {
      return Function.prototype.apply.apply(timer.setTimeout, [
        global,
        arguments
      ]);
    };

    self.setInterval = function(fn, delay, params) {
      return Function.prototype.apply.apply(timer.setInterval, [
        global,
        arguments
      ]);
    };

    self.clearTimeout = function(id) {
      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);
    };

    self.clearInterval = function(id) {
      return Function.prototype.call.apply(timer.clearInterval, [global, id]);
    };

    /**
     * Tick the Clock forward, running any enqueued timeouts along the way
     * @name Clock#tick
     * @since 1.3.0
     * @function
     * @param {int} millis The number of milliseconds to tick.
     */
    self.tick = function(millis) {
      if (installed) {
        delayedFunctionScheduler.tick(millis, function(millis) {
          mockDate.tick(millis);
        });
      } else {
        throw new Error(
          'Mock clock is not installed, use jasmine.clock().install()'
        );
      }
    };

    return self;

    function originalTimingFunctionsIntact() {
      return (
        global.setTimeout === realTimingFunctions.setTimeout &&
        global.clearTimeout === realTimingFunctions.clearTimeout &&
        global.setInterval === realTimingFunctions.setInterval &&
        global.clearInterval === realTimingFunctions.clearInterval
      );
    }

    function replace(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    }

    function setTimeout(fn, delay) {
      if (!NODE_JS) {
        return delayedFunctionScheduler.scheduleFunction(
          fn,
          delay,
          argSlice(arguments, 2)
        );
      }

      var timeout = new FakeTimeout();

      delayedFunctionScheduler.scheduleFunction(
        fn,
        delay,
        argSlice(arguments, 2),
        false,
        timeout
      );

      return timeout;
    }

    function clearTimeout(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function setInterval(fn, interval) {
      if (!NODE_JS) {
        return delayedFunctionScheduler.scheduleFunction(
          fn,
          interval,
          argSlice(arguments, 2),
          true
        );
      }

      var timeout = new FakeTimeout();

      delayedFunctionScheduler.scheduleFunction(
        fn,
        interval,
        argSlice(arguments, 2),
        true,
        timeout
      );

      return timeout;
    }

    function clearInterval(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function argSlice(argsObj, n) {
      return Array.prototype.slice.call(argsObj, n);
    }
  }

  /**
   * Mocks Node.js Timeout class
   */
  function FakeTimeout() {}

  FakeTimeout.prototype.ref = function() {
    return this;
  };

  FakeTimeout.prototype.unref = function() {
    return this;
  };

  return Clock;
};

getJasmineRequireObj().DelayedFunctionScheduler = function(j$) {
  function DelayedFunctionScheduler() {
    var self = this;
    var scheduledLookup = [];
    var scheduledFunctions = {};
    var currentTime = 0;
    var delayedFnCount = 0;
    var deletedKeys = [];

    self.tick = function(millis, tickDate) {
      millis = millis || 0;
      var endTime = currentTime + millis;

      runScheduledFunctions(endTime, tickDate);
      currentTime = endTime;
    };

    self.scheduleFunction = function(
      funcToCall,
      millis,
      params,
      recurring,
      timeoutKey,
      runAtMillis
    ) {
      var f;
      if (typeof funcToCall === 'string') {
        /* jshint evil: true */
        f = function() {
          return eval(funcToCall);
        };
        /* jshint evil: false */
      } else {
        f = funcToCall;
      }

      millis = millis || 0;
      timeoutKey = timeoutKey || ++delayedFnCount;
      runAtMillis = runAtMillis || currentTime + millis;

      var funcToSchedule = {
        runAtMillis: runAtMillis,
        funcToCall: f,
        recurring: recurring,
        params: params,
        timeoutKey: timeoutKey,
        millis: millis
      };

      if (runAtMillis in scheduledFunctions) {
        scheduledFunctions[runAtMillis].push(funcToSchedule);
      } else {
        scheduledFunctions[runAtMillis] = [funcToSchedule];
        scheduledLookup.push(runAtMillis);
        scheduledLookup.sort(function(a, b) {
          return a - b;
        });
      }

      return timeoutKey;
    };

    self.removeFunctionWithId = function(timeoutKey) {
      deletedKeys.push(timeoutKey);

      for (var runAtMillis in scheduledFunctions) {
        var funcs = scheduledFunctions[runAtMillis];
        var i = indexOfFirstToPass(funcs, function(func) {
          return func.timeoutKey === timeoutKey;
        });

        if (i > -1) {
          if (funcs.length === 1) {
            delete scheduledFunctions[runAtMillis];
            deleteFromLookup(runAtMillis);
          } else {
            funcs.splice(i, 1);
          }

          // intervals get rescheduled when executed, so there's never more
          // than a single scheduled function with a given timeoutKey
          break;
        }
      }
    };

    return self;

    function indexOfFirstToPass(array, testFn) {
      var index = -1;

      for (var i = 0; i < array.length; ++i) {
        if (testFn(array[i])) {
          index = i;
          break;
        }
      }

      return index;
    }

    function deleteFromLookup(key) {
      var value = Number(key);
      var i = indexOfFirstToPass(scheduledLookup, function(millis) {
        return millis === value;
      });

      if (i > -1) {
        scheduledLookup.splice(i, 1);
      }
    }

    function reschedule(scheduledFn) {
      self.scheduleFunction(
        scheduledFn.funcToCall,
        scheduledFn.millis,
        scheduledFn.params,
        true,
        scheduledFn.timeoutKey,
        scheduledFn.runAtMillis + scheduledFn.millis
      );
    }

    function forEachFunction(funcsToRun, callback) {
      for (var i = 0; i < funcsToRun.length; ++i) {
        callback(funcsToRun[i]);
      }
    }

    function runScheduledFunctions(endTime, tickDate) {
      tickDate = tickDate || function() {};
      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {
        tickDate(endTime - currentTime);
        return;
      }

      do {
        deletedKeys = [];
        var newCurrentTime = scheduledLookup.shift();
        tickDate(newCurrentTime - currentTime);

        currentTime = newCurrentTime;

        var funcsToRun = scheduledFunctions[currentTime];

        delete scheduledFunctions[currentTime];

        forEachFunction(funcsToRun, function(funcToRun) {
          if (funcToRun.recurring) {
            reschedule(funcToRun);
          }
        });

        forEachFunction(funcsToRun, function(funcToRun) {
          if (j$.util.arrayContains(deletedKeys, funcToRun.timeoutKey)) {
            // skip a timeoutKey deleted whilst we were running
            return;
          }
          funcToRun.funcToCall.apply(null, funcToRun.params || []);
        });
        deletedKeys = [];
      } while (
        scheduledLookup.length > 0 &&
        // checking first if we're out of time prevents setTimeout(0)
        // scheduled in a funcToRun from forcing an extra iteration
        currentTime !== endTime &&
        scheduledLookup[0] <= endTime
      );

      // ran out of functions to call, but still time left on the clock
      if (currentTime !== endTime) {
        tickDate(endTime - currentTime);
      }
    }
  }

  return DelayedFunctionScheduler;
};

getJasmineRequireObj().errors = function() {
  function ExpectationFailed() {}

  ExpectationFailed.prototype = new Error();
  ExpectationFailed.prototype.constructor = ExpectationFailed;

  return {
    ExpectationFailed: ExpectationFailed
  };
};

getJasmineRequireObj().ExceptionFormatter = function(j$) {
  var ignoredProperties = [
    'name',
    'message',
    'stack',
    'fileName',
    'sourceURL',
    'line',
    'lineNumber',
    'column',
    'description',
    'jasmineMessage'
  ];

  function ExceptionFormatter(options) {
    var jasmineFile = (options && options.jasmineFile) || j$.util.jasmineFile();
    this.message = function(error) {
      var message = '';

      if (error.jasmineMessage) {
        message += error.jasmineMessage;
      } else if (error.name && error.message) {
        message += error.name + ': ' + error.message;
      } else if (error.message) {
        message += error.message;
      } else {
        message += error.toString() + ' thrown';
      }

      if (error.fileName || error.sourceURL) {
        message += ' in ' + (error.fileName || error.sourceURL);
      }

      if (error.line || error.lineNumber) {
        message += ' (line ' + (error.line || error.lineNumber) + ')';
      }

      return message;
    };

    this.stack = function(error) {
      if (!error || !error.stack) {
        return null;
      }

      var stackTrace = new j$.StackTrace(error);
      var lines = filterJasmine(stackTrace);
      var result = '';

      if (stackTrace.message) {
        lines.unshift(stackTrace.message);
      }

      result += formatProperties(error);
      result += lines.join('\n');

      return result;
    };

    function filterJasmine(stackTrace) {
      var result = [],
        jasmineMarker =
          stackTrace.style === 'webkit' ? '<Jasmine>' : '    at <Jasmine>';

      stackTrace.frames.forEach(function(frame) {
        if (frame.file && frame.file !== jasmineFile) {
          result.push(frame.raw);
        } else if (result[result.length - 1] !== jasmineMarker) {
          result.push(jasmineMarker);
        }
      });

      return result;
    }

    function formatProperties(error) {
      if (!(error instanceof Object)) {
        return;
      }

      var result = {};
      var empty = true;

      for (var prop in error) {
        if (j$.util.arrayContains(ignoredProperties, prop)) {
          continue;
        }
        result[prop] = error[prop];
        empty = false;
      }

      if (!empty) {
        return 'error properties: ' + j$.pp(result) + '\n';
      }

      return '';
    }
  }

  return ExceptionFormatter;
};

getJasmineRequireObj().Expectation = function(j$) {
  /**
   * Matchers that come with Jasmine out of the box.
   * @namespace matchers
   */
  function Expectation(options) {
    this.expector = new j$.Expector(options);

    var customMatchers = options.customMatchers || {};
    for (var matcherName in customMatchers) {
      this[matcherName] = wrapSyncCompare(
        matcherName,
        customMatchers[matcherName]
      );
    }
  }

  /**
   * Add some context for an {@link expect}
   * @function
   * @name matchers#withContext
   * @since 3.3.0
   * @param {String} message - Additional context to show when the matcher fails
   * @return {matchers}
   */
  Expectation.prototype.withContext = function withContext(message) {
    return addFilter(this, new ContextAddingFilter(message));
  };

  /**
   * Invert the matcher following this {@link expect}
   * @member
   * @name matchers#not
   * @since 1.3.0
   * @type {matchers}
   * @example
   * expect(something).not.toBe(true);
   */
  Object.defineProperty(Expectation.prototype, 'not', {
    get: function() {
      return addFilter(this, syncNegatingFilter);
    }
  });

  /**
   * Asynchronous matchers.
   * @namespace async-matchers
   */
  function AsyncExpectation(options) {
    var global = options.global || j$.getGlobal();
    this.expector = new j$.Expector(options);

    if (!global.Promise) {
      throw new Error(
        'expectAsync is unavailable because the environment does not support promises.'
      );
    }

    var customAsyncMatchers = options.customAsyncMatchers || {};
    for (var matcherName in customAsyncMatchers) {
      this[matcherName] = wrapAsyncCompare(
        matcherName,
        customAsyncMatchers[matcherName]
      );
    }
  }

  /**
   * Add some context for an {@link expectAsync}
   * @function
   * @name async-matchers#withContext
   * @since 3.3.0
   * @param {String} message - Additional context to show when the async matcher fails
   * @return {async-matchers}
   */
  AsyncExpectation.prototype.withContext = function withContext(message) {
    return addFilter(this, new ContextAddingFilter(message));
  };

  /**
   * Invert the matcher following this {@link expectAsync}
   * @member
   * @name async-matchers#not
   * @type {async-matchers}
   * @example
   * await expectAsync(myPromise).not.toBeResolved();
   * @example
   * return expectAsync(myPromise).not.toBeResolved();
   */
  Object.defineProperty(AsyncExpectation.prototype, 'not', {
    get: function() {
      return addFilter(this, asyncNegatingFilter);
    }
  });

  function wrapSyncCompare(name, matcherFactory) {
    return function() {
      var result = this.expector.compare(name, matcherFactory, arguments);
      this.expector.processResult(result);
    };
  }

  function wrapAsyncCompare(name, matcherFactory) {
    return function() {
      var self = this;

      // Capture the call stack here, before we go async, so that it will contain
      // frames that are relevant to the user instead of just parts of Jasmine.
      var errorForStack = j$.util.errorWithStack();

      return this.expector
        .compare(name, matcherFactory, arguments)
        .then(function(result) {
          self.expector.processResult(result, errorForStack);
        });
    };
  }

  function addCoreMatchers(prototype, matchers, wrapper) {
    for (var matcherName in matchers) {
      var matcher = matchers[matcherName];
      prototype[matcherName] = wrapper(matcherName, matcher);
    }
  }

  function addFilter(source, filter) {
    var result = Object.create(source);
    result.expector = source.expector.addFilter(filter);
    return result;
  }

  function negatedFailureMessage(result, matcherName, args, matchersUtil) {
    if (result.message) {
      if (j$.isFunction_(result.message)) {
        return result.message();
      } else {
        return result.message;
      }
    }

    args = args.slice();
    args.unshift(true);
    args.unshift(matcherName);
    return matchersUtil.buildFailureMessage.apply(matchersUtil, args);
  }

  function negate(result) {
    result.pass = !result.pass;
    return result;
  }

  var syncNegatingFilter = {
    selectComparisonFunc: function(matcher) {
      function defaultNegativeCompare() {
        return negate(matcher.compare.apply(null, arguments));
      }

      return matcher.negativeCompare || defaultNegativeCompare;
    },
    buildFailureMessage: negatedFailureMessage
  };

  var asyncNegatingFilter = {
    selectComparisonFunc: function(matcher) {
      function defaultNegativeCompare() {
        return matcher.compare.apply(this, arguments).then(negate);
      }

      return matcher.negativeCompare || defaultNegativeCompare;
    },
    buildFailureMessage: negatedFailureMessage
  };

  function ContextAddingFilter(message) {
    this.message = message;
  }

  ContextAddingFilter.prototype.modifyFailureMessage = function(msg) {
    var nl = msg.indexOf('\n');

    if (nl === -1) {
      return this.message + ': ' + msg;
    } else {
      return this.message + ':\n' + indent(msg);
    }
  };

  function indent(s) {
    return s.replace(/^/gm, '    ');
  }

  return {
    factory: function(options) {
      return new Expectation(options || {});
    },
    addCoreMatchers: function(matchers) {
      addCoreMatchers(Expectation.prototype, matchers, wrapSyncCompare);
    },
    asyncFactory: function(options) {
      return new AsyncExpectation(options || {});
    },
    addAsyncCoreMatchers: function(matchers) {
      addCoreMatchers(AsyncExpectation.prototype, matchers, wrapAsyncCompare);
    }
  };
};

getJasmineRequireObj().ExpectationFilterChain = function() {
  function ExpectationFilterChain(maybeFilter, prev) {
    this.filter_ = maybeFilter;
    this.prev_ = prev;
  }

  ExpectationFilterChain.prototype.addFilter = function(filter) {
    return new ExpectationFilterChain(filter, this);
  };

  ExpectationFilterChain.prototype.selectComparisonFunc = function(matcher) {
    return this.callFirst_('selectComparisonFunc', arguments).result;
  };

  ExpectationFilterChain.prototype.buildFailureMessage = function(
    result,
    matcherName,
    args,
    matchersUtil
  ) {
    return this.callFirst_('buildFailureMessage', arguments).result;
  };

  ExpectationFilterChain.prototype.modifyFailureMessage = function(msg) {
    var result = this.callFirst_('modifyFailureMessage', arguments).result;
    return result || msg;
  };

  ExpectationFilterChain.prototype.callFirst_ = function(fname, args) {
    var prevResult;

    if (this.prev_) {
      prevResult = this.prev_.callFirst_(fname, args);

      if (prevResult.found) {
        return prevResult;
      }
    }

    if (this.filter_ && this.filter_[fname]) {
      return {
        found: true,
        result: this.filter_[fname].apply(this.filter_, args)
      };
    }

    return { found: false };
  };

  return ExpectationFilterChain;
};

//TODO: expectation result may make more sense as a presentation of an expectation.
getJasmineRequireObj().buildExpectationResult = function(j$) {
  function buildExpectationResult(options) {
    var messageFormatter = options.messageFormatter || function() {},
      stackFormatter = options.stackFormatter || function() {};

    /**
     * @typedef Expectation
     * @property {String} matcherName - The name of the matcher that was executed for this expectation.
     * @property {String} message - The failure message for the expectation.
     * @property {String} stack - The stack trace for the failure if available.
     * @property {Boolean} passed - Whether the expectation passed or failed.
     * @property {Object} expected - If the expectation failed, what was the expected value.
     * @property {Object} actual - If the expectation failed, what actual value was produced.
     */
    var result = {
      matcherName: options.matcherName,
      message: message(),
      stack: stack(),
      passed: options.passed
    };

    if (!result.passed) {
      result.expected = options.expected;
      result.actual = options.actual;

      if (options.error && !j$.isString_(options.error)) {
        if ('code' in options.error) {
          result.code = options.error.code;
        }

        if (
          options.error.code === 'ERR_ASSERTION' &&
          options.expected === '' &&
          options.actual === ''
        ) {
          result.expected = options.error.expected;
          result.actual = options.error.actual;
          result.matcherName = 'assert ' + options.error.operator;
        }
      }
    }

    return result;

    function message() {
      if (options.passed) {
        return 'Passed.';
      } else if (options.message) {
        return options.message;
      } else if (options.error) {
        return messageFormatter(options.error);
      }
      return '';
    }

    function stack() {
      if (options.passed) {
        return '';
      }

      var error = options.error;
      if (!error) {
        if (options.errorForStack) {
          error = options.errorForStack;
        } else if (options.stack) {
          error = options;
        } else {
          try {
            throw new Error(message());
          } catch (e) {
            error = e;
          }
        }
      }
      return stackFormatter(error);
    }
  }

  return buildExpectationResult;
};

getJasmineRequireObj().Expector = function(j$) {
  function Expector(options) {
    this.matchersUtil = options.matchersUtil || {
      buildFailureMessage: function() {}
    };
    this.customEqualityTesters = options.customEqualityTesters || [];
    this.actual = options.actual;
    this.addExpectationResult = options.addExpectationResult || function() {};
    this.filters = new j$.ExpectationFilterChain();
  }

  Expector.prototype.instantiateMatcher = function(
    matcherName,
    matcherFactory,
    args
  ) {
    this.matcherName = matcherName;
    this.args = Array.prototype.slice.call(args, 0);
    this.expected = this.args.slice(0);

    this.args.unshift(this.actual);

    var matcher = matcherFactory(this.matchersUtil, this.customEqualityTesters);
    var comparisonFunc = this.filters.selectComparisonFunc(matcher);
    return comparisonFunc || matcher.compare;
  };

  Expector.prototype.buildMessage = function(result) {
    var self = this;

    if (result.pass) {
      return '';
    }

    var msg = this.filters.buildFailureMessage(
      result,
      this.matcherName,
      this.args,
      this.matchersUtil,
      defaultMessage
    );
    return this.filters.modifyFailureMessage(msg || defaultMessage());

    function defaultMessage() {
      if (!result.message) {
        var args = self.args.slice();
        args.unshift(false);
        args.unshift(self.matcherName);
        return self.matchersUtil.buildFailureMessage.apply(
          self.matchersUtil,
          args
        );
      } else if (j$.isFunction_(result.message)) {
        return result.message();
      } else {
        return result.message;
      }
    }
  };

  Expector.prototype.compare = function(matcherName, matcherFactory, args) {
    var matcherCompare = this.instantiateMatcher(
      matcherName,
      matcherFactory,
      args
    );
    return matcherCompare.apply(null, this.args);
  };

  Expector.prototype.addFilter = function(filter) {
    var result = Object.create(this);
    result.filters = this.filters.addFilter(filter);
    return result;
  };

  Expector.prototype.processResult = function(result, errorForStack) {
    var message = this.buildMessage(result);

    if (this.expected.length === 1) {
      this.expected = this.expected[0];
    }

    this.addExpectationResult(result.pass, {
      matcherName: this.matcherName,
      passed: result.pass,
      message: message,
      error: errorForStack ? undefined : result.error,
      errorForStack: errorForStack || undefined,
      actual: this.actual,
      expected: this.expected // TODO: this may need to be arrayified/sliced
    });
  };

  return Expector;
};

getJasmineRequireObj().formatErrorMsg = function() {
  function generateErrorMsg(domain, usage) {
    var usageDefinition = usage ? '\nUsage: ' + usage : '';

    return function errorMsg(msg) {
      return domain + ' : ' + msg + usageDefinition;
    };
  }

  return generateErrorMsg;
};

getJasmineRequireObj().GlobalErrors = function(j$) {
  function GlobalErrors(global) {
    var handlers = [];
    global = global || j$.getGlobal();

    var onerror = function onerror() {
      var handler = handlers[handlers.length - 1];

      if (handler) {
        handler.apply(null, Array.prototype.slice.call(arguments, 0));
      } else {
        throw arguments[0];
      }
    };

    this.originalHandlers = {};
    this.jasmineHandlers = {};
    this.installOne_ = function installOne_(errorType, jasmineMessage) {
      function taggedOnError(error) {
        error.jasmineMessage = jasmineMessage + ': ' + error;

        var handler = handlers[handlers.length - 1];

        if (handler) {
          handler(error);
        } else {
          throw error;
        }
      }

      this.originalHandlers[errorType] = global.process.listeners(errorType);
      this.jasmineHandlers[errorType] = taggedOnError;

      global.process.removeAllListeners(errorType);
      global.process.on(errorType, taggedOnError);

      this.uninstall = function uninstall() {
        var errorTypes = Object.keys(this.originalHandlers);
        for (var iType = 0; iType < errorTypes.length; iType++) {
          var errorType = errorTypes[iType];
          global.process.removeListener(
            errorType,
            this.jasmineHandlers[errorType]
          );
          for (var i = 0; i < this.originalHandlers[errorType].length; i++) {
            global.process.on(errorType, this.originalHandlers[errorType][i]);
          }
          delete this.originalHandlers[errorType];
          delete this.jasmineHandlers[errorType];
        }
      };
    };

    this.install = function install() {
      if (
        global.process &&
        global.process.listeners &&
        j$.isFunction_(global.process.on)
      ) {
        this.installOne_('uncaughtException', 'Uncaught exception');
        this.installOne_('unhandledRejection', 'Unhandled promise rejection');
      } else {
        var originalHandler = global.onerror;
        global.onerror = onerror;

        var browserRejectionHandler = function browserRejectionHandler(event) {
          if (j$.isError_(event.reason)) {
            event.reason.jasmineMessage =
              'Unhandled promise rejection: ' + event.reason;
            onerror(event.reason);
          } else {
            onerror('Unhandled promise rejection: ' + event.reason);
          }
        };

        if (global.addEventListener) {
          global.addEventListener(
            'unhandledrejection',
            browserRejectionHandler
          );
        }

        this.uninstall = function uninstall() {
          global.onerror = originalHandler;
          if (global.removeEventListener) {
            global.removeEventListener(
              'unhandledrejection',
              browserRejectionHandler
            );
          }
        };
      }
    };

    this.pushListener = function pushListener(listener) {
      handlers.push(listener);
    };

    this.popListener = function popListener() {
      handlers.pop();
    };
  }

  return GlobalErrors;
};

/* eslint-disable compat/compat */
getJasmineRequireObj().toBePending = function(j$) {
  /**
   * Expect a promise to be pending, ie. the promise is neither resolved nor rejected.
   * @function
   * @async
   * @name async-matchers#toBePending
   * @since 3.6
   * @example
   * await expectAsync(aPromise).toBePending();
   */
  return function toBePending() {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBePending to be called on a promise.');
        }
        var want = {};
        return Promise.race([actual, Promise.resolve(want)]).then(
          function(got) { return {pass: want === got}; },
          function() { return {pass: false}; }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejected = function(j$) {
  /**
   * Expect a promise to be rejected.
   * @function
   * @async
   * @name async-matchers#toBeRejected
   * @since 3.1.0
   * @example
   * await expectAsync(aPromise).toBeRejected();
   * @example
   * return expectAsync(aPromise).toBeRejected();
   */
  return function toBeRejected() {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBeRejected to be called on a promise.');
        }
        return actual.then(
          function() { return {pass: false}; },
          function() { return {pass: true}; }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejectedWith = function(j$) {
  /**
   * Expect a promise to be rejected with a value equal to the expected, using deep equality comparison.
   * @function
   * @async
   * @name async-matchers#toBeRejectedWith
   * @since 3.3.0
   * @param {Object} expected - Value that the promise is expected to be rejected with
   * @example
   * await expectAsync(aPromise).toBeRejectedWith({prop: 'value'});
   * @example
   * return expectAsync(aPromise).toBeRejectedWith({prop: 'value'});
   */
  return function toBeRejectedWith(matchersUtil) {
    return {
      compare: function(actualPromise, expectedValue) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error('Expected toBeRejectedWith to be called on a promise.');
        }

        function prefix(passed) {
          return 'Expected a promise ' +
            (passed ? 'not ' : '') +
            'to be rejected with ' + matchersUtil.pp(expectedValue);
        }

        return actualPromise.then(
          function() {
          return {
            pass: false,
            message: prefix(false) + ' but it was resolved.'
          };
        },
        function(actualValue) {
          if (matchersUtil.equals(actualValue, expectedValue)) {
            return {
              pass: true,
              message: prefix(true) + '.'
            };
          } else {
            return {
              pass: false,
              message: prefix(false) + ' but it was rejected with ' + matchersUtil.pp(actualValue) + '.'
            };
          }
        }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeRejectedWithError = function(j$) {
  /**
   * Expect a promise to be rejected with a value matched to the expected
   * @function
   * @async
   * @name async-matchers#toBeRejectedWithError
   * @since 3.5.0
   * @param {Error} [expected] - `Error` constructor the object that was thrown needs to be an instance of. If not provided, `Error` will be used.
   * @param {RegExp|String} [message] - The message that should be set on the thrown `Error`
   * @example
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError, 'Error message');
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError, /Error message/);
   * await expectAsync(aPromise).toBeRejectedWithError(MyCustomError);
   * await expectAsync(aPromise).toBeRejectedWithError('Error message');
   * return expectAsync(aPromise).toBeRejectedWithError(/Error message/);
   */
  return function toBeRejectedWithError(matchersUtil) {
    return {
      compare: function(actualPromise, arg1, arg2) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error('Expected toBeRejectedWithError to be called on a promise.');
        }

        var expected = getExpectedFromArgs(arg1, arg2, matchersUtil);

        return actualPromise.then(
          function() {
            return {
              pass: false,
              message: 'Expected a promise to be rejected but it was resolved.'
            };
          },
          function(actualValue) { return matchError(actualValue, expected, matchersUtil); }
        );
      }
    };
  };

  function matchError(actual, expected, matchersUtil) {
    if (!j$.isError_(actual)) {
      return fail(expected, 'rejected with ' + matchersUtil.pp(actual));
    }

    if (!(actual instanceof expected.error)) {
      return fail(expected, 'rejected with type ' + j$.fnNameFor(actual.constructor));
    }

    var actualMessage = actual.message;

    if (actualMessage === expected.message || typeof expected.message === 'undefined') {
      return pass(expected);
    }

    if (expected.message instanceof RegExp && expected.message.test(actualMessage)) {
      return pass(expected);
    }

    return fail(expected, 'rejected with ' + matchersUtil.pp(actual));
  }

  function pass(expected) {
    return {
      pass: true,
      message: 'Expected a promise not to be rejected with ' + expected.printValue + ', but it was.'
    };
  }

  function fail(expected, message) {
    return {
      pass: false,
      message: 'Expected a promise to be rejected with ' + expected.printValue + ' but it was ' + message + '.'
    };
  }


  function getExpectedFromArgs(arg1, arg2, matchersUtil) {
    var error, message;

    if (isErrorConstructor(arg1)) {
      error = arg1;
      message = arg2;
    } else {
      error = Error;
      message = arg1;
    }

    return {
      error: error,
      message: message,
      printValue: j$.fnNameFor(error) + (typeof message === 'undefined' ? '' : ': ' + matchersUtil.pp(message))
    };
  }

  function isErrorConstructor(value) {
    return typeof value === 'function' && (value === Error || j$.isError_(value.prototype));
  }
};

getJasmineRequireObj().toBeResolved = function(j$) {
  /**
   * Expect a promise to be resolved.
   * @function
   * @async
   * @name async-matchers#toBeResolved
   * @since 3.1.0
   * @example
   * await expectAsync(aPromise).toBeResolved();
   * @example
   * return expectAsync(aPromise).toBeResolved();
   */
  return function toBeResolved() {
    return {
      compare: function(actual) {
        if (!j$.isPromiseLike(actual)) {
          throw new Error('Expected toBeResolved to be called on a promise.');
        }

        return actual.then(
          function() { return {pass: true}; },
          function() { return {pass: false}; }
        );
      }
    };
  };
};

getJasmineRequireObj().toBeResolvedTo = function(j$) {
  /**
   * Expect a promise to be resolved to a value equal to the expected, using deep equality comparison.
   * @function
   * @async
   * @name async-matchers#toBeResolvedTo
   * @since 3.1.0
   * @param {Object} expected - Value that the promise is expected to resolve to
   * @example
   * await expectAsync(aPromise).toBeResolvedTo({prop: 'value'});
   * @example
   * return expectAsync(aPromise).toBeResolvedTo({prop: 'value'});
   */
  return function toBeResolvedTo(matchersUtil) {
    return {
      compare: function(actualPromise, expectedValue) {
        if (!j$.isPromiseLike(actualPromise)) {
          throw new Error('Expected toBeResolvedTo to be called on a promise.');
        }

        function prefix(passed) {
          return 'Expected a promise ' +
            (passed ? 'not ' : '') +
            'to be resolved to ' + matchersUtil.pp(expectedValue);
        }

        return actualPromise.then(
          function(actualValue) {
            if (matchersUtil.equals(actualValue, expectedValue)) {
              return {
                pass: true,
                message: prefix(true) + '.'
              };
            } else {
              return {
                pass: false,
                message: prefix(false) + ' but it was resolved to ' + matchersUtil.pp(actualValue) + '.'
              };
            }
          },
          function() {
            return {
              pass: false,
              message: prefix(false) + ' but it was rejected.'
            };
          }
        );
      }
    };
  };
};

getJasmineRequireObj().DiffBuilder = function (j$) {
  return function DiffBuilder(config) {
    var prettyPrinter = (config || {}).prettyPrinter || j$.makePrettyPrinter(),
      mismatches = new j$.MismatchTree(),
      path = new j$.ObjectPath(),
      actualRoot = undefined,
      expectedRoot = undefined;

    return {
      setRoots: function (actual, expected) {
        actualRoot = actual;
        expectedRoot = expected;
      },

      recordMismatch: function (formatter) {
        mismatches.add(path, formatter);
      },

      getMessage: function () {
        var messages = [];

        mismatches.traverse(function (path, isLeaf, formatter) {
          var actualCustom, expectedCustom, useCustom,
            derefResult = dereferencePath(path, actualRoot, expectedRoot, prettyPrinter),
            actual = derefResult.actual,
            expected = derefResult.expected;

          if (formatter) {
            messages.push(formatter(actual, expected, path, prettyPrinter));
            return true;
          }

          actualCustom = prettyPrinter.customFormat_(actual);
          expectedCustom = prettyPrinter.customFormat_(expected);
          useCustom = !(j$.util.isUndefined(actualCustom) && j$.util.isUndefined(expectedCustom));

          if (useCustom) {
            messages.push(wrapPrettyPrinted(actualCustom, expectedCustom, path));
            return false; // don't recurse further
          }

          if (isLeaf) {
            messages.push(defaultFormatter(actual, expected, path, prettyPrinter));
          }

          return true;
        });

        return messages.join('\n');
      },

      withPath: function (pathComponent, block) {
        var oldPath = path;
        path = path.add(pathComponent);
        block();
        path = oldPath;
      }
    };

    function defaultFormatter(actual, expected, path, prettyPrinter) {
      return wrapPrettyPrinted(prettyPrinter(actual), prettyPrinter(expected), path);
    }

    function wrapPrettyPrinted(actual, expected, path) {
      return 'Expected ' +
        path + (path.depth() ? ' = ' : '') +
        actual +
        ' to equal ' +
        expected +
        '.';
    }
  };

  function dereferencePath(objectPath, actual, expected, pp) {
    function handleAsymmetricExpected() {
      if (j$.isAsymmetricEqualityTester_(expected) && j$.isFunction_(expected.valuesForDiff_)) {
        var asymmetricResult = expected.valuesForDiff_(actual, pp);
        expected = asymmetricResult.self;
        actual = asymmetricResult.other;
      }
    }

    var i;
    handleAsymmetricExpected();

    for (i = 0; i < objectPath.components.length; i++) {
      actual = actual[objectPath.components[i]];
      expected = expected[objectPath.components[i]];
      handleAsymmetricExpected();
    }

    return {actual: actual, expected: expected};
  }

};

getJasmineRequireObj().MatchersUtil = function(j$) {
  // TODO: convert all uses of j$.pp to use the injected pp

  /**
   * _Note:_ Do not construct this directly. Jasmine will construct one and
   * pass it to matchers and asymmetric equality testers.
   * @name MatchersUtil
   * @classdesc Utilities for use in implementing matchers
   * @constructor
   */
  function MatchersUtil(options) {
    options = options || {};
    this.customTesters_ = options.customTesters || [];
    /**
     * Formats a value for use in matcher failure messages and similar contexts,
     * taking into account the current set of custom value formatters.
     * @function
     * @name MatchersUtil#pp
     * @since 3.6.0
     * @param {*} value The value to pretty-print
     * @return {string} The pretty-printed value
     */
    this.pp = options.pp || function() {};
  };

  /**
   * Determines whether `haystack` contains `needle`, using the same comparison
   * logic as {@link MatchersUtil#equals}.
   * @function
   * @name MatchersUtil#contains
   * @since 2.0.0
   * @param {*} haystack The collection to search
   * @param {*} needle The value to search for
   * @param [customTesters] An array of custom equality testers
   * @returns {boolean} True if `needle` was found in `haystack`
   */
  MatchersUtil.prototype.contains = function(haystack, needle, customTesters) {
    if (j$.isSet(haystack)) {
      return haystack.has(needle);
    }

    if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||
      (!!haystack && !haystack.indexOf))
    {
      for (var i = 0; i < haystack.length; i++) {
        if (this.equals(haystack[i], needle, customTesters)) {
          return true;
        }
      }
      return false;
    }

    return !!haystack && haystack.indexOf(needle) >= 0;
  };

  MatchersUtil.prototype.buildFailureMessage = function() {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 0),
      matcherName = args[0],
      isNot = args[1],
      actual = args[2],
      expected = args.slice(3),
      englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });

    var message = 'Expected ' +
      self.pp(actual) +
      (isNot ? ' not ' : ' ') +
      englishyPredicate;

    if (expected.length > 0) {
      for (var i = 0; i < expected.length; i++) {
        if (i > 0) {
          message += ',';
        }
        message += ' ' + self.pp(expected[i]);
      }
    }

    return message + '.';
  };

  MatchersUtil.prototype.asymmetricDiff_ = function(a, b, aStack, bStack, customTesters, diffBuilder) {
    if (j$.isFunction_(b.valuesForDiff_)) {
      var values = b.valuesForDiff_(a, this.pp);
      this.eq_(values.other, values.self, aStack, bStack, customTesters, diffBuilder);
    } else {
      diffBuilder.recordMismatch();
    }
  };

  MatchersUtil.prototype.asymmetricMatch_ = function(a, b, aStack, bStack, customTesters, diffBuilder) {
    var asymmetricA = j$.isAsymmetricEqualityTester_(a),
        asymmetricB = j$.isAsymmetricEqualityTester_(b),
        shim,
        result;

    if (asymmetricA === asymmetricB) {
      return undefined;
    }

    shim = j$.asymmetricEqualityTesterArgCompatShim(this, customTesters);

    if (asymmetricA) {
      result = a.asymmetricMatch(b, shim);
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }

    if (asymmetricB) {
      result = b.asymmetricMatch(a, shim);
      if (!result) {
        this.asymmetricDiff_(a, b, aStack, bStack, customTesters, diffBuilder);
      }
      return result;
    }
  };

  /**
   * Determines whether two values are deeply equal to each other.
   * @function
   * @name MatchersUtil#equals
   * @since 2.0.0
   * @param {*} a The first value to compare
   * @param {*} b The second value to compare
   * @param [customTesters] An array of custom equality testers
   * @returns {boolean} True if the values are equal
   */
  MatchersUtil.prototype.equals = function(a, b, customTestersOrDiffBuilder, diffBuilderOrNothing) {
    var customTesters, diffBuilder;

    if (isDiffBuilder(customTestersOrDiffBuilder)) {
      diffBuilder = customTestersOrDiffBuilder;
    } else {
      customTesters = customTestersOrDiffBuilder;
      diffBuilder = diffBuilderOrNothing;
    }

    customTesters = customTesters || this.customTesters_;
    diffBuilder = diffBuilder || j$.NullDiffBuilder();
    diffBuilder.setRoots(a, b);

    return this.eq_(a, b, [], [], customTesters, diffBuilder);
  };

  // Equality function lovingly adapted from isEqual in
  //   [Underscore](http://underscorejs.org)
  MatchersUtil.prototype.eq_ = function(a, b, aStack, bStack, customTesters, diffBuilder) {
    var result = true, self = this, i;

    var asymmetricResult = this.asymmetricMatch_(a, b, aStack, bStack, customTesters, diffBuilder);
    if (!j$.util.isUndefined(asymmetricResult)) {
      return asymmetricResult;
    }

    for (i = 0; i < customTesters.length; i++) {
      var customTesterResult = customTesters[i](a, b);
      if (!j$.util.isUndefined(customTesterResult)) {
        if (!customTesterResult) {
          diffBuilder.recordMismatch();
        }
        return customTesterResult;
      }
    }

    if (a instanceof Error && b instanceof Error) {
      result = a.message == b.message;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }

    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) {
      result = a !== 0 || 1 / a == 1 / b;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
      result = a === b;
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
      diffBuilder.recordMismatch();
      return false;
    }
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        result = a == String(b);
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        result = a != +a ? b != +b : (a === 0 && b === 0 ? 1 / a == 1 / b : a == +b);
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        result = +a == +b;
        if (!result) {
          diffBuilder.recordMismatch();
        }
        return result;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
          a.global == b.global &&
          a.multiline == b.multiline &&
          a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') {
      diffBuilder.recordMismatch();
      return false;
    }

    var aIsDomNode = j$.isDomNode(a);
    var bIsDomNode = j$.isDomNode(b);
    if (aIsDomNode && bIsDomNode) {
      // At first try to use DOM3 method isEqualNode
      result = a.isEqualNode(b);
      if (!result) {
        diffBuilder.recordMismatch();
      }
      return result;
    }
    if (aIsDomNode || bIsDomNode) {
      diffBuilder.recordMismatch();
      return false;
    }

    var aIsPromise = j$.isPromise(a);
    var bIsPromise = j$.isPromise(b);
    if (aIsPromise && bIsPromise) {
      return a === b;
    }

    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) { return bStack[length] == b; }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0;
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]') {
      var aLength = a.length;
      var bLength = b.length;

      diffBuilder.withPath('length', function() {
        if (aLength !== bLength) {
          diffBuilder.recordMismatch();
          result = false;
        }
      });

      for (i = 0; i < aLength || i < bLength; i++) {
        diffBuilder.withPath(i, function() {
          if (i >= bLength) {
            diffBuilder.recordMismatch(actualArrayIsLongerFormatter.bind(null, self.pp));
            result = false;
          } else {
            result = self.eq_(i < aLength ? a[i] : void 0, i < bLength ? b[i] : void 0, aStack, bStack, customTesters, diffBuilder) && result;
          }
        });
      }
      if (!result) {
        return false;
      }
    } else if (j$.isMap(a) && j$.isMap(b)) {
      if (a.size != b.size) {
        diffBuilder.recordMismatch();
        return false;
      }

      var keysA = [];
      var keysB = [];
      a.forEach( function( valueA, keyA ) {
        keysA.push( keyA );
      });
      b.forEach( function( valueB, keyB ) {
        keysB.push( keyB );
      });

      // For both sets of keys, check they map to equal values in both maps.
      // Keep track of corresponding keys (in insertion order) in order to handle asymmetric obj keys.
      var mapKeys = [keysA, keysB];
      var cmpKeys = [keysB, keysA];
      var mapIter, mapKey, mapValueA, mapValueB;
      var cmpIter, cmpKey;
      for (i = 0; result && i < mapKeys.length; i++) {
        mapIter = mapKeys[i];
        cmpIter = cmpKeys[i];

        for (var j = 0; result && j < mapIter.length; j++) {
          mapKey = mapIter[j];
          cmpKey = cmpIter[j];
          mapValueA = a.get(mapKey);

          // Only use the cmpKey when one of the keys is asymmetric and the corresponding key matches,
          // otherwise explicitly look up the mapKey in the other Map since we want keys with unique
          // obj identity (that are otherwise equal) to not match.
          if (j$.isAsymmetricEqualityTester_(mapKey) || j$.isAsymmetricEqualityTester_(cmpKey) &&
              this.eq_(mapKey, cmpKey, aStack, bStack, customTesters, j$.NullDiffBuilder())) {
            mapValueB = b.get(cmpKey);
          } else {
            mapValueB = b.get(mapKey);
          }
          result = this.eq_(mapValueA, mapValueB, aStack, bStack, customTesters, j$.NullDiffBuilder());
        }
      }

      if (!result) {
        diffBuilder.recordMismatch();
        return false;
      }
    } else if (j$.isSet(a) && j$.isSet(b)) {
      if (a.size != b.size) {
        diffBuilder.recordMismatch();
        return false;
      }

      var valuesA = [];
      a.forEach( function( valueA ) {
        valuesA.push( valueA );
      });
      var valuesB = [];
      b.forEach( function( valueB ) {
        valuesB.push( valueB );
      });

      // For both sets, check they are all contained in the other set
      var setPairs = [[valuesA, valuesB], [valuesB, valuesA]];
      var stackPairs = [[aStack, bStack], [bStack, aStack]];
      var baseValues, baseValue, baseStack;
      var otherValues, otherValue, otherStack;
      var found;
      var prevStackSize;
      for (i = 0; result && i < setPairs.length; i++) {
        baseValues = setPairs[i][0];
        otherValues = setPairs[i][1];
        baseStack = stackPairs[i][0];
        otherStack = stackPairs[i][1];
        // For each value in the base set...
        for (var k = 0; result && k < baseValues.length; k++) {
          baseValue = baseValues[k];
          found = false;
          // ... test that it is present in the other set
          for (var l = 0; !found && l < otherValues.length; l++) {
            otherValue = otherValues[l];
            prevStackSize = baseStack.length;
            // compare by value equality
            found = this.eq_(baseValue, otherValue, baseStack, otherStack, customTesters, j$.NullDiffBuilder());
            if (!found && prevStackSize !== baseStack.length) {
              baseStack.splice(prevStackSize);
              otherStack.splice(prevStackSize);
            }
          }
          result = result && found;
        }
      }

      if (!result) {
        diffBuilder.recordMismatch();
        return false;
      }
    } else {

      // Objects with different constructors are not equivalent, but `Object`s
      // or `Array`s from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor &&
          isFunction(aCtor) && isFunction(bCtor) &&
          a instanceof aCtor && b instanceof bCtor &&
          !(aCtor instanceof aCtor && bCtor instanceof bCtor)) {

        diffBuilder.recordMismatch(constructorsAreDifferentFormatter.bind(null, this.pp));
        return false;
      }
    }

    // Deep compare objects.
    var aKeys = keys(a, className == '[object Array]'), key;
    size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, className == '[object Array]').length !== size) {
      diffBuilder.recordMismatch(objectKeysAreDifferentFormatter.bind(null, this.pp));
      return false;
    }

    for (i = 0; i < size; i++) {
      key = aKeys[i];
      // Deep compare each member
      if (!j$.util.has(b, key)) {
        diffBuilder.recordMismatch(objectKeysAreDifferentFormatter.bind(null, this.pp));
        result = false;
        continue;
      }

      diffBuilder.withPath(key, function() {
        if(!self.eq_(a[key], b[key], aStack, bStack, customTesters, diffBuilder)) {
          result = false;
        }
      });
    }

    if (!result) {
      return false;
    }

    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;
  };

  function keys(obj, isArray) {
    var allKeys = Object.keys ? Object.keys(obj) :
      (function(o) {
          var keys = [];
          for (var key in o) {
              if (j$.util.has(o, key)) {
                  keys.push(key);
              }
          }
          return keys;
      })(obj);

    if (!isArray) {
      return allKeys;
    }

    if (allKeys.length === 0) {
        return allKeys;
    }

    var extraKeys = [];
    for (var i = 0; i < allKeys.length; i++) {
      if (!/^[0-9]+$/.test(allKeys[i])) {
        extraKeys.push(allKeys[i]);
      }
    }

    return extraKeys;
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function objectKeysAreDifferentFormatter(pp, actual, expected, path) {
    var missingProperties = j$.util.objectDifference(expected, actual),
        extraProperties = j$.util.objectDifference(actual, expected),
        missingPropertiesMessage = formatKeyValuePairs(pp, missingProperties),
        extraPropertiesMessage = formatKeyValuePairs(pp, extraProperties),
        messages = [];

    if (!path.depth()) {
      path = 'object';
    }

    if (missingPropertiesMessage.length) {
      messages.push('Expected ' + path + ' to have properties' + missingPropertiesMessage);
    }

    if (extraPropertiesMessage.length) {
      messages.push('Expected ' + path + ' not to have properties' + extraPropertiesMessage);
    }

    return messages.join('\n');
  }

  function constructorsAreDifferentFormatter(pp, actual, expected, path) {
    if (!path.depth()) {
      path = 'object';
    }

    return 'Expected ' +
      path + ' to be a kind of ' +
      j$.fnNameFor(expected.constructor) +
      ', but was ' + pp(actual) + '.';
  }

  function actualArrayIsLongerFormatter(pp, actual, expected, path) {
    return 'Unexpected ' +
      path + (path.depth() ? ' = ' : '') +
      pp(actual) +
      ' in array.';
  }

  function formatKeyValuePairs(pp, obj) {
    var formatted = '';
    for (var key in obj) {
      formatted += '\n    ' + key + ': ' + pp(obj[key]);
    }
    return formatted;
  }

  function isDiffBuilder(obj) {
    return obj && typeof obj.recordMismatch === 'function';
  }

  return MatchersUtil;
};

getJasmineRequireObj().MismatchTree = function (j$) {

  /*
    To be able to apply custom object formatters at all possible levels of an
    object graph, DiffBuilder needs to be able to know not just where the
    mismatch occurred but also all ancestors of the mismatched value in both
    the expected and actual object graphs. MismatchTree maintains that context
    and provides it via the traverse method.
   */
  function MismatchTree(path) {
    this.path = path || new j$.ObjectPath([]);
    this.formatter = undefined;
    this.children = [];
    this.isMismatch = false;
  }

  MismatchTree.prototype.add = function (path, formatter) {
    var key, child;

    if (path.depth() === 0) {
      this.formatter = formatter;
      this.isMismatch = true;
    } else {
      key = path.components[0];
      path = path.shift();
      child = this.child(key);

      if (!child) {
        child = new MismatchTree(this.path.add(key));
        this.children.push(child);
      }

      child.add(path, formatter);
    }
  };

  MismatchTree.prototype.traverse = function (visit) {
    var i, hasChildren = this.children.length > 0;

    if (this.isMismatch || hasChildren) {
      if (visit(this.path, !hasChildren, this.formatter)) {
        for (i = 0; i < this.children.length; i++) {
          this.children[i].traverse(visit);
        }
      }
    }
  };

  MismatchTree.prototype.child = function(key) {
    var i, pathEls;

    for (i = 0; i < this.children.length; i++) {
      pathEls = this.children[i].path.components;
      if (pathEls[pathEls.length - 1] === key) {
        return this.children[i];
      }
    }
  };

  return MismatchTree;
};


getJasmineRequireObj().nothing = function() {
  /**
   * {@link expect} nothing explicitly.
   * @function
   * @name matchers#nothing
   * @since 2.8.0
   * @example
   * expect().nothing();
   */
  function nothing() {
    return {
      compare: function() {
        return {
          pass: true
        };
      }
    };
  }

  return nothing;
};

getJasmineRequireObj().NullDiffBuilder = function(j$) {
  return function() {
    return {
      withPath: function(_, block) {
        block();
      },
      setRoots: function() {},
      recordMismatch: function() {}
    };
  };
};

getJasmineRequireObj().ObjectPath = function(j$) {
  function ObjectPath(components) {
    this.components = components || [];
  }

  ObjectPath.prototype.toString = function() {
    if (this.components.length) {
      return '$' + map(this.components, formatPropertyAccess).join('');
    } else {
      return '';
    }
  };

  ObjectPath.prototype.add = function(component) {
    return new ObjectPath(this.components.concat([component]));
  };

  ObjectPath.prototype.shift = function() {
    return new ObjectPath(this.components.slice(1));
  };

  ObjectPath.prototype.depth = function() {
    return this.components.length;
  };

  function formatPropertyAccess(prop) {
    if (typeof prop === 'number') {
      return '[' + prop + ']';
    }

    if (isValidIdentifier(prop)) {
      return '.' + prop;
    }

    return '[\'' + prop + '\']';
  }

  function map(array, fn) {
    var results = [];
    for (var i = 0; i < array.length; i++) {
      results.push(fn(array[i]));
    }
    return results;
  }

  function isValidIdentifier(string) {
    return /^[A-Za-z\$_][A-Za-z0-9\$_]*$/.test(string);
  }

  return ObjectPath;
};

getJasmineRequireObj().requireAsyncMatchers = function(jRequire, j$) {
  var availableMatchers = [
      'toBePending',
      'toBeResolved',
      'toBeRejected',
      'toBeResolvedTo',
      'toBeRejectedWith',
      'toBeRejectedWithError'
    ],
    matchers = {};

  for (var i = 0; i < availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
};

getJasmineRequireObj().toBe = function(j$) {
  /**
   * {@link expect} the actual value to be `===` to the expected value.
   * @function
   * @name matchers#toBe
   * @since 1.3.0
   * @param {Object} expected - The expected value to compare against.
   * @example
   * expect(thing).toBe(realThing);
   */
  function toBe(matchersUtil) {
    var tip = ' Tip: To check for deep equality, use .toEqual() instead of .toBe().';

    return {
      compare: function(actual, expected) {
        var result = {
          pass: actual === expected
        };

        if (typeof expected === 'object') {
          result.message = matchersUtil.buildFailureMessage('toBe', result.pass, actual, expected) + tip;
        }

        return result;
      }
    };
  }

  return toBe;
};

getJasmineRequireObj().toBeCloseTo = function() {
  /**
   * {@link expect} the actual value to be within a specified precision of the expected value.
   * @function
   * @name matchers#toBeCloseTo
   * @since 1.3.0
   * @param {Object} expected - The expected value to compare against.
   * @param {Number} [precision=2] - The number of decimal points to check.
   * @example
   * expect(number).toBeCloseTo(42.2, 3);
   */
  function toBeCloseTo() {
    return {
      compare: function(actual, expected, precision) {
        if (precision !== 0) {
          precision = precision || 2;
        }

        if (expected === null || actual === null) {
          throw new Error('Cannot use toBeCloseTo with null. Arguments evaluated to: ' +
            'expect(' + actual + ').toBeCloseTo(' + expected + ').'
          );
        }

        var pow = Math.pow(10, precision + 1);
        var delta = Math.abs(expected - actual);
        var maxDelta = Math.pow(10, -precision) / 2;

        return {
          pass: Math.round(delta * pow) <= maxDelta * pow
        };
      }
    };
  }

  return toBeCloseTo;
};

getJasmineRequireObj().toBeDefined = function() {
  /**
   * {@link expect} the actual value to be defined. (Not `undefined`)
   * @function
   * @name matchers#toBeDefined
   * @since 1.3.0
   * @example
   * expect(result).toBeDefined();
   */
  function toBeDefined() {
    return {
      compare: function(actual) {
        return {
          pass: (void 0 !== actual)
        };
      }
    };
  }

  return toBeDefined;
};

getJasmineRequireObj().toBeFalse = function() {
  /**
   * {@link expect} the actual value to be `false`.
   * @function
   * @name matchers#toBeFalse
   * @since 3.5.0
   * @example
   * expect(result).toBeFalse();
   */
  function toBeFalse() {
    return {
      compare: function(actual) {
        return {
          pass: actual === false
        };
      }
    };
  }

  return toBeFalse;
};

getJasmineRequireObj().toBeFalsy = function() {
  /**
   * {@link expect} the actual value to be falsy
   * @function
   * @name matchers#toBeFalsy
   * @since 2.0.0
   * @example
   * expect(result).toBeFalsy();
   */
  function toBeFalsy() {
    return {
      compare: function(actual) {
        return {
          pass: !actual
        };
      }
    };
  }

  return toBeFalsy;
};

getJasmineRequireObj().toBeGreaterThan = function() {
  /**
   * {@link expect} the actual value to be greater than the expected value.
   * @function
   * @name matchers#toBeGreaterThan
   * @since 2.0.0
   * @param {Number} expected - The value to compare against.
   * @example
   * expect(result).toBeGreaterThan(3);
   */
  function toBeGreaterThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual > expected
        };
      }
    };
  }

  return toBeGreaterThan;
};


getJasmineRequireObj().toBeGreaterThanOrEqual = function() {
  /**
   * {@link expect} the actual value to be greater than or equal to the expected value.
   * @function
   * @name matchers#toBeGreaterThanOrEqual
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeGreaterThanOrEqual(25);
   */
  function toBeGreaterThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual >= expected
        };
      }
    };
  }

  return toBeGreaterThanOrEqual;
};

getJasmineRequireObj().toBeInstanceOf = function(j$) {
  var usageError =  j$.formatErrorMsg('<toBeInstanceOf>', 'expect(value).toBeInstanceOf(<ConstructorFunction>)');

  /**
   * {@link expect} the actual to be an instance of the expected class
   * @function
   * @name matchers#toBeInstanceOf
   * @since 3.5.0
   * @param {Object} expected - The class or constructor function to check for
   * @example
   * expect('foo').toBeInstanceOf(String);
   * expect(3).toBeInstanceOf(Number);
   * expect(new Error()).toBeInstanceOf(Error);
   */
  function toBeInstanceOf(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var actualType = actual && actual.constructor ? j$.fnNameFor(actual.constructor) : matchersUtil.pp(actual),
            expectedType = expected ? j$.fnNameFor(expected) : matchersUtil.pp(expected),
            expectedMatcher,
            pass;

        try {
            expectedMatcher = new j$.Any(expected);
            pass = expectedMatcher.asymmetricMatch(actual);
        } catch (error) {
            throw new Error(usageError('Expected value is not a constructor function'));
        }

        if (pass) {
          return {
            pass: true,
            message: 'Expected instance of ' + actualType + ' not to be an instance of ' + expectedType
          };
        } else {
          return {
            pass: false,
            message: 'Expected instance of ' + actualType + ' to be an instance of ' + expectedType
          };
        }
      }
    };
  }

  return toBeInstanceOf;
};

getJasmineRequireObj().toBeLessThan = function() {
  /**
   * {@link expect} the actual value to be less than the expected value.
   * @function
   * @name matchers#toBeLessThan
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeLessThan(0);
   */
  function toBeLessThan() {
    return {

      compare: function(actual, expected) {
        return {
          pass: actual < expected
        };
      }
    };
  }

  return toBeLessThan;
};

getJasmineRequireObj().toBeLessThanOrEqual = function() {
  /**
   * {@link expect} the actual value to be less than or equal to the expected value.
   * @function
   * @name matchers#toBeLessThanOrEqual
   * @since 2.0.0
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeLessThanOrEqual(123);
   */
  function toBeLessThanOrEqual() {
    return {

      compare: function(actual, expected) {
        return {
          pass: actual <= expected
        };
      }
    };
  }

  return toBeLessThanOrEqual;
};

getJasmineRequireObj().toBeNaN = function(j$) {
  /**
   * {@link expect} the actual value to be `NaN` (Not a Number).
   * @function
   * @name matchers#toBeNaN
   * @since 1.3.0
   * @example
   * expect(thing).toBeNaN();
   */
  function toBeNaN(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: (actual !== actual)
        };

        if (result.pass) {
          result.message = 'Expected actual not to be NaN.';
        } else {
          result.message = function() { return 'Expected ' + matchersUtil.pp(actual) + ' to be NaN.'; };
        }

        return result;
      }
    };
  }

  return toBeNaN;
};

getJasmineRequireObj().toBeNegativeInfinity = function(j$) {
  /**
   * {@link expect} the actual value to be `-Infinity` (-infinity).
   * @function
   * @name matchers#toBeNegativeInfinity
   * @since 2.6.0
   * @example
   * expect(thing).toBeNegativeInfinity();
   */
  function toBeNegativeInfinity(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: (actual === Number.NEGATIVE_INFINITY)
        };

        if (result.pass) {
          result.message = 'Expected actual not to be -Infinity.';
        } else {
          result.message = function() { return 'Expected ' + matchersUtil.pp(actual) + ' to be -Infinity.'; };
        }

        return result;
      }
    };
  }

  return toBeNegativeInfinity;
};

getJasmineRequireObj().toBeNull = function() {
  /**
   * {@link expect} the actual value to be `null`.
   * @function
   * @name matchers#toBeNull
   * @since 1.3.0
   * @example
   * expect(result).toBeNull();
   */
  function toBeNull() {
    return {
      compare: function(actual) {
        return {
          pass: actual === null
        };
      }
    };
  }

  return toBeNull;
};

getJasmineRequireObj().toBePositiveInfinity = function(j$) {
  /**
   * {@link expect} the actual value to be `Infinity` (infinity).
   * @function
   * @name matchers#toBePositiveInfinity
   * @since 2.6.0
   * @example
   * expect(thing).toBePositiveInfinity();
   */
  function toBePositiveInfinity(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {
          pass: (actual === Number.POSITIVE_INFINITY)
        };

        if (result.pass) {
          result.message = 'Expected actual not to be Infinity.';
        } else {
          result.message = function() { return 'Expected ' + matchersUtil.pp(actual) + ' to be Infinity.'; };
        }

        return result;
      }
    };
  }

  return toBePositiveInfinity;
};

getJasmineRequireObj().toBeTrue = function() {
  /**
   * {@link expect} the actual value to be `true`.
   * @function
   * @name matchers#toBeTrue
   * @since 3.5.0
   * @example
   * expect(result).toBeTrue();
   */
  function toBeTrue() {
    return {
      compare: function(actual) {
        return {
          pass: actual === true
        };
      }
    };
  }

  return toBeTrue;
};

getJasmineRequireObj().toBeTruthy = function() {
  /**
   * {@link expect} the actual value to be truthy.
   * @function
   * @name matchers#toBeTruthy
   * @since 2.0.0
   * @example
   * expect(thing).toBeTruthy();
   */
  function toBeTruthy() {
    return {
      compare: function(actual) {
        return {
          pass: !!actual
        };
      }
    };
  }

  return toBeTruthy;
};

getJasmineRequireObj().toBeUndefined = function() {
  /**
   * {@link expect} the actual value to be `undefined`.
   * @function
   * @name matchers#toBeUndefined
   * @since 1.3.0
   * @example
   * expect(result).toBeUndefined():
   */
  function toBeUndefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 === actual
        };
      }
    };
  }

  return toBeUndefined;
};

getJasmineRequireObj().toContain = function() {
  /**
   * {@link expect} the actual value to contain a specific value.
   * @function
   * @name matchers#toContain
   * @since 2.0.0
   * @param {Object} expected - The value to look for.
   * @example
   * expect(array).toContain(anElement);
   * expect(string).toContain(substring);
   */
  function toContain(matchersUtil) {
    return {
      compare: function(actual, expected) {

        return {
          pass: matchersUtil.contains(actual, expected)
        };
      }
    };
  }

  return toContain;
};

getJasmineRequireObj().toEqual = function(j$) {
  /**
   * {@link expect} the actual value to be equal to the expected, using deep equality comparison.
   * @function
   * @name matchers#toEqual
   * @since 1.3.0
   * @param {Object} expected - Expected value
   * @example
   * expect(bigObject).toEqual({"foo": ['bar', 'baz']});
   */
  function toEqual(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var result = {
            pass: false
          },
          diffBuilder = j$.DiffBuilder({prettyPrinter: matchersUtil.pp});

        result.pass = matchersUtil.equals(actual, expected, diffBuilder);

        // TODO: only set error message if test fails
        result.message = diffBuilder.getMessage();

        return result;
      }
    };
  }

  return toEqual;
};

getJasmineRequireObj().toHaveBeenCalled = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalled>', 'expect(<spyObj>).toHaveBeenCalled()');

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called.
   * @function
   * @name matchers#toHaveBeenCalled
   * @since 1.3.0
   * @example
   * expect(mySpy).toHaveBeenCalled();
   * expect(mySpy).not.toHaveBeenCalled();
   */
  function toHaveBeenCalled(matchersUtil) {
    return {
      compare: function(actual) {
        var result = {};

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + matchersUtil.pp(actual) + '.'));
        }

        if (arguments.length > 1) {
          throw new Error(getErrorMsg('Does not take arguments, use toHaveBeenCalledWith'));
        }

        result.pass = actual.calls.any();

        result.message = result.pass ?
          'Expected spy ' + actual.and.identity + ' not to have been called.' :
          'Expected spy ' + actual.and.identity + ' to have been called.';

        return result;
      }
    };
  }

  return toHaveBeenCalled;
};

getJasmineRequireObj().toHaveBeenCalledBefore = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledBefore>', 'expect(<spyObj>).toHaveBeenCalledBefore(<spyObj>)');

  /**
   * {@link expect} the actual value (a {@link Spy}) to have been called before another {@link Spy}.
   * @function
   * @name matchers#toHaveBeenCalledBefore
   * @since 2.6.0
   * @param {Spy} expected - {@link Spy} that should have been called after the `actual` {@link Spy}.
   * @example
   * expect(mySpy).toHaveBeenCalledBefore(otherSpy);
   */
  function toHaveBeenCalledBefore(matchersUtil) {
    return {
      compare: function(firstSpy, latterSpy) {
        if (!j$.isSpy(firstSpy)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + matchersUtil.pp(firstSpy) + '.'));
        }
        if (!j$.isSpy(latterSpy)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + matchersUtil.pp(latterSpy) + '.'));
        }

        var result = { pass: false };

        if (!firstSpy.calls.count()) {
          result.message = 'Expected spy ' +  firstSpy.and.identity + ' to have been called.';
          return result;
        }
        if (!latterSpy.calls.count()) {
          result.message = 'Expected spy ' +  latterSpy.and.identity + ' to have been called.';
          return result;
        }

        var latest1stSpyCall = firstSpy.calls.mostRecent().invocationOrder;
        var first2ndSpyCall = latterSpy.calls.first().invocationOrder;

        result.pass = latest1stSpyCall < first2ndSpyCall;

        if (result.pass) {
          result.message = 'Expected spy ' + firstSpy.and.identity + ' to not have been called before spy ' + latterSpy.and.identity + ', but it was';
        } else {
          var first1stSpyCall = firstSpy.calls.first().invocationOrder;
          var latest2ndSpyCall = latterSpy.calls.mostRecent().invocationOrder;

          if(first1stSpyCall < first2ndSpyCall) {
            result.message = 'Expected latest call to spy ' + firstSpy.and.identity + ' to have been called before first call to spy ' + latterSpy.and.identity + ' (no interleaved calls)';
          } else if (latest2ndSpyCall > latest1stSpyCall) {
            result.message = 'Expected first call to spy ' + latterSpy.and.identity + ' to have been called after latest call to spy ' + firstSpy.and.identity + ' (no interleaved calls)';
          } else {
            result.message = 'Expected spy ' + firstSpy.and.identity + ' to have been called before spy ' + latterSpy.and.identity;
          }
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledBefore;
};

getJasmineRequireObj().toHaveBeenCalledOnceWith = function (j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledOnceWith>', 'expect(<spyObj>).toHaveBeenCalledOnceWith(...arguments)');

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called exactly once, and exactly with the particular arguments.
   * @function
   * @name matchers#toHaveBeenCalledOnceWith
   * @since 3.6.0
   * @param {...Object} - The arguments to look for
   * @example
   * expect(mySpy).toHaveBeenCalledOnceWith('foo', 'bar', 2);
   */
  function toHaveBeenCalledOnceWith(util) {
    return {
      compare: function () {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1);

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));
        }

        var prettyPrintedCalls = actual.calls.allArgs().map(function (argsForCall) {
          return '  ' + j$.pp(argsForCall);
        });

        if (actual.calls.count() === 1 && util.contains(actual.calls.allArgs(), expectedArgs)) {
          return {
            pass: true,
            message: 'Expected spy ' + actual.and.identity + ' to have been called 0 times, multiple times, or once, but with arguments different from:\n'
              + '  ' + j$.pp(expectedArgs) + '\n'
              + 'But the actual call was:\n'
              + prettyPrintedCalls.join(',\n') + '.\n\n'
          };
        }

        function getDiffs() {
          return actual.calls.allArgs().map(function (argsForCall, callIx) {
            var diffBuilder = new j$.DiffBuilder();
            util.equals(argsForCall, expectedArgs, diffBuilder);
            return diffBuilder.getMessage();
          });
        }

        function butString() {
          switch (actual.calls.count()) {
            case 0:
              return 'But it was never called.\n\n';
            case 1:
              return 'But the actual call was:\n' + prettyPrintedCalls.join(',\n') + '.\n' + getDiffs().join('\n') + '\n\n';
            default:
              return 'But the actual calls were:\n' + prettyPrintedCalls.join(',\n') + '.\n\n';
          }
        }

        return {
          pass: false,
          message: 'Expected spy ' + actual.and.identity + ' to have been called only once, and with given args:\n'
            + '  ' + j$.pp(expectedArgs) + '\n'
            + butString()
        };
      }
    };
  }

  return toHaveBeenCalledOnceWith;
};

getJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledTimes>', 'expect(<spyObj>).toHaveBeenCalledTimes(<Number>)');

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called the specified number of times.
   * @function
   * @name matchers#toHaveBeenCalledTimes
   * @since 2.4.0
   * @param {Number} expected - The number of invocations to look for.
   * @example
   * expect(mySpy).toHaveBeenCalledTimes(3);
   */
  function toHaveBeenCalledTimes(matchersUtil) {
    return {
      compare: function(actual, expected) {
        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + matchersUtil.pp(actual) + '.'));
        }

        var args = Array.prototype.slice.call(arguments, 0),
          result = { pass: false };

        if (!j$.isNumber_(expected)) {
          throw new Error(getErrorMsg('The expected times failed is a required argument and must be a number.'));
        }

        actual = args[0];
        var calls = actual.calls.count();
        var timesMessage = expected === 1 ? 'once' : expected + ' times';
        result.pass = calls === expected;
        result.message = result.pass ?
          'Expected spy ' + actual.and.identity + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :
          'Expected spy ' + actual.and.identity + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';
        return result;
      }
    };
  }

  return toHaveBeenCalledTimes;
};

getJasmineRequireObj().toHaveBeenCalledWith = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledWith>', 'expect(<spyObj>).toHaveBeenCalledWith(...arguments)');

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called with particular arguments at least once.
   * @function
   * @name matchers#toHaveBeenCalledWith
   * @since 1.3.0
   * @param {...Object} - The arguments to look for
   * @example
   * expect(mySpy).toHaveBeenCalledWith('foo', 'bar', 2);
   */
  function toHaveBeenCalledWith(matchersUtil) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1),
          result = { pass: false };

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + matchersUtil.pp(actual) + '.'));
        }

        if (!actual.calls.any()) {
          result.message = function() {
            return 'Expected spy ' + actual.and.identity + ' to have been called with:\n' +
              '  ' + matchersUtil.pp(expectedArgs) +
              '\nbut it was never called.';
          };
          return result;
        }

        if (matchersUtil.contains(actual.calls.allArgs(), expectedArgs)) {
          result.pass = true;
          result.message = function() {
            return 'Expected spy ' + actual.and.identity + ' not to have been called with:\n' +
              '  ' + matchersUtil.pp(expectedArgs) +
              '\nbut it was.';
          };
        } else {
          result.message = function() {
            var prettyPrintedCalls = actual.calls.allArgs().map(function(argsForCall) {
              return '  ' + matchersUtil.pp(argsForCall);
            });

            var diffs = actual.calls.allArgs().map(function(argsForCall, callIx) {
            var diffBuilder = new j$.DiffBuilder();
              matchersUtil.equals(argsForCall, expectedArgs, diffBuilder);
              return 'Call ' + callIx + ':\n' +
                diffBuilder.getMessage().replace(/^/mg, '  ');
            });

            return 'Expected spy ' + actual.and.identity + ' to have been called with:\n' +
              '  ' + matchersUtil.pp(expectedArgs) + '\n' + '' +
              'but actual calls were:\n' +
              prettyPrintedCalls.join(',\n') + '.\n\n' +
              diffs.join('\n');
          };
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledWith;
};

getJasmineRequireObj().toHaveClass = function(j$) {
  /**
   * {@link expect} the actual value to be a DOM element that has the expected class
   * @function
   * @name matchers#toHaveClass
   * @since 3.0.0
   * @param {Object} expected - The class name to test for
   * @example
   * var el = document.createElement('div');
   * el.className = 'foo bar baz';
   * expect(el).toHaveClass('bar');
   */
  function toHaveClass(matchersUtil) {
    return {
      compare: function(actual, expected) {
        if (!isElement(actual)) {
          throw new Error(matchersUtil.pp(actual) + ' is not a DOM element');
        }

        return {
          pass: actual.classList.contains(expected)
        };
      }
    };
  }

  function isElement(maybeEl) {
    return maybeEl &&
      maybeEl.classList &&
      j$.isFunction_(maybeEl.classList.contains);
  }

  return toHaveClass;
};

getJasmineRequireObj().toHaveSize = function(j$) {
  /**
   * {@link expect} the actual size to be equal to the expected, using array-like length or object keys size.
   * @function
   * @name matchers#toHaveSize
   * @since 3.6.0
   * @param {Object} expected - Expected size
   * @example
   * array = [1,2];
   * expect(array).toHaveSize(2);
   */
  function toHaveSize() {
    return {
      compare: function(actual, expected) {
        var result = {
            pass: false
          };

        if (j$.isA_('WeakSet', actual) || j$.isWeakMap(actual) || j$.isDataView(actual)) {
          throw new Error('Cannot get size of ' + actual + '.');
        }

        if (j$.isSet(actual) || j$.isMap(actual)) {
          result.pass = actual.size === expected;
        } else if (isLength(actual.length)) {
          result.pass = actual.length === expected;
        } else {
          result.pass = Object.keys(actual).length === expected;
        }

        return result;
      }
    };
  }

  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;  // eslint-disable-line compat/compat
  function isLength(value) {
    return (typeof value == 'number') && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;
  }

  return toHaveSize;
};

getJasmineRequireObj().toMatch = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toMatch>', 'expect(<expectation>).toMatch(<string> || <regexp>)');

  /**
   * {@link expect} the actual value to match a regular expression
   * @function
   * @name matchers#toMatch
   * @since 1.3.0
   * @param {RegExp|String} expected - Value to look for in the string.
   * @example
   * expect("my string").toMatch(/string$/);
   * expect("other string").toMatch("her");
   */
  function toMatch() {
    return {
      compare: function(actual, expected) {
        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
          throw new Error(getErrorMsg('Expected is not a String or a RegExp'));
        }

        var regexp = new RegExp(expected);

        return {
          pass: regexp.test(actual)
        };
      }
    };
  }

  return toMatch;
};

getJasmineRequireObj().toThrow = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toThrow>', 'expect(function() {<expectation>}).toThrow()');

  /**
   * {@link expect} a function to `throw` something.
   * @function
   * @name matchers#toThrow
   * @since 2.0.0
   * @param {Object} [expected] - Value that should be thrown. If not provided, simply the fact that something was thrown will be checked.
   * @example
   * expect(function() { return 'things'; }).toThrow('foo');
   * expect(function() { return 'stuff'; }).toThrow();
   */
  function toThrow(matchersUtil) {
    return {
      compare: function(actual, expected) {
        var result = { pass: false },
          threw = false,
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          result.message = 'Expected function to throw an exception.';
          return result;
        }

        if (arguments.length == 1) {
          result.pass = true;
          result.message = function() { return 'Expected function not to throw, but it threw ' + matchersUtil.pp(thrown) + '.'; };

          return result;
        }

        if (matchersUtil.equals(thrown, expected)) {
          result.pass = true;
          result.message = function() { return 'Expected function not to throw ' + matchersUtil.pp(expected) + '.'; };
        } else {
          result.message = function() { return 'Expected function to throw ' + matchersUtil.pp(expected) + ', but it threw ' +  matchersUtil.pp(thrown) + '.'; };
        }

        return result;
      }
    };
  }

  return toThrow;
};

getJasmineRequireObj().toThrowError = function(j$) {

  var getErrorMsg =  j$.formatErrorMsg('<toThrowError>', 'expect(function() {<expectation>}).toThrowError(<ErrorConstructor>, <message>)');

  /**
   * {@link expect} a function to `throw` an `Error`.
   * @function
   * @name matchers#toThrowError
   * @since 2.0.0
   * @param {Error} [expected] - `Error` constructor the object that was thrown needs to be an instance of. If not provided, `Error` will be used.
   * @param {RegExp|String} [message] - The message that should be set on the thrown `Error`
   * @example
   * expect(function() { return 'things'; }).toThrowError(MyCustomError, 'message');
   * expect(function() { return 'things'; }).toThrowError(MyCustomError, /bar/);
   * expect(function() { return 'stuff'; }).toThrowError(MyCustomError);
   * expect(function() { return 'other'; }).toThrowError(/foo/);
   * expect(function() { return 'other'; }).toThrowError();
   */
  function toThrowError(matchersUtil) {
    return {
      compare: function(actual) {
        var errorMatcher = getMatcher.apply(null, arguments),
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        try {
          actual();
          return fail('Expected function to throw an Error.');
        } catch (e) {
          thrown = e;
        }

        if (!j$.isError_(thrown)) {
          return fail(function() { return 'Expected function to throw an Error, but it threw ' + matchersUtil.pp(thrown) + '.'; });
        }

        return errorMatcher.match(thrown);
      }
    };

    function getMatcher() {
      var expected, errorType;

      if (arguments[2]) {
        errorType = arguments[1];
        expected = arguments[2];
        if (!isAnErrorType(errorType)) {
          throw new Error(getErrorMsg('Expected error type is not an Error.'));
        }

        return exactMatcher(expected, errorType);
      } else if (arguments[1]) {
        expected = arguments[1];

        if (isAnErrorType(arguments[1])) {
          return exactMatcher(null, arguments[1]);
        } else {
          return exactMatcher(arguments[1], null);
        }
      } else {
        return anyMatcher();
      }
    }

    function anyMatcher() {
      return {
        match: function(error) {
          return pass('Expected function not to throw an Error, but it threw ' + j$.fnNameFor(error) + '.');
        }
      };
    }

    function exactMatcher(expected, errorType) {
      if (expected && !isStringOrRegExp(expected)) {
        if (errorType) {
          throw new Error(getErrorMsg('Expected error message is not a string or RegExp.'));
        } else {
          throw new Error(getErrorMsg('Expected is not an Error, string, or RegExp.'));
        }
      }

      function messageMatch(message) {
        if (typeof expected == 'string') {
          return expected == message;
        } else {
          return expected.test(message);
        }
      }

      var errorTypeDescription = errorType ? j$.fnNameFor(errorType) : 'an exception';

      function thrownDescription(thrown) {
        var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',
            thrownMessage = '';

        if (expected) {
          thrownMessage = ' with message ' + matchersUtil.pp(thrown.message);
        }

        return thrownName + thrownMessage;
      }

      function messageDescription() {
        if (expected === null) {
          return '';
        } else if (expected instanceof RegExp) {
          return ' with a message matching ' + matchersUtil.pp(expected);
        } else {
          return ' with message ' + matchersUtil.pp(expected);
        }
      }

      function matches(error) {
        return (errorType === null || error instanceof errorType) &&
          (expected === null || messageMatch(error.message));
      }

      return {
        match: function(thrown) {
          if (matches(thrown)) {
            return pass(function() {
              return 'Expected function not to throw ' + errorTypeDescription + messageDescription() + '.';
            });
          } else {
            return fail(function() {
              return 'Expected function to throw ' + errorTypeDescription + messageDescription() +
                ', but it threw ' + thrownDescription(thrown) + '.';
            });
          }
        }
      };
    }

    function isStringOrRegExp(potential) {
      return potential instanceof RegExp || (typeof potential == 'string');
    }

    function isAnErrorType(type) {
      if (typeof type !== 'function') {
        return false;
      }

      var Surrogate = function() {};
      Surrogate.prototype = type.prototype;
      return j$.isError_(new Surrogate());
    }
  }

  function pass(message) {
    return {
      pass: true,
      message: message
    };
  }

  function fail(message) {
    return {
      pass: false,
      message: message
    };
  }

  return toThrowError;
};

getJasmineRequireObj().toThrowMatching = function(j$) {
  var usageError =  j$.formatErrorMsg('<toThrowMatching>', 'expect(function() {<expectation>}).toThrowMatching(<Predicate>)');

  /**
   * {@link expect} a function to `throw` something matching a predicate.
   * @function
   * @name matchers#toThrowMatching
   * @since 3.0.0
   * @param {Function} predicate - A function that takes the thrown exception as its parameter and returns true if it matches.
   * @example
   * expect(function() { throw new Error('nope'); }).toThrowMatching(function(thrown) { return thrown.message === 'nope'; });
   */
  function toThrowMatching(matchersUtil) {
    return {
      compare: function(actual, predicate) {
        var thrown;

        if (typeof actual !== 'function') {
          throw new Error(usageError('Actual is not a Function'));
        }

        if (typeof predicate !== 'function') {
          throw new Error(usageError('Predicate is not a Function'));
        }

        try {
          actual();
          return fail('Expected function to throw an exception.');
        } catch (e) {
          thrown = e;
        }

        if (predicate(thrown)) {
          return pass('Expected function not to throw an exception matching a predicate.');
        } else {
            return fail(function() {
              return 'Expected function to throw an exception matching a predicate, ' +
                'but it threw ' + thrownDescription(thrown) + '.';
            });
        }
      }
    };

    function thrownDescription(thrown) {
      if (thrown && thrown.constructor) {
        return j$.fnNameFor(thrown.constructor) + ' with message ' +
          matchersUtil.pp(thrown.message);
      } else {
        return matchersUtil.pp(thrown);
      }
    }
  }

  function pass(message) {
    return {
      pass: true,
      message: message
    };
  }

  function fail(message) {
    return {
      pass: false,
      message: message
    };
  }

  return toThrowMatching;
};

getJasmineRequireObj().MockDate = function() {
  function MockDate(global) {
    var self = this;
    var currentTime = 0;

    if (!global || !global.Date) {
      self.install = function() {};
      self.tick = function() {};
      self.uninstall = function() {};
      return self;
    }

    var GlobalDate = global.Date;

    self.install = function(mockDate) {
      if (mockDate instanceof GlobalDate) {
        currentTime = mockDate.getTime();
      } else {
        currentTime = new GlobalDate().getTime();
      }

      global.Date = FakeDate;
    };

    self.tick = function(millis) {
      millis = millis || 0;
      currentTime = currentTime + millis;
    };

    self.uninstall = function() {
      currentTime = 0;
      global.Date = GlobalDate;
    };

    createDateProperties();

    return self;

    function FakeDate() {
      switch (arguments.length) {
        case 0:
          return new GlobalDate(currentTime);
        case 1:
          return new GlobalDate(arguments[0]);
        case 2:
          return new GlobalDate(arguments[0], arguments[1]);
        case 3:
          return new GlobalDate(arguments[0], arguments[1], arguments[2]);
        case 4:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3]
          );
        case 5:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4]
          );
        case 6:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4],
            arguments[5]
          );
        default:
          return new GlobalDate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4],
            arguments[5],
            arguments[6]
          );
      }
    }

    function createDateProperties() {
      FakeDate.prototype = GlobalDate.prototype;

      FakeDate.now = function() {
        if (GlobalDate.now) {
          return currentTime;
        } else {
          throw new Error('Browser does not support Date.now()');
        }
      };

      FakeDate.toSource = GlobalDate.toSource;
      FakeDate.toString = GlobalDate.toString;
      FakeDate.parse = GlobalDate.parse;
      FakeDate.UTC = GlobalDate.UTC;
    }
  }

  return MockDate;
};

getJasmineRequireObj().makePrettyPrinter = function(j$) {
  function SinglePrettyPrintRun(customObjectFormatters, pp) {
    this.customObjectFormatters_ = customObjectFormatters;
    this.ppNestLevel_ = 0;
    this.seen = [];
    this.length = 0;
    this.stringParts = [];
    this.pp_ = pp;
  }

  function hasCustomToString(value) {
    // value.toString !== Object.prototype.toString if value has no custom toString but is from another context (e.g.
    // iframe, web worker)
    try {
      return (
        j$.isFunction_(value.toString) &&
        value.toString !== Object.prototype.toString &&
        value.toString() !== Object.prototype.toString.call(value)
      );
    } catch (e) {
      // The custom toString() threw.
      return true;
    }
  }

  SinglePrettyPrintRun.prototype.format = function(value) {
    this.ppNestLevel_++;
    try {
      var customFormatResult = this.applyCustomFormatters_(value);

      if (customFormatResult) {
        this.emitScalar(customFormatResult);
      } else if (j$.util.isUndefined(value)) {
        this.emitScalar('undefined');
      } else if (value === null) {
        this.emitScalar('null');
      } else if (value === 0 && 1 / value === -Infinity) {
        this.emitScalar('-0');
      } else if (value === j$.getGlobal()) {
        this.emitScalar('<global>');
      } else if (value.jasmineToString) {
        this.emitScalar(value.jasmineToString(this.pp_));
      } else if (typeof value === 'string') {
        this.emitString(value);
      } else if (j$.isSpy(value)) {
        this.emitScalar('spy on ' + value.and.identity);
      } else if (j$.isSpy(value.toString)) {
        this.emitScalar('spy on ' + value.toString.and.identity);
      } else if (value instanceof RegExp) {
        this.emitScalar(value.toString());
      } else if (typeof value === 'function') {
        this.emitScalar('Function');
      } else if (j$.isDomNode(value)) {
        if (value.tagName) {
          this.emitDomElement(value);
        } else {
          this.emitScalar('HTMLNode');
        }
      } else if (value instanceof Date) {
        this.emitScalar('Date(' + value + ')');
      } else if (j$.isSet(value)) {
        this.emitSet(value);
      } else if (j$.isMap(value)) {
        this.emitMap(value);
      } else if (j$.isTypedArray_(value)) {
        this.emitTypedArray(value);
      } else if (
        value.toString &&
        typeof value === 'object' &&
        !j$.isArray_(value) &&
        hasCustomToString(value)
      ) {
        try {
          this.emitScalar(value.toString());
        } catch (e) {
          this.emitScalar('has-invalid-toString-method');
        }
      } else if (j$.util.arrayContains(this.seen, value)) {
        this.emitScalar(
          '<circular reference: ' +
            (j$.isArray_(value) ? 'Array' : 'Object') +
            '>'
        );
      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {
        this.seen.push(value);
        if (j$.isArray_(value)) {
          this.emitArray(value);
        } else {
          this.emitObject(value);
        }
        this.seen.pop();
      } else {
        this.emitScalar(value.toString());
      }
    } catch (e) {
      if (this.ppNestLevel_ > 1 || !(e instanceof MaxCharsReachedError)) {
        throw e;
      }
    } finally {
      this.ppNestLevel_--;
    }
  };

  SinglePrettyPrintRun.prototype.applyCustomFormatters_ = function(value) {
    return customFormat(value, this.customObjectFormatters_);
  };

  SinglePrettyPrintRun.prototype.iterateObject = function(obj, fn) {
    var objKeys = keys(obj, j$.isArray_(obj));
    var isGetter = function isGetter(prop) {};

    if (obj.__lookupGetter__) {
      isGetter = function isGetter(prop) {
        var getter = obj.__lookupGetter__(prop);
        return !j$.util.isUndefined(getter) && getter !== null;
      };
    }
    var length = Math.min(objKeys.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    for (var i = 0; i < length; i++) {
      var property = objKeys[i];
      fn(property, isGetter(property));
    }

    return objKeys.length > length;
  };

  SinglePrettyPrintRun.prototype.emitScalar = function(value) {
    this.append(value);
  };

  SinglePrettyPrintRun.prototype.emitString = function(value) {
    this.append("'" + value + "'");
  };

  SinglePrettyPrintRun.prototype.emitArray = function(array) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Array');
      return;
    }
    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    this.append('[ ');
    for (var i = 0; i < length; i++) {
      if (i > 0) {
        this.append(', ');
      }
      this.format(array[i]);
    }
    if (array.length > length) {
      this.append(', ...');
    }

    var self = this;
    var first = array.length === 0;
    var truncated = this.iterateObject(array, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(array, property, isGetter);
    });

    if (truncated) {
      this.append(', ...');
    }

    this.append(' ]');
  };

  SinglePrettyPrintRun.prototype.emitSet = function(set) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Set');
      return;
    }
    this.append('Set( ');
    var size = Math.min(set.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    var i = 0;
    set.forEach(function(value, key) {
      if (i >= size) {
        return;
      }
      if (i > 0) {
        this.append(', ');
      }
      this.format(value);

      i++;
    }, this);
    if (set.size > size) {
      this.append(', ...');
    }
    this.append(' )');
  };

  SinglePrettyPrintRun.prototype.emitMap = function(map) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Map');
      return;
    }
    this.append('Map( ');
    var size = Math.min(map.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    var i = 0;
    map.forEach(function(value, key) {
      if (i >= size) {
        return;
      }
      if (i > 0) {
        this.append(', ');
      }
      this.format([key, value]);

      i++;
    }, this);
    if (map.size > size) {
      this.append(', ...');
    }
    this.append(' )');
  };

  SinglePrettyPrintRun.prototype.emitObject = function(obj) {
    var ctor = obj.constructor,
      constructorName;

    constructorName =
      typeof ctor === 'function' && obj instanceof ctor
        ? j$.fnNameFor(obj.constructor)
        : 'null';

    this.append(constructorName);

    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      return;
    }

    var self = this;
    this.append('({ ');
    var first = true;

    var truncated = this.iterateObject(obj, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(obj, property, isGetter);
    });

    if (truncated) {
      this.append(', ...');
    }

    this.append(' })');
  };

  SinglePrettyPrintRun.prototype.emitTypedArray = function(arr) {
    var constructorName = j$.fnNameFor(arr.constructor),
      limitedArray = Array.prototype.slice.call(
        arr,
        0,
        j$.MAX_PRETTY_PRINT_ARRAY_LENGTH
      ),
      itemsString = Array.prototype.join.call(limitedArray, ', ');

    if (limitedArray.length !== arr.length) {
      itemsString += ', ...';
    }

    this.append(constructorName + ' [ ' + itemsString + ' ]');
  };

  SinglePrettyPrintRun.prototype.emitDomElement = function(el) {
    var tagName = el.tagName.toLowerCase(),
      attrs = el.attributes,
      i,
      len = attrs.length,
      out = '<' + tagName,
      attr;

    for (i = 0; i < len; i++) {
      attr = attrs[i];
      out += ' ' + attr.name;

      if (attr.value !== '') {
        out += '="' + attr.value + '"';
      }
    }

    out += '>';

    if (el.childElementCount !== 0 || el.textContent !== '') {
      out += '...</' + tagName + '>';
    }

    this.append(out);
  };

  SinglePrettyPrintRun.prototype.formatProperty = function(
    obj,
    property,
    isGetter
  ) {
    this.append(property);
    this.append(': ');
    if (isGetter) {
      this.append('<getter>');
    } else {
      this.format(obj[property]);
    }
  };

  SinglePrettyPrintRun.prototype.append = function(value) {
    // This check protects us from the rare case where an object has overriden
    // `toString()` with an invalid implementation (returning a non-string).
    if (typeof value !== 'string') {
      value = Object.prototype.toString.call(value);
    }

    var result = truncate(value, j$.MAX_PRETTY_PRINT_CHARS - this.length);
    this.length += result.value.length;
    this.stringParts.push(result.value);

    if (result.truncated) {
      throw new MaxCharsReachedError();
    }
  };

  function truncate(s, maxlen) {
    if (s.length <= maxlen) {
      return { value: s, truncated: false };
    }

    s = s.substring(0, maxlen - 4) + ' ...';
    return { value: s, truncated: true };
  }

  function MaxCharsReachedError() {
    this.message =
      'Exceeded ' +
      j$.MAX_PRETTY_PRINT_CHARS +
      ' characters while pretty-printing a value';
  }

  MaxCharsReachedError.prototype = new Error();

  function keys(obj, isArray) {
    var allKeys = Object.keys
      ? Object.keys(obj)
      : (function(o) {
          var keys = [];
          for (var key in o) {
            if (j$.util.has(o, key)) {
              keys.push(key);
            }
          }
          return keys;
        })(obj);

    if (!isArray) {
      return allKeys;
    }

    if (allKeys.length === 0) {
      return allKeys;
    }

    var extraKeys = [];
    for (var i = 0; i < allKeys.length; i++) {
      if (!/^[0-9]+$/.test(allKeys[i])) {
        extraKeys.push(allKeys[i]);
      }
    }

    return extraKeys;
  }

  function customFormat(value, customObjectFormatters) {
    var i, result;

    for (i = 0; i < customObjectFormatters.length; i++) {
      result = customObjectFormatters[i](value);

      if (result !== undefined) {
        return result;
      }
    }
  }

  return function(customObjectFormatters) {
    customObjectFormatters = customObjectFormatters || [];

    var pp = function(value) {
      var prettyPrinter = new SinglePrettyPrintRun(customObjectFormatters, pp);
      prettyPrinter.format(value);
      return prettyPrinter.stringParts.join('');
    };

    pp.customFormat_ = function(value) {
      return customFormat(value, customObjectFormatters);
    };

    return pp;
  };
};

getJasmineRequireObj().QueueRunner = function(j$) {
  function StopExecutionError() {}
  StopExecutionError.prototype = new Error();
  j$.StopExecutionError = StopExecutionError;

  function once(fn) {
    var called = false;
    return function(arg) {
      if (!called) {
        called = true;
        // Direct call using single parameter, because cleanup/next does not need more
        fn(arg);
      }
      return null;
    };
  }

  function emptyFn() {}

  function QueueRunner(attrs) {
    var queueableFns = attrs.queueableFns || [];
    this.queueableFns = queueableFns.concat(attrs.cleanupFns || []);
    this.firstCleanupIx = queueableFns.length;
    this.onComplete = attrs.onComplete || emptyFn;
    this.clearStack =
      attrs.clearStack ||
      function(fn) {
        fn();
      };
    this.onException = attrs.onException || emptyFn;
    this.userContext = attrs.userContext || new j$.UserContext();
    this.timeout = attrs.timeout || {
      setTimeout: setTimeout,
      clearTimeout: clearTimeout
    };
    this.fail = attrs.fail || emptyFn;
    this.globalErrors = attrs.globalErrors || {
      pushListener: emptyFn,
      popListener: emptyFn
    };
    this.completeOnFirstError = !!attrs.completeOnFirstError;
    this.errored = false;

    if (typeof this.onComplete !== 'function') {
      throw new Error('invalid onComplete ' + JSON.stringify(this.onComplete));
    }
    this.deprecated = attrs.deprecated;
  }

  QueueRunner.prototype.execute = function() {
    var self = this;
    this.handleFinalError = function(message, source, lineno, colno, error) {
      // Older browsers would send the error as the first parameter. HTML5
      // specifies the the five parameters above. The error instance should
      // be preffered, otherwise the call stack would get lost.
      self.onException(error || message);
    };
    this.globalErrors.pushListener(this.handleFinalError);
    this.run(0);
  };

  QueueRunner.prototype.skipToCleanup = function(lastRanIndex) {
    if (lastRanIndex < this.firstCleanupIx) {
      this.run(this.firstCleanupIx);
    } else {
      this.run(lastRanIndex + 1);
    }
  };

  QueueRunner.prototype.clearTimeout = function(timeoutId) {
    Function.prototype.apply.apply(this.timeout.clearTimeout, [
      j$.getGlobal(),
      [timeoutId]
    ]);
  };

  QueueRunner.prototype.setTimeout = function(fn, timeout) {
    return Function.prototype.apply.apply(this.timeout.setTimeout, [
      j$.getGlobal(),
      [fn, timeout]
    ]);
  };

  QueueRunner.prototype.attempt = function attempt(iterativeIndex) {
    var self = this,
      completedSynchronously = true,
      handleError = function handleError(error) {
        onException(error);
        next(error);
      },
      cleanup = once(function cleanup() {
        if (timeoutId !== void 0) {
          self.clearTimeout(timeoutId);
        }
        self.globalErrors.popListener(handleError);
      }),
      next = once(function next(err) {
        cleanup();

        if (j$.isError_(err)) {
          if (!(err instanceof StopExecutionError) && !err.jasmineMessage) {
            self.fail(err);
          }
          self.errored = errored = true;
        }

        function runNext() {
          if (self.completeOnFirstError && errored) {
            self.skipToCleanup(iterativeIndex);
          } else {
            self.run(iterativeIndex + 1);
          }
        }

        if (completedSynchronously) {
          self.setTimeout(runNext);
        } else {
          runNext();
        }
      }),
      errored = false,
      queueableFn = self.queueableFns[iterativeIndex],
      timeoutId;

    next.fail = function nextFail() {
      self.fail.apply(null, arguments);
      self.errored = errored = true;
      next();
    };

    self.globalErrors.pushListener(handleError);

    if (queueableFn.timeout !== undefined) {
      var timeoutInterval = queueableFn.timeout || j$.DEFAULT_TIMEOUT_INTERVAL;
      timeoutId = self.setTimeout(function() {
        var error = new Error(
          'Timeout - Async function did not complete within ' +
            timeoutInterval +
            'ms ' +
            (queueableFn.timeout
              ? '(custom timeout)'
              : '(set by jasmine.DEFAULT_TIMEOUT_INTERVAL)')
        );
        onException(error);
        next();
      }, timeoutInterval);
    }

    try {
      if (queueableFn.fn.length === 0) {
        var maybeThenable = queueableFn.fn.call(self.userContext);

        if (maybeThenable && j$.isFunction_(maybeThenable.then)) {
          maybeThenable.then(next, onPromiseRejection);
          completedSynchronously = false;
          return { completedSynchronously: false };
        }
      } else {
        queueableFn.fn.call(self.userContext, next);
        completedSynchronously = false;
        return { completedSynchronously: false };
      }
    } catch (e) {
      onException(e);
      self.errored = errored = true;
    }

    cleanup();
    return { completedSynchronously: true, errored: errored };

    function onException(e) {
      self.onException(e);
      self.errored = errored = true;
    }

    function onPromiseRejection(e) {
      onException(e);
      next();
    }
  };

  QueueRunner.prototype.run = function(recursiveIndex) {
    var length = this.queueableFns.length,
      self = this,
      iterativeIndex;

    for (
      iterativeIndex = recursiveIndex;
      iterativeIndex < length;
      iterativeIndex++
    ) {
      var result = this.attempt(iterativeIndex);

      if (!result.completedSynchronously) {
        return;
      }

      self.errored = self.errored || result.errored;

      if (this.completeOnFirstError && result.errored) {
        this.skipToCleanup(iterativeIndex);
        return;
      }
    }

    this.clearStack(function() {
      self.globalErrors.popListener(self.handleFinalError);
      self.onComplete(self.errored && new StopExecutionError());
    });
  };

  return QueueRunner;
};

getJasmineRequireObj().ReportDispatcher = function(j$) {
  function ReportDispatcher(methods, queueRunnerFactory) {
    var dispatchedMethods = methods || [];

    for (var i = 0; i < dispatchedMethods.length; i++) {
      var method = dispatchedMethods[i];
      this[method] = (function(m) {
        return function() {
          dispatch(m, arguments);
        };
      })(method);
    }

    var reporters = [];
    var fallbackReporter = null;

    this.addReporter = function(reporter) {
      reporters.push(reporter);
    };

    this.provideFallbackReporter = function(reporter) {
      fallbackReporter = reporter;
    };

    this.clearReporters = function() {
      reporters = [];
    };

    return this;

    function dispatch(method, args) {
      if (reporters.length === 0 && fallbackReporter !== null) {
        reporters.push(fallbackReporter);
      }
      var onComplete = args[args.length - 1];
      args = j$.util.argsToArray(args).splice(0, args.length - 1);
      var fns = [];
      for (var i = 0; i < reporters.length; i++) {
        var reporter = reporters[i];
        addFn(fns, reporter, method, args);
      }

      queueRunnerFactory({
        queueableFns: fns,
        onComplete: onComplete,
        isReporter: true
      });
    }

    function addFn(fns, reporter, method, args) {
      var fn = reporter[method];
      if (!fn) {
        return;
      }

      var thisArgs = j$.util.cloneArgs(args);
      if (fn.length <= 1) {
        fns.push({
          fn: function() {
            return fn.apply(reporter, thisArgs);
          }
        });
      } else {
        fns.push({
          fn: function(done) {
            return fn.apply(reporter, thisArgs.concat([done]));
          }
        });
      }
    }
  }

  return ReportDispatcher;
};

getJasmineRequireObj().interface = function(jasmine, env) {
  var jasmineInterface = {
    /**
     * Callback passed to parts of the Jasmine base interface.
     *
     * By default Jasmine assumes this function completes synchronously.
     * If you have code that you need to test asynchronously, you can declare that you receive a `done` callback, return a Promise, or use the `async` keyword if it is supported in your environment.
     * @callback implementationCallback
     * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
     * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
     */

    /**
     * Create a group of specs (often called a suite).
     *
     * Calls to `describe` can be nested within other calls to compose your suite as a tree.
     * @name describe
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    describe: function(description, specDefinitions) {
      return env.describe(description, specDefinitions);
    },

    /**
     * A temporarily disabled [`describe`]{@link describe}
     *
     * Specs within an `xdescribe` will be marked pending and not executed
     * @name xdescribe
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    xdescribe: function(description, specDefinitions) {
      return env.xdescribe(description, specDefinitions);
    },

    /**
     * A focused [`describe`]{@link describe}
     *
     * If suites or specs are focused, only those that are focused will be executed
     * @see fit
     * @name fdescribe
     * @since 2.1.0
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    fdescribe: function(description, specDefinitions) {
      return env.fdescribe(description, specDefinitions);
    },

    /**
     * Define a single spec. A spec should contain one or more {@link expect|expectations} that test the state of the code.
     *
     * A spec whose expectations all succeed will be passing and a spec with any failures will fail.
     * The name `it` is a pronoun for the test target, not an abbreviation of anything. It makes the
     * spec more readable by connecting the function name `it` and the argument `description` as a
     * complete sentence.
     * @name it
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking
     * @param {implementationCallback} [testFunction] Function that contains the code of your test. If not provided the test will be `pending`.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.
     * @see async
     */
    it: function() {
      return env.it.apply(env, arguments);
    },

    /**
     * A temporarily disabled [`it`]{@link it}
     *
     * The spec will report as `pending` and will not be executed.
     * @name xit
     * @since 1.3.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking.
     * @param {implementationCallback} [testFunction] Function that contains the code of your test. Will not be executed.
     */
    xit: function() {
      return env.xit.apply(env, arguments);
    },

    /**
     * A focused [`it`]{@link it}
     *
     * If suites or specs are focused, only those that are focused will be executed.
     * @name fit
     * @since 2.1.0
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking.
     * @param {implementationCallback} testFunction Function that contains the code of your test.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.
     * @see async
     */
    fit: function() {
      return env.fit.apply(env, arguments);
    },

    /**
     * Run some shared setup before each of the specs in the {@link describe} in which it is called.
     * @name beforeEach
     * @since 1.3.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to setup your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeEach.
     * @see async
     */
    beforeEach: function() {
      return env.beforeEach.apply(env, arguments);
    },

    /**
     * Run some shared teardown after each of the specs in the {@link describe} in which it is called.
     * @name afterEach
     * @since 1.3.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterEach.
     * @see async
     */
    afterEach: function() {
      return env.afterEach.apply(env, arguments);
    },

    /**
     * Run some shared setup once before all of the specs in the {@link describe} are run.
     *
     * _Note:_ Be careful, sharing the setup from a beforeAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @name beforeAll
     * @since 2.1.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to setup your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeAll.
     * @see async
     */
    beforeAll: function() {
      return env.beforeAll.apply(env, arguments);
    },

    /**
     * Run some shared teardown once after all of the specs in the {@link describe} are run.
     *
     * _Note:_ Be careful, sharing the teardown from a afterAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @name afterAll
     * @since 2.1.0
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterAll.
     * @see async
     */
    afterAll: function() {
      return env.afterAll.apply(env, arguments);
    },

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SpecResult}
     * @name setSpecProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    setSpecProperty: function(key, value) {
      return env.setSpecProperty(key, value);
    },

    /**
     * Sets a user-defined property that will be provided to reporters as part of the properties field of {@link SuiteResult}
     * @name setSuiteProperty
     * @since 3.6.0
     * @function
     * @param {String} key The name of the property
     * @param {*} value The value of the property
     */
    setSuiteProperty: function(key, value) {
      return env.setSuiteProperty(key, value);
    },

    /**
     * Create an expectation for a spec.
     * @name expect
     * @since 1.3.0
     * @function
     * @global
     * @param {Object} actual - Actual computed value to test expectations against.
     * @return {matchers}
     */
    expect: function(actual) {
      return env.expect(actual);
    },

    /**
     * Create an asynchronous expectation for a spec. Note that the matchers
     * that are provided by an asynchronous expectation all return promises
     * which must be either returned from the spec or waited for using `await`
     * in order for Jasmine to associate them with the correct spec.
     * @name expectAsync
     * @since 3.3.0
     * @function
     * @global
     * @param {Object} actual - Actual computed value to test expectations against.
     * @return {async-matchers}
     * @example
     * await expectAsync(somePromise).toBeResolved();
     * @example
     * return expectAsync(somePromise).toBeResolved();
     */
    expectAsync: function(actual) {
      return env.expectAsync(actual);
    },

    /**
     * Mark a spec as pending, expectation results will be ignored.
     * @name pending
     * @since 2.0.0
     * @function
     * @global
     * @param {String} [message] - Reason the spec is pending.
     */
    pending: function() {
      return env.pending.apply(env, arguments);
    },

    /**
     * Explicitly mark a spec as failed.
     * @name fail
     * @since 2.1.0
     * @function
     * @global
     * @param {String|Error} [error] - Reason for the failure.
     */
    fail: function() {
      return env.fail.apply(env, arguments);
    },

    /**
     * Install a spy onto an existing object.
     * @name spyOn
     * @since 1.3.0
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}.
     * @param {String} methodName - The name of the method to replace with a {@link Spy}.
     * @returns {Spy}
     */
    spyOn: function(obj, methodName) {
      return env.spyOn(obj, methodName);
    },

    /**
     * Install a spy on a property installed with `Object.defineProperty` onto an existing object.
     * @name spyOnProperty
     * @since 2.6.0
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}
     * @param {String} propertyName - The name of the property to replace with a {@link Spy}.
     * @param {String} [accessType=get] - The access type (get|set) of the property to {@link Spy} on.
     * @returns {Spy}
     */
    spyOnProperty: function(obj, methodName, accessType) {
      return env.spyOnProperty(obj, methodName, accessType);
    },

    /**
     * Installs spies on all writable and configurable properties of an object.
     * @name spyOnAllFunctions
     * @since 3.2.1
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}s
     * @returns {Object} the spied object
     */
    spyOnAllFunctions: function(obj) {
      return env.spyOnAllFunctions(obj);
    },

    jsApiReporter: new jasmine.JsApiReporter({
      timer: new jasmine.Timer()
    }),

    /**
     * @namespace jasmine
     */
    jasmine: jasmine
  };

  /**
   * Add a custom equality tester for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addCustomEqualityTester
   * @since 2.0.0
   * @function
   * @param {Function} tester - A function which takes two arguments to compare and returns a `true` or `false` comparison result if it knows how to compare them, and `undefined` otherwise.
   * @see custom_equality
   */
  jasmine.addCustomEqualityTester = function(tester) {
    env.addCustomEqualityTester(tester);
  };

  /**
   * Add custom matchers for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addMatchers
   * @since 2.0.0
   * @function
   * @param {Object} matchers - Keys from this object will be the new matcher names.
   * @see custom_matcher
   */
  jasmine.addMatchers = function(matchers) {
    return env.addMatchers(matchers);
  };

  /**
   * Add custom async matchers for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addAsyncMatchers
   * @since 3.5.0
   * @function
   * @param {Object} matchers - Keys from this object will be the new async matcher names.
   * @see custom_matcher
   */
  jasmine.addAsyncMatchers = function(matchers) {
    return env.addAsyncMatchers(matchers);
  };

  /**
   * Add a custom object formatter for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addCustomObjectFormatter
   * @since 3.6.0
   * @function
   * @param {Function} formatter - A function which takes a value to format and returns a string if it knows how to format it, and `undefined` otherwise.
   * @see custom_object_formatters
   */
  jasmine.addCustomObjectFormatter = function(formatter) {
    return env.addCustomObjectFormatter(formatter);
  };

  /**
   * Get the currently booted mock {Clock} for this Jasmine environment.
   * @name jasmine.clock
   * @since 2.0.0
   * @function
   * @returns {Clock}
   */
  jasmine.clock = function() {
    return env.clock;
  };

  /**
   * Create a bare {@link Spy} object. This won't be installed anywhere and will not have any implementation behind it.
   * @name jasmine.createSpy
   * @since 1.3.0
   * @function
   * @param {String} [name] - Name to give the spy. This will be displayed in failure messages.
   * @param {Function} [originalFn] - Function to act as the real implementation.
   * @return {Spy}
   */
  jasmine.createSpy = function(name, originalFn) {
    return env.createSpy(name, originalFn);
  };

  /**
   * Create an object with multiple {@link Spy}s as its members.
   * @name jasmine.createSpyObj
   * @since 1.3.0
   * @function
   * @param {String} [baseName] - Base name for the spies in the object.
   * @param {String[]|Object} methodNames - Array of method names to create spies for, or Object whose keys will be method names and values the {@link Spy#and#returnValue|returnValue}.
   * @param {String[]|Object} [propertyNames] - Array of property names to create spies for, or Object whose keys will be propertynames and values the {@link Spy#and#returnValue|returnValue}.
   * @return {Object}
   */
  jasmine.createSpyObj = function(baseName, methodNames, propertyNames) {
    return env.createSpyObj(baseName, methodNames, propertyNames);
  };

  /**
   * Add a custom spy strategy for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addSpyStrategy
   * @since 3.5.0
   * @function
   * @param {String} name - The name of the strategy (i.e. what you call from `and`)
   * @param {Function} factory - Factory function that returns the plan to be executed.
   */
  jasmine.addSpyStrategy = function(name, factory) {
    return env.addSpyStrategy(name, factory);
  };

  /**
   * Set the default spy strategy for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.setDefaultSpyStrategy
   * @function
   * @param {Function} defaultStrategyFn - a function that assigns a strategy
   * @example
   * beforeEach(function() {
   *   jasmine.setDefaultSpyStrategy(and => and.returnValue(true));
   * });
   */
  jasmine.setDefaultSpyStrategy = function(defaultStrategyFn) {
    return env.setDefaultSpyStrategy(defaultStrategyFn);
  };

  return jasmineInterface;
};

getJasmineRequireObj().Spy = function(j$) {
  var nextOrder = (function() {
    var order = 0;

    return function() {
      return order++;
    };
  })();

  var matchersUtil = new j$.MatchersUtil({
    customTesters: [],
    pp: j$.makePrettyPrinter()
  });

  /**
   * _Note:_ Do not construct this directly, use {@link spyOn}, {@link spyOnProperty}, {@link jasmine.createSpy}, or {@link jasmine.createSpyObj}
   * @constructor
   * @name Spy
   */
  function Spy(
    name,
    originalFn,
    customStrategies,
    defaultStrategyFn,
    getPromise
  ) {
    var numArgs = typeof originalFn === 'function' ? originalFn.length : 0,
      wrapper = makeFunc(numArgs, function(context, args, invokeNew) {
        return spy(context, args, invokeNew);
      }),
      strategyDispatcher = new SpyStrategyDispatcher({
        name: name,
        fn: originalFn,
        getSpy: function() {
          return wrapper;
        },
        customStrategies: customStrategies,
        getPromise: getPromise
      }),
      callTracker = new j$.CallTracker(),
      spy = function(context, args, invokeNew) {
        /**
         * @name Spy.callData
         * @property {object} object - `this` context for the invocation.
         * @property {number} invocationOrder - Order of the invocation.
         * @property {Array} args - The arguments passed for this invocation.
         */
        var callData = {
          object: context,
          invocationOrder: nextOrder(),
          args: Array.prototype.slice.apply(args)
        };

        callTracker.track(callData);
        var returnValue = strategyDispatcher.exec(context, args, invokeNew);
        callData.returnValue = returnValue;

        return returnValue;
      };

    function makeFunc(length, fn) {
      switch (length) {
        case 1:
          return function wrap1(a) {
            return fn(this, arguments, this instanceof wrap1);
          };
        case 2:
          return function wrap2(a, b) {
            return fn(this, arguments, this instanceof wrap2);
          };
        case 3:
          return function wrap3(a, b, c) {
            return fn(this, arguments, this instanceof wrap3);
          };
        case 4:
          return function wrap4(a, b, c, d) {
            return fn(this, arguments, this instanceof wrap4);
          };
        case 5:
          return function wrap5(a, b, c, d, e) {
            return fn(this, arguments, this instanceof wrap5);
          };
        case 6:
          return function wrap6(a, b, c, d, e, f) {
            return fn(this, arguments, this instanceof wrap6);
          };
        case 7:
          return function wrap7(a, b, c, d, e, f, g) {
            return fn(this, arguments, this instanceof wrap7);
          };
        case 8:
          return function wrap8(a, b, c, d, e, f, g, h) {
            return fn(this, arguments, this instanceof wrap8);
          };
        case 9:
          return function wrap9(a, b, c, d, e, f, g, h, i) {
            return fn(this, arguments, this instanceof wrap9);
          };
        default:
          return function wrap() {
            return fn(this, arguments, this instanceof wrap);
          };
      }
    }

    for (var prop in originalFn) {
      if (prop === 'and' || prop === 'calls') {
        throw new Error(
          "Jasmine spies would overwrite the 'and' and 'calls' properties on the object being spied upon"
        );
      }

      wrapper[prop] = originalFn[prop];
    }

    /**
     * @member {SpyStrategy} - Accesses the default strategy for the spy. This strategy will be used
     * whenever the spy is called with arguments that don't match any strategy
     * created with {@link Spy#withArgs}.
     * @name Spy#and
     * @since 2.0.0
     * @example
     * spyOn(someObj, 'func').and.returnValue(42);
     */
    wrapper.and = strategyDispatcher.and;
    /**
     * Specifies a strategy to be used for calls to the spy that have the
     * specified arguments.
     * @name Spy#withArgs
     * @since 3.0.0
     * @function
     * @param {...*} args - The arguments to match
     * @type {SpyStrategy}
     * @example
     * spyOn(someObj, 'func').withArgs(1, 2, 3).and.returnValue(42);
     * someObj.func(1, 2, 3); // returns 42
     */
    wrapper.withArgs = function() {
      return strategyDispatcher.withArgs.apply(strategyDispatcher, arguments);
    };
    wrapper.calls = callTracker;

    if (defaultStrategyFn) {
      defaultStrategyFn(wrapper.and);
    }

    return wrapper;
  }

  function SpyStrategyDispatcher(strategyArgs) {
    var baseStrategy = new j$.SpyStrategy(strategyArgs);
    var argsStrategies = new StrategyDict(function() {
      return new j$.SpyStrategy(strategyArgs);
    });

    this.and = baseStrategy;

    this.exec = function(spy, args, invokeNew) {
      var strategy = argsStrategies.get(args);

      if (!strategy) {
        if (argsStrategies.any() && !baseStrategy.isConfigured()) {
          throw new Error(
            "Spy '" +
              strategyArgs.name +
              "' received a call with arguments " +
              j$.pp(Array.prototype.slice.call(args)) +
              ' but all configured strategies specify other arguments.'
          );
        } else {
          strategy = baseStrategy;
        }
      }

      return strategy.exec(spy, args, invokeNew);
    };

    this.withArgs = function() {
      return { and: argsStrategies.getOrCreate(arguments) };
    };
  }

  function StrategyDict(strategyFactory) {
    this.strategies = [];
    this.strategyFactory = strategyFactory;
  }

  StrategyDict.prototype.any = function() {
    return this.strategies.length > 0;
  };

  StrategyDict.prototype.getOrCreate = function(args) {
    var strategy = this.get(args);

    if (!strategy) {
      strategy = this.strategyFactory();
      this.strategies.push({
        args: args,
        strategy: strategy
      });
    }

    return strategy;
  };

  StrategyDict.prototype.get = function(args) {
    var i;

    for (i = 0; i < this.strategies.length; i++) {
      if (matchersUtil.equals(args, this.strategies[i].args)) {
        return this.strategies[i].strategy;
      }
    }
  };

  return Spy;
};

getJasmineRequireObj().SpyFactory = function(j$) {
  function SpyFactory(getCustomStrategies, getDefaultStrategyFn, getPromise) {
    var self = this;

    this.createSpy = function(name, originalFn) {
      return j$.Spy(
        name,
        originalFn,
        getCustomStrategies(),
        getDefaultStrategyFn(),
        getPromise
      );
    };

    this.createSpyObj = function(baseName, methodNames, propertyNames) {
      var baseNameIsCollection =
        j$.isObject_(baseName) || j$.isArray_(baseName);

      if (baseNameIsCollection) {
        propertyNames = methodNames;
        methodNames = baseName;
        baseName = 'unknown';
      }

      var obj = {};
      var spy, descriptor;

      var methods = normalizeKeyValues(methodNames);
      for (var i = 0; i < methods.length; i++) {
        spy = obj[methods[i][0]] = self.createSpy(
          baseName + '.' + methods[i][0]
        );
        if (methods[i].length > 1) {
          spy.and.returnValue(methods[i][1]);
        }
      }

      var properties = normalizeKeyValues(propertyNames);
      for (var i = 0; i < properties.length; i++) {
        descriptor = {
          get: self.createSpy(baseName + '.' + properties[i][0] + '.get'),
          set: self.createSpy(baseName + '.' + properties[i][0] + '.set')
        };
        if (properties[i].length > 1) {
          descriptor.get.and.returnValue(properties[i][1]);
          descriptor.set.and.returnValue(properties[i][1]);
        }
        Object.defineProperty(obj, properties[i][0], descriptor);
      }

      if (methods.length === 0 && properties.length === 0) {
        throw 'createSpyObj requires a non-empty array or object of method names to create spies for';
      }

      return obj;
    };
  }

  function normalizeKeyValues(object) {
    var result = [];
    if (j$.isArray_(object)) {
      for (var i = 0; i < object.length; i++) {
        result.push([object[i]]);
      }
    } else if (j$.isObject_(object)) {
      for (var key in object) {
        if (object.hasOwnProperty(key)) {
          result.push([key, object[key]]);
        }
      }
    }
    return result;
  }

  return SpyFactory;
};

getJasmineRequireObj().SpyRegistry = function(j$) {
  var spyOnMsg = j$.formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');
  var spyOnPropertyMsg = j$.formatErrorMsg(
    '<spyOnProperty>',
    'spyOnProperty(<object>, <propName>, [accessType])'
  );

  function SpyRegistry(options) {
    options = options || {};
    var global = options.global || j$.getGlobal();
    var createSpy = options.createSpy;
    var currentSpies =
      options.currentSpies ||
      function() {
        return [];
      };

    this.allowRespy = function(allow) {
      this.respy = allow;
    };

    this.spyOn = function(obj, methodName) {
      var getErrorMsg = spyOnMsg;

      if (j$.util.isUndefined(obj) || obj === null) {
        throw new Error(
          getErrorMsg(
            'could not find an object to spy upon for ' + methodName + '()'
          )
        );
      }

      if (j$.util.isUndefined(methodName) || methodName === null) {
        throw new Error(getErrorMsg('No method name supplied'));
      }

      if (j$.util.isUndefined(obj[methodName])) {
        throw new Error(getErrorMsg(methodName + '() method does not exist'));
      }

      if (obj[methodName] && j$.isSpy(obj[methodName])) {
        if (this.respy) {
          return obj[methodName];
        } else {
          throw new Error(
            getErrorMsg(methodName + ' has already been spied upon')
          );
        }
      }

      var descriptor = Object.getOwnPropertyDescriptor(obj, methodName);

      if (descriptor && !(descriptor.writable || descriptor.set)) {
        throw new Error(
          getErrorMsg(methodName + ' is not declared writable or has no setter')
        );
      }

      var originalMethod = obj[methodName],
        spiedMethod = createSpy(methodName, originalMethod),
        restoreStrategy;

      if (
        Object.prototype.hasOwnProperty.call(obj, methodName) ||
        (obj === global && methodName === 'onerror')
      ) {
        restoreStrategy = function() {
          obj[methodName] = originalMethod;
        };
      } else {
        restoreStrategy = function() {
          if (!delete obj[methodName]) {
            obj[methodName] = originalMethod;
          }
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      obj[methodName] = spiedMethod;

      return spiedMethod;
    };

    this.spyOnProperty = function(obj, propertyName, accessType) {
      var getErrorMsg = spyOnPropertyMsg;

      accessType = accessType || 'get';

      if (j$.util.isUndefined(obj)) {
        throw new Error(
          getErrorMsg(
            'spyOn could not find an object to spy upon for ' +
              propertyName +
              ''
          )
        );
      }

      if (j$.util.isUndefined(propertyName)) {
        throw new Error(getErrorMsg('No property name supplied'));
      }

      var descriptor = j$.util.getPropertyDescriptor(obj, propertyName);

      if (!descriptor) {
        throw new Error(getErrorMsg(propertyName + ' property does not exist'));
      }

      if (!descriptor.configurable) {
        throw new Error(
          getErrorMsg(propertyName + ' is not declared configurable')
        );
      }

      if (!descriptor[accessType]) {
        throw new Error(
          getErrorMsg(
            'Property ' +
              propertyName +
              ' does not have access type ' +
              accessType
          )
        );
      }

      if (j$.isSpy(descriptor[accessType])) {
        if (this.respy) {
          return descriptor[accessType];
        } else {
          throw new Error(
            getErrorMsg(
              propertyName + '#' + accessType + ' has already been spied upon'
            )
          );
        }
      }

      var originalDescriptor = j$.util.clone(descriptor),
        spy = createSpy(propertyName, descriptor[accessType]),
        restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {
        restoreStrategy = function() {
          Object.defineProperty(obj, propertyName, originalDescriptor);
        };
      } else {
        restoreStrategy = function() {
          delete obj[propertyName];
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      descriptor[accessType] = spy;

      Object.defineProperty(obj, propertyName, descriptor);

      return spy;
    };

    this.spyOnAllFunctions = function(obj) {
      if (j$.util.isUndefined(obj)) {
        throw new Error(
          'spyOnAllFunctions could not find an object to spy upon'
        );
      }

      var pointer = obj,
        props = [],
        prop,
        descriptor;

      while (pointer) {
        for (prop in pointer) {
          if (
            Object.prototype.hasOwnProperty.call(pointer, prop) &&
            pointer[prop] instanceof Function
          ) {
            descriptor = Object.getOwnPropertyDescriptor(pointer, prop);
            if (
              (descriptor.writable || descriptor.set) &&
              descriptor.configurable
            ) {
              props.push(prop);
            }
          }
        }
        pointer = Object.getPrototypeOf(pointer);
      }

      for (var i = 0; i < props.length; i++) {
        this.spyOn(obj, props[i]);
      }

      return obj;
    };

    this.clearSpies = function() {
      var spies = currentSpies();
      for (var i = spies.length - 1; i >= 0; i--) {
        var spyEntry = spies[i];
        spyEntry.restoreObjectToOriginalState();
      }
    };
  }

  return SpyRegistry;
};

getJasmineRequireObj().SpyStrategy = function(j$) {
  /**
   * @interface SpyStrategy
   */
  function SpyStrategy(options) {
    options = options || {};

    var self = this;

    /**
     * Get the identifying information for the spy.
     * @name SpyStrategy#identity
     * @since 3.0.0
     * @member
     * @type {String}
     */
    this.identity = options.name || 'unknown';
    this.originalFn = options.fn || function() {};
    this.getSpy = options.getSpy || function() {};
    this.plan = this._defaultPlan = function() {};

    var k,
      cs = options.customStrategies || {};
    for (k in cs) {
      if (j$.util.has(cs, k) && !this[k]) {
        this[k] = createCustomPlan(cs[k]);
      }
    }

    var getPromise =
      typeof options.getPromise === 'function'
        ? options.getPromise
        : function() {};

    var requirePromise = function(name) {
      var Promise = getPromise();

      if (!Promise) {
        throw new Error(
          name +
            ' requires global Promise, or `Promise` configured with `jasmine.getEnv().configure()`'
        );
      }

      return Promise;
    };

    /**
     * Tell the spy to return a promise resolving to the specified value when invoked.
     * @name SpyStrategy#resolveTo
     * @since 3.5.0
     * @function
     * @param {*} value The value to return.
     */
    this.resolveTo = function(value) {
      var Promise = requirePromise('resolveTo');
      self.plan = function() {
        return Promise.resolve(value);
      };
      return self.getSpy();
    };

    /**
     * Tell the spy to return a promise rejecting with the specified value when invoked.
     * @name SpyStrategy#rejectWith
     * @since 3.5.0
     * @function
     * @param {*} value The value to return.
     */
    this.rejectWith = function(value) {
      var Promise = requirePromise('rejectWith');

      self.plan = function() {
        return Promise.reject(value);
      };
      return self.getSpy();
    };
  }

  function createCustomPlan(factory) {
    return function() {
      var plan = factory.apply(null, arguments);

      if (!j$.isFunction_(plan)) {
        throw new Error('Spy strategy must return a function');
      }

      this.plan = plan;
      return this.getSpy();
    };
  }

  /**
   * Execute the current spy strategy.
   * @name SpyStrategy#exec
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.exec = function(context, args, invokeNew) {
    var contextArgs = [context].concat(
      args ? Array.prototype.slice.call(args) : []
    );
    var target = this.plan.bind.apply(this.plan, contextArgs);

    return invokeNew ? new target() : target();
  };

  /**
   * Tell the spy to call through to the real implementation when invoked.
   * @name SpyStrategy#callThrough
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.callThrough = function() {
    this.plan = this.originalFn;
    return this.getSpy();
  };

  /**
   * Tell the spy to return the value when invoked.
   * @name SpyStrategy#returnValue
   * @since 2.0.0
   * @function
   * @param {*} value The value to return.
   */
  SpyStrategy.prototype.returnValue = function(value) {
    this.plan = function() {
      return value;
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to return one of the specified values (sequentially) each time the spy is invoked.
   * @name SpyStrategy#returnValues
   * @since 2.1.0
   * @function
   * @param {...*} values - Values to be returned on subsequent calls to the spy.
   */
  SpyStrategy.prototype.returnValues = function() {
    var values = Array.prototype.slice.call(arguments);
    this.plan = function() {
      return values.shift();
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to throw an error when invoked.
   * @name SpyStrategy#throwError
   * @since 2.0.0
   * @function
   * @param {Error|Object|String} something Thing to throw
   */
  SpyStrategy.prototype.throwError = function(something) {
    var error = j$.isString_(something) ? new Error(something) : something;
    this.plan = function() {
      throw error;
    };
    return this.getSpy();
  };

  /**
   * Tell the spy to call a fake implementation when invoked.
   * @name SpyStrategy#callFake
   * @since 2.0.0
   * @function
   * @param {Function} fn The function to invoke with the passed parameters.
   */
  SpyStrategy.prototype.callFake = function(fn) {
    if (!(j$.isFunction_(fn) || j$.isAsyncFunction_(fn))) {
      throw new Error(
        'Argument passed to callFake should be a function, got ' + fn
      );
    }
    this.plan = fn;
    return this.getSpy();
  };

  /**
   * Tell the spy to do nothing when invoked. This is the default.
   * @name SpyStrategy#stub
   * @since 2.0.0
   * @function
   */
  SpyStrategy.prototype.stub = function(fn) {
    this.plan = function() {};
    return this.getSpy();
  };

  SpyStrategy.prototype.isConfigured = function() {
    return this.plan !== this._defaultPlan;
  };

  return SpyStrategy;
};

getJasmineRequireObj().StackTrace = function(j$) {
  function StackTrace(error) {
    var lines = error.stack.split('\n').filter(function(line) {
      return line !== '';
    });

    var extractResult = extractMessage(error.message, lines);

    if (extractResult) {
      this.message = extractResult.message;
      lines = extractResult.remainder;
    }

    var parseResult = tryParseFrames(lines);
    this.frames = parseResult.frames;
    this.style = parseResult.style;
  }

  var framePatterns = [
    // PhantomJS on Linux, Node, Chrome, IE, Edge
    // e.g. "   at QueueRunner.run (http://localhost:8888/__jasmine__/jasmine.js:4320:20)"
    // Note that the "function name" can include a surprisingly large set of
    // characters, including angle brackets and square brackets.
    {
      re: /^\s*at ([^\)]+) \(([^\)]+)\)$/,
      fnIx: 1,
      fileLineColIx: 2,
      style: 'v8'
    },

    // NodeJS alternate form, often mixed in with the Chrome style
    // e.g. "  at /some/path:4320:20
    { re: /\s*at (.+)$/, fileLineColIx: 1, style: 'v8' },

    // PhantomJS on OS X, Safari, Firefox
    // e.g. "run@http://localhost:8888/__jasmine__/jasmine.js:4320:27"
    // or "http://localhost:8888/__jasmine__/jasmine.js:4320:27"
    {
      re: /^(([^@\s]+)@)?([^\s]+)$/,
      fnIx: 2,
      fileLineColIx: 3,
      style: 'webkit'
    }
  ];

  // regexes should capture the function name (if any) as group 1
  // and the file, line, and column as group 2.
  function tryParseFrames(lines) {
    var style = null;
    var frames = lines.map(function(line) {
      var convertedLine = first(framePatterns, function(pattern) {
        var overallMatch = line.match(pattern.re),
          fileLineColMatch;
        if (!overallMatch) {
          return null;
        }

        fileLineColMatch = overallMatch[pattern.fileLineColIx].match(
          /^(.*):(\d+):\d+$/
        );
        if (!fileLineColMatch) {
          return null;
        }

        style = style || pattern.style;
        return {
          raw: line,
          file: fileLineColMatch[1],
          line: parseInt(fileLineColMatch[2], 10),
          func: overallMatch[pattern.fnIx]
        };
      });

      return convertedLine || { raw: line };
    });

    return {
      style: style,
      frames: frames
    };
  }

  function first(items, fn) {
    var i, result;

    for (i = 0; i < items.length; i++) {
      result = fn(items[i]);

      if (result) {
        return result;
      }
    }
  }

  function extractMessage(message, stackLines) {
    var len = messagePrefixLength(message, stackLines);

    if (len > 0) {
      return {
        message: stackLines.slice(0, len).join('\n'),
        remainder: stackLines.slice(len)
      };
    }
  }

  function messagePrefixLength(message, stackLines) {
    if (!stackLines[0].match(/^\w*Error/)) {
      return 0;
    }

    var messageLines = message.split('\n');
    var i;

    for (i = 1; i < messageLines.length; i++) {
      if (messageLines[i] !== stackLines[i]) {
        return 0;
      }
    }

    return messageLines.length;
  }

  return StackTrace;
};

getJasmineRequireObj().Suite = function(j$) {
  function Suite(attrs) {
    this.env = attrs.env;
    this.id = attrs.id;
    this.parentSuite = attrs.parentSuite;
    this.description = attrs.description;
    this.expectationFactory = attrs.expectationFactory;
    this.asyncExpectationFactory = attrs.asyncExpectationFactory;
    this.expectationResultFactory = attrs.expectationResultFactory;
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;

    this.beforeFns = [];
    this.afterFns = [];
    this.beforeAllFns = [];
    this.afterAllFns = [];

    this.timer = attrs.timer || new j$.Timer();

    this.children = [];

    /**
     * @typedef SuiteResult
     * @property {Int} id - The unique id of this suite.
     * @property {String} description - The description text passed to the {@link describe} that made this suite.
     * @property {String} fullName - The full description including all ancestors of this suite.
     * @property {Expectation[]} failedExpectations - The list of expectations that failed in an {@link afterAll} for this suite.
     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred on this suite.
     * @property {String} status - Once the suite has completed, this string represents the pass/fail status of this suite.
     * @property {number} duration - The time in ms for Suite execution, including any before/afterAll, before/afterEach.
     * @property {Object} properties - User-supplied properties, if any, that were set using {@link Env#setSuiteProperty}
     */
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      deprecationWarnings: [],
      duration: null,
      properties: null
    };
  }

  Suite.prototype.setSuiteProperty = function(key, value) {
    this.result.properties = this.result.properties || {};
    this.result.properties[key] = value;
  };

  Suite.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Suite.prototype.expectAsync = function(actual) {
    return this.asyncExpectationFactory(actual, this);
  };

  Suite.prototype.getFullName = function() {
    var fullName = [];
    for (
      var parentSuite = this;
      parentSuite;
      parentSuite = parentSuite.parentSuite
    ) {
      if (parentSuite.parentSuite) {
        fullName.unshift(parentSuite.description);
      }
    }
    return fullName.join(' ');
  };

  Suite.prototype.pend = function() {
    this.markedPending = true;
  };

  Suite.prototype.beforeEach = function(fn) {
    this.beforeFns.unshift(fn);
  };

  Suite.prototype.beforeAll = function(fn) {
    this.beforeAllFns.push(fn);
  };

  Suite.prototype.afterEach = function(fn) {
    this.afterFns.unshift(fn);
  };

  Suite.prototype.afterAll = function(fn) {
    this.afterAllFns.unshift(fn);
  };

  Suite.prototype.startTimer = function() {
    this.timer.start();
  };

  Suite.prototype.endTimer = function() {
    this.result.duration = this.timer.elapsed();
  };

  function removeFns(queueableFns) {
    for (var i = 0; i < queueableFns.length; i++) {
      queueableFns[i].fn = null;
    }
  }

  Suite.prototype.cleanupBeforeAfter = function() {
    removeFns(this.beforeAllFns);
    removeFns(this.afterAllFns);
    removeFns(this.beforeFns);
    removeFns(this.afterFns);
  };

  Suite.prototype.addChild = function(child) {
    this.children.push(child);
  };

  Suite.prototype.status = function() {
    if (this.markedPending) {
      return 'pending';
    }

    if (this.result.failedExpectations.length > 0) {
      return 'failed';
    } else {
      return 'passed';
    }
  };

  Suite.prototype.canBeReentered = function() {
    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;
  };

  Suite.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Suite.prototype.sharedUserContext = function() {
    if (!this.sharedContext) {
      this.sharedContext = this.parentSuite
        ? this.parentSuite.clonedSharedUserContext()
        : new j$.UserContext();
    }

    return this.sharedContext;
  };

  Suite.prototype.clonedSharedUserContext = function() {
    return j$.UserContext.fromExisting(this.sharedUserContext());
  };

  Suite.prototype.onException = function() {
    if (arguments[0] instanceof j$.errors.ExpectationFailed) {
      return;
    }

    var data = {
      matcherName: '',
      passed: false,
      expected: '',
      actual: '',
      error: arguments[0]
    };
    var failedExpectation = this.expectationResultFactory(data);

    if (!this.parentSuite) {
      failedExpectation.globalErrorType = 'afterAll';
    }

    this.result.failedExpectations.push(failedExpectation);
  };

  Suite.prototype.addExpectationResult = function() {
    if (isFailure(arguments)) {
      var data = arguments[1];
      this.result.failedExpectations.push(this.expectationResultFactory(data));
      if (this.throwOnExpectationFailure) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Suite.prototype.addDeprecationWarning = function(deprecation) {
    if (typeof deprecation === 'string') {
      deprecation = { message: deprecation };
    }
    this.result.deprecationWarnings.push(
      this.expectationResultFactory(deprecation)
    );
  };

  function isFailure(args) {
    return !args[0];
  }

  return Suite;
};

if (typeof window == void 0 && typeof exports == 'object') {
  /* globals exports */
  exports.Suite = jasmineRequire.Suite;
}

getJasmineRequireObj().Timer = function() {
  var defaultNow = (function(Date) {
    return function() {
      return new Date().getTime();
    };
  })(Date);

  function Timer(options) {
    options = options || {};

    var now = options.now || defaultNow,
      startTime;

    this.start = function() {
      startTime = now();
    };

    this.elapsed = function() {
      return now() - startTime;
    };
  }

  return Timer;
};

getJasmineRequireObj().TreeProcessor = function() {
  function TreeProcessor(attrs) {
    var tree = attrs.tree,
      runnableIds = attrs.runnableIds,
      queueRunnerFactory = attrs.queueRunnerFactory,
      nodeStart = attrs.nodeStart || function() {},
      nodeComplete = attrs.nodeComplete || function() {},
      failSpecWithNoExpectations = !!attrs.failSpecWithNoExpectations,
      orderChildren =
        attrs.orderChildren ||
        function(node) {
          return node.children;
        },
      excludeNode =
        attrs.excludeNode ||
        function(node) {
          return false;
        },
      stats = { valid: true },
      processed = false,
      defaultMin = Infinity,
      defaultMax = 1 - Infinity;

    this.processTree = function() {
      processNode(tree, true);
      processed = true;
      return stats;
    };

    this.execute = function(done) {
      if (!processed) {
        this.processTree();
      }

      if (!stats.valid) {
        throw 'invalid order';
      }

      var childFns = wrapChildren(tree, 0);

      queueRunnerFactory({
        queueableFns: childFns,
        userContext: tree.sharedUserContext(),
        onException: function() {
          tree.onException.apply(tree, arguments);
        },
        onComplete: done
      });
    };

    function runnableIndex(id) {
      for (var i = 0; i < runnableIds.length; i++) {
        if (runnableIds[i] === id) {
          return i;
        }
      }
    }

    function processNode(node, parentExcluded) {
      var executableIndex = runnableIndex(node.id);

      if (executableIndex !== undefined) {
        parentExcluded = false;
      }

      if (!node.children) {
        var excluded = parentExcluded || excludeNode(node);
        stats[node.id] = {
          excluded: excluded,
          willExecute: !excluded && !node.markedPending,
          segments: [
            {
              index: 0,
              owner: node,
              nodes: [node],
              min: startingMin(executableIndex),
              max: startingMax(executableIndex)
            }
          ]
        };
      } else {
        var hasExecutableChild = false;

        var orderedChildren = orderChildren(node);

        for (var i = 0; i < orderedChildren.length; i++) {
          var child = orderedChildren[i];

          processNode(child, parentExcluded);

          if (!stats.valid) {
            return;
          }

          var childStats = stats[child.id];

          hasExecutableChild = hasExecutableChild || childStats.willExecute;
        }

        stats[node.id] = {
          excluded: parentExcluded,
          willExecute: hasExecutableChild
        };

        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);

        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {
          stats = { valid: false };
        }
      }
    }

    function startingMin(executableIndex) {
      return executableIndex === undefined ? defaultMin : executableIndex;
    }

    function startingMax(executableIndex) {
      return executableIndex === undefined ? defaultMax : executableIndex;
    }

    function segmentChildren(
      node,
      orderedChildren,
      nodeStats,
      executableIndex
    ) {
      var currentSegment = {
          index: 0,
          owner: node,
          nodes: [],
          min: startingMin(executableIndex),
          max: startingMax(executableIndex)
        },
        result = [currentSegment],
        lastMax = defaultMax,
        orderedChildSegments = orderChildSegments(orderedChildren);

      function isSegmentBoundary(minIndex) {
        return (
          lastMax !== defaultMax &&
          minIndex !== defaultMin &&
          lastMax < minIndex - 1
        );
      }

      for (var i = 0; i < orderedChildSegments.length; i++) {
        var childSegment = orderedChildSegments[i],
          maxIndex = childSegment.max,
          minIndex = childSegment.min;

        if (isSegmentBoundary(minIndex)) {
          currentSegment = {
            index: result.length,
            owner: node,
            nodes: [],
            min: defaultMin,
            max: defaultMax
          };
          result.push(currentSegment);
        }

        currentSegment.nodes.push(childSegment);
        currentSegment.min = Math.min(currentSegment.min, minIndex);
        currentSegment.max = Math.max(currentSegment.max, maxIndex);
        lastMax = maxIndex;
      }

      nodeStats.segments = result;
    }

    function orderChildSegments(children) {
      var specifiedOrder = [],
        unspecifiedOrder = [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i],
          segments = stats[child.id].segments;

        for (var j = 0; j < segments.length; j++) {
          var seg = segments[j];

          if (seg.min === defaultMin) {
            unspecifiedOrder.push(seg);
          } else {
            specifiedOrder.push(seg);
          }
        }
      }

      specifiedOrder.sort(function(a, b) {
        return a.min - b.min;
      });

      return specifiedOrder.concat(unspecifiedOrder);
    }

    function executeNode(node, segmentNumber) {
      if (node.children) {
        return {
          fn: function(done) {
            var onStart = {
              fn: function(next) {
                nodeStart(node, next);
              }
            };

            queueRunnerFactory({
              onComplete: function() {
                var args = Array.prototype.slice.call(arguments, [0]);
                node.cleanupBeforeAfter();
                nodeComplete(node, node.getResult(), function() {
                  done.apply(undefined, args);
                });
              },
              queueableFns: [onStart].concat(wrapChildren(node, segmentNumber)),
              userContext: node.sharedUserContext(),
              onException: function() {
                node.onException.apply(node, arguments);
              }
            });
          }
        };
      } else {
        return {
          fn: function(done) {
            node.execute(
              done,
              stats[node.id].excluded,
              failSpecWithNoExpectations
            );
          }
        };
      }
    }

    function wrapChildren(node, segmentNumber) {
      var result = [],
        segmentChildren = stats[node.id].segments[segmentNumber].nodes;

      for (var i = 0; i < segmentChildren.length; i++) {
        result.push(
          executeNode(segmentChildren[i].owner, segmentChildren[i].index)
        );
      }

      if (!stats[node.id].willExecute) {
        return result;
      }

      return node.beforeAllFns.concat(result).concat(node.afterAllFns);
    }
  }

  return TreeProcessor;
};

getJasmineRequireObj().UserContext = function(j$) {
  function UserContext() {}

  UserContext.fromExisting = function(oldContext) {
    var context = new UserContext();

    for (var prop in oldContext) {
      if (oldContext.hasOwnProperty(prop)) {
        context[prop] = oldContext[prop];
      }
    }

    return context;
  };

  return UserContext;
};

getJasmineRequireObj().version = function() {
  return '3.6.0';
};

        </script>
        <script type="text/javascript">
        /*
Copyright (c) 2008-2020 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var jasmineRequire = window.jasmineRequire || require('./jasmine.js');

jasmineRequire.html = function(j$) {
  j$.ResultsNode = jasmineRequire.ResultsNode();
  j$.HtmlReporter = jasmineRequire.HtmlReporter(j$);
  j$.QueryString = jasmineRequire.QueryString();
  j$.HtmlSpecFilter = jasmineRequire.HtmlSpecFilter();
};

jasmineRequire.HtmlReporter = function(j$) {
  function ResultsStateBuilder() {
    this.topResults = new j$.ResultsNode({}, '', null);
    this.currentParent = this.topResults;
    this.specsExecuted = 0;
    this.failureCount = 0;
    this.pendingSpecCount = 0;
  }

  ResultsStateBuilder.prototype.suiteStarted = function(result) {
    this.currentParent.addChild(result, 'suite');
    this.currentParent = this.currentParent.last();
  };

  ResultsStateBuilder.prototype.suiteDone = function(result) {
    this.currentParent.updateResult(result);
    if (this.currentParent !== this.topResults) {
      this.currentParent = this.currentParent.parent;
    }

    if (result.status === 'failed') {
      this.failureCount++;
    }
  };

  ResultsStateBuilder.prototype.specStarted = function(result) {};

  ResultsStateBuilder.prototype.specDone = function(result) {
    this.currentParent.addChild(result, 'spec');

    if (result.status !== 'excluded') {
      this.specsExecuted++;
    }

    if (result.status === 'failed') {
      this.failureCount++;
    }

    if (result.status == 'pending') {
      this.pendingSpecCount++;
    }
  };

  function HtmlReporter(options) {
    var config = function() {
        return (options.env && options.env.configuration()) || {};
      },
      getContainer = options.getContainer,
      createElement = options.createElement,
      createTextNode = options.createTextNode,
      navigateWithNewParam = options.navigateWithNewParam || function() {},
      addToExistingQueryString =
        options.addToExistingQueryString || defaultQueryString,
      filterSpecs = options.filterSpecs,
      htmlReporterMain,
      symbols,
      deprecationWarnings = [];

    this.initialize = function() {
      clearPrior();
      htmlReporterMain = createDom(
        'div',
        { className: 'jasmine_html-reporter' },
        createDom(
          'div',
          { className: 'jasmine-banner' },
          createDom('a', {
            className: 'jasmine-title',
            href: 'http://jasmine.github.io/',
            target: '_blank'
          }),
          createDom('span', { className: 'jasmine-version' }, j$.version)
        ),
        createDom('ul', { className: 'jasmine-symbol-summary' }),
        createDom('div', { className: 'jasmine-alert' }),
        createDom(
          'div',
          { className: 'jasmine-results' },
          createDom('div', { className: 'jasmine-failures' })
        )
      );
      getContainer().appendChild(htmlReporterMain);
    };

    var totalSpecsDefined;
    this.jasmineStarted = function(options) {
      totalSpecsDefined = options.totalSpecsDefined || 0;
    };

    var summary = createDom('div', { className: 'jasmine-summary' });

    var stateBuilder = new ResultsStateBuilder();

    this.suiteStarted = function(result) {
      stateBuilder.suiteStarted(result);
    };

    this.suiteDone = function(result) {
      stateBuilder.suiteDone(result);

      if (result.status === 'failed') {
        failures.push(failureDom(result));
      }
      addDeprecationWarnings(result);
    };

    this.specStarted = function(result) {
      stateBuilder.specStarted(result);
    };

    var failures = [];
    this.specDone = function(result) {
      stateBuilder.specDone(result);

      if (noExpectations(result)) {
        var noSpecMsg = "Spec '" + result.fullName + "' has no expectations.";
        if (result.status === 'failed') {
          console.error(noSpecMsg);
        } else {
          console.warn(noSpecMsg);
        }
      }

      if (!symbols) {
        symbols = find('.jasmine-symbol-summary');
      }

      symbols.appendChild(
        createDom('li', {
          className: this.displaySpecInCorrectFormat(result),
          id: 'spec_' + result.id,
          title: result.fullName
        })
      );

      if (result.status === 'failed') {
        failures.push(failureDom(result));
      }

      addDeprecationWarnings(result);
    };

    this.displaySpecInCorrectFormat = function(result) {
      return noExpectations(result) && result.status === 'passed'
        ? 'jasmine-empty'
        : this.resultStatus(result.status);
    };

    this.resultStatus = function(status) {
      if (status === 'excluded') {
        return config().hideDisabled
          ? 'jasmine-excluded-no-display'
          : 'jasmine-excluded';
      }
      return 'jasmine-' + status;
    };

    this.jasmineDone = function(doneResult) {
      var banner = find('.jasmine-banner');
      var alert = find('.jasmine-alert');
      var order = doneResult && doneResult.order;
      var i;
      alert.appendChild(
        createDom(
          'span',
          { className: 'jasmine-duration' },
          'finished in ' + doneResult.totalTime / 1000 + 's'
        )
      );

      banner.appendChild(optionsMenu(config()));

      if (stateBuilder.specsExecuted < totalSpecsDefined) {
        var skippedMessage =
          'Ran ' +
          stateBuilder.specsExecuted +
          ' of ' +
          totalSpecsDefined +
          ' specs - run all';
        var skippedLink = addToExistingQueryString('spec', '');
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-bar jasmine-skipped' },
            createDom(
              'a',
              { href: skippedLink, title: 'Run all specs' },
              skippedMessage
            )
          )
        );
      }
      var statusBarMessage = '';
      var statusBarClassName = 'jasmine-overall-result jasmine-bar ';
      var globalFailures = (doneResult && doneResult.failedExpectations) || [];
      var failed = stateBuilder.failureCount + globalFailures.length > 0;

      if (totalSpecsDefined > 0 || failed) {
        statusBarMessage +=
          pluralize('spec', stateBuilder.specsExecuted) +
          ', ' +
          pluralize('failure', stateBuilder.failureCount);
        if (stateBuilder.pendingSpecCount) {
          statusBarMessage +=
            ', ' + pluralize('pending spec', stateBuilder.pendingSpecCount);
        }
      }

      if (doneResult.overallStatus === 'passed') {
        statusBarClassName += ' jasmine-passed ';
      } else if (doneResult.overallStatus === 'incomplete') {
        statusBarClassName += ' jasmine-incomplete ';
        statusBarMessage =
          'Incomplete: ' +
          doneResult.incompleteReason +
          ', ' +
          statusBarMessage;
      } else {
        statusBarClassName += ' jasmine-failed ';
      }

      var seedBar;
      if (order && order.random) {
        seedBar = createDom(
          'span',
          { className: 'jasmine-seed-bar' },
          ', randomized with seed ',
          createDom(
            'a',
            {
              title: 'randomized with seed ' + order.seed,
              href: seedHref(order.seed)
            },
            order.seed
          )
        );
      }

      alert.appendChild(
        createDom(
          'span',
          { className: statusBarClassName },
          statusBarMessage,
          seedBar
        )
      );

      var errorBarClassName = 'jasmine-bar jasmine-errored';
      var afterAllMessagePrefix = 'AfterAll ';

      for (i = 0; i < globalFailures.length; i++) {
        alert.appendChild(
          createDom(
            'span',
            { className: errorBarClassName },
            globalFailureMessage(globalFailures[i])
          )
        );
      }

      function globalFailureMessage(failure) {
        if (failure.globalErrorType === 'load') {
          var prefix = 'Error during loading: ' + failure.message;

          if (failure.filename) {
            return (
              prefix + ' in ' + failure.filename + ' line ' + failure.lineno
            );
          } else {
            return prefix;
          }
        } else {
          return afterAllMessagePrefix + failure.message;
        }
      }

      addDeprecationWarnings(doneResult);

      var warningBarClassName = 'jasmine-bar jasmine-warning';
      for (i = 0; i < deprecationWarnings.length; i++) {
        var warning = deprecationWarnings[i];
        alert.appendChild(
          createDom(
            'span',
            { className: warningBarClassName },
            'DEPRECATION: ' + warning
          )
        );
      }

      var results = find('.jasmine-results');
      results.appendChild(summary);

      summaryList(stateBuilder.topResults, summary);

      if (failures.length) {
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-menu jasmine-bar jasmine-spec-list' },
            createDom('span', {}, 'Spec List | '),
            createDom(
              'a',
              { className: 'jasmine-failures-menu', href: '#' },
              'Failures'
            )
          )
        );
        alert.appendChild(
          createDom(
            'span',
            { className: 'jasmine-menu jasmine-bar jasmine-failure-list' },
            createDom(
              'a',
              { className: 'jasmine-spec-list-menu', href: '#' },
              'Spec List'
            ),
            createDom('span', {}, ' | Failures ')
          )
        );

        find('.jasmine-failures-menu').onclick = function() {
          setMenuModeTo('jasmine-failure-list');
          return false;
        };
        find('.jasmine-spec-list-menu').onclick = function() {
          setMenuModeTo('jasmine-spec-list');
          return false;
        };

        setMenuModeTo('jasmine-failure-list');

        var failureNode = find('.jasmine-failures');
        for (i = 0; i < failures.length; i++) {
          failureNode.appendChild(failures[i]);
        }
      }
    };

    return this;

    function failureDom(result) {
      var failure = createDom(
        'div',
        { className: 'jasmine-spec-detail jasmine-failed' },
        failureDescription(result, stateBuilder.currentParent),
        createDom('div', { className: 'jasmine-messages' })
      );
      var messages = failure.childNodes[1];

      for (var i = 0; i < result.failedExpectations.length; i++) {
        var expectation = result.failedExpectations[i];
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-result-message' },
            expectation.message
          )
        );
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-stack-trace' },
            expectation.stack
          )
        );
      }

      if (result.failedExpectations.length === 0) {
        messages.appendChild(
          createDom(
            'div',
            { className: 'jasmine-result-message' },
            'Spec has no expectations'
          )
        );
      }

      return failure;
    }

    function summaryList(resultsTree, domParent) {
      var specListNode;
      for (var i = 0; i < resultsTree.children.length; i++) {
        var resultNode = resultsTree.children[i];
        if (filterSpecs && !hasActiveSpec(resultNode)) {
          continue;
        }
        if (resultNode.type === 'suite') {
          var suiteListNode = createDom(
            'ul',
            { className: 'jasmine-suite', id: 'suite-' + resultNode.result.id },
            createDom(
              'li',
              {
                className:
                  'jasmine-suite-detail jasmine-' + resultNode.result.status
              },
              createDom(
                'a',
                { href: specHref(resultNode.result) },
                resultNode.result.description
              )
            )
          );

          summaryList(resultNode, suiteListNode);
          domParent.appendChild(suiteListNode);
        }
        if (resultNode.type === 'spec') {
          if (domParent.getAttribute('class') !== 'jasmine-specs') {
            specListNode = createDom('ul', { className: 'jasmine-specs' });
            domParent.appendChild(specListNode);
          }
          var specDescription = resultNode.result.description;
          if (noExpectations(resultNode.result)) {
            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;
          }
          if (
            resultNode.result.status === 'pending' &&
            resultNode.result.pendingReason !== ''
          ) {
            specDescription =
              specDescription +
              ' PENDING WITH MESSAGE: ' +
              resultNode.result.pendingReason;
          }
          specListNode.appendChild(
            createDom(
              'li',
              {
                className: 'jasmine-' + resultNode.result.status,
                id: 'spec-' + resultNode.result.id
              },
              createDom(
                'a',
                { href: specHref(resultNode.result) },
                specDescription
              )
            )
          );
        }
      }
    }

    function optionsMenu(config) {
      var optionsMenuDom = createDom(
        'div',
        { className: 'jasmine-run-options' },
        createDom('span', { className: 'jasmine-trigger' }, 'Options'),
        createDom(
          'div',
          { className: 'jasmine-payload' },
          createDom(
            'div',
            { className: 'jasmine-stop-on-failure' },
            createDom('input', {
              className: 'jasmine-fail-fast',
              id: 'jasmine-fail-fast',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-fail-fast' },
              'stop execution on spec failure'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-throw-failures' },
            createDom('input', {
              className: 'jasmine-throw',
              id: 'jasmine-throw-failures',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-throw-failures' },
              'stop spec on expectation failure'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-random-order' },
            createDom('input', {
              className: 'jasmine-random',
              id: 'jasmine-random-order',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-random-order' },
              'run tests in random order'
            )
          ),
          createDom(
            'div',
            { className: 'jasmine-hide-disabled' },
            createDom('input', {
              className: 'jasmine-disabled',
              id: 'jasmine-hide-disabled',
              type: 'checkbox'
            }),
            createDom(
              'label',
              { className: 'jasmine-label', for: 'jasmine-hide-disabled' },
              'hide disabled tests'
            )
          )
        )
      );

      var failFastCheckbox = optionsMenuDom.querySelector('#jasmine-fail-fast');
      failFastCheckbox.checked = config.failFast;
      failFastCheckbox.onclick = function() {
        navigateWithNewParam('failFast', !config.failFast);
      };

      var throwCheckbox = optionsMenuDom.querySelector(
        '#jasmine-throw-failures'
      );
      throwCheckbox.checked = config.oneFailurePerSpec;
      throwCheckbox.onclick = function() {
        navigateWithNewParam('throwFailures', !config.oneFailurePerSpec);
      };

      var randomCheckbox = optionsMenuDom.querySelector(
        '#jasmine-random-order'
      );
      randomCheckbox.checked = config.random;
      randomCheckbox.onclick = function() {
        navigateWithNewParam('random', !config.random);
      };

      var hideDisabled = optionsMenuDom.querySelector('#jasmine-hide-disabled');
      hideDisabled.checked = config.hideDisabled;
      hideDisabled.onclick = function() {
        navigateWithNewParam('hideDisabled', !config.hideDisabled);
      };

      var optionsTrigger = optionsMenuDom.querySelector('.jasmine-trigger'),
        optionsPayload = optionsMenuDom.querySelector('.jasmine-payload'),
        isOpen = /\bjasmine-open\b/;

      optionsTrigger.onclick = function() {
        if (isOpen.test(optionsPayload.className)) {
          optionsPayload.className = optionsPayload.className.replace(
            isOpen,
            ''
          );
        } else {
          optionsPayload.className += ' jasmine-open';
        }
      };

      return optionsMenuDom;
    }

    function failureDescription(result, suite) {
      var wrapper = createDom(
        'div',
        { className: 'jasmine-description' },
        createDom(
          'a',
          { title: result.description, href: specHref(result) },
          result.description
        )
      );
      var suiteLink;

      while (suite && suite.parent) {
        wrapper.insertBefore(createTextNode(' > '), wrapper.firstChild);
        suiteLink = createDom(
          'a',
          { href: suiteHref(suite) },
          suite.result.description
        );
        wrapper.insertBefore(suiteLink, wrapper.firstChild);

        suite = suite.parent;
      }

      return wrapper;
    }

    function suiteHref(suite) {
      var els = [];

      while (suite && suite.parent) {
        els.unshift(suite.result.description);
        suite = suite.parent;
      }

      return addToExistingQueryString('spec', els.join(' '));
    }

    function addDeprecationWarnings(result) {
      if (result && result.deprecationWarnings) {
        for (var i = 0; i < result.deprecationWarnings.length; i++) {
          var warning = result.deprecationWarnings[i].message;
          if (!j$.util.arrayContains(warning)) {
            deprecationWarnings.push(warning);
          }
        }
      }
    }

    function find(selector) {
      return getContainer().querySelector('.jasmine_html-reporter ' + selector);
    }

    function clearPrior() {
      // return the reporter
      var oldReporter = find('');

      if (oldReporter) {
        getContainer().removeChild(oldReporter);
      }
    }

    function createDom(type, attrs, childrenVarArgs) {
      var el = createElement(type);

      for (var i = 2; i < arguments.length; i++) {
        var child = arguments[i];

        if (typeof child === 'string') {
          el.appendChild(createTextNode(child));
        } else {
          if (child) {
            el.appendChild(child);
          }
        }
      }

      for (var attr in attrs) {
        if (attr == 'className') {
          el[attr] = attrs[attr];
        } else {
          el.setAttribute(attr, attrs[attr]);
        }
      }

      return el;
    }

    function pluralize(singular, count) {
      var word = count == 1 ? singular : singular + 's';

      return '' + count + ' ' + word;
    }

    function specHref(result) {
      return addToExistingQueryString('spec', result.fullName);
    }

    function seedHref(seed) {
      return addToExistingQueryString('seed', seed);
    }

    function defaultQueryString(key, value) {
      return '?' + key + '=' + value;
    }

    function setMenuModeTo(mode) {
      htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);
    }

    function noExpectations(result) {
      var allExpectations =
        result.failedExpectations.length + result.passedExpectations.length;

      return (
        allExpectations === 0 &&
        (result.status === 'passed' || result.status === 'failed')
      );
    }

    function hasActiveSpec(resultNode) {
      if (resultNode.type == 'spec' && resultNode.result.status != 'excluded') {
        return true;
      }

      if (resultNode.type == 'suite') {
        for (var i = 0, j = resultNode.children.length; i < j; i++) {
          if (hasActiveSpec(resultNode.children[i])) {
            return true;
          }
        }
      }
    }
  }

  return HtmlReporter;
};

jasmineRequire.HtmlSpecFilter = function() {
  function HtmlSpecFilter(options) {
    var filterString =
      options &&
      options.filterString() &&
      options.filterString().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    var filterPattern = new RegExp(filterString);

    this.matches = function(specName) {
      return filterPattern.test(specName);
    };
  }

  return HtmlSpecFilter;
};

jasmineRequire.ResultsNode = function() {
  function ResultsNode(result, type, parent) {
    this.result = result;
    this.type = type;
    this.parent = parent;

    this.children = [];

    this.addChild = function(result, type) {
      this.children.push(new ResultsNode(result, type, this));
    };

    this.last = function() {
      return this.children[this.children.length - 1];
    };

    this.updateResult = function(result) {
      this.result = result;
    };
  }

  return ResultsNode;
};

jasmineRequire.QueryString = function() {
  function QueryString(options) {
    this.navigateWithNewParam = function(key, value) {
      options.getWindowLocation().search = this.fullStringWithNewParam(
        key,
        value
      );
    };

    this.fullStringWithNewParam = function(key, value) {
      var paramMap = queryStringToParamMap();
      paramMap[key] = value;
      return toQueryString(paramMap);
    };

    this.getParam = function(key) {
      return queryStringToParamMap()[key];
    };

    return this;

    function toQueryString(paramMap) {
      var qStrPairs = [];
      for (var prop in paramMap) {
        qStrPairs.push(
          encodeURIComponent(prop) + '=' + encodeURIComponent(paramMap[prop])
        );
      }
      return '?' + qStrPairs.join('&');
    }

    function queryStringToParamMap() {
      var paramStr = options.getWindowLocation().search.substring(1),
        params = [],
        paramMap = {};

      if (paramStr.length > 0) {
        params = paramStr.split('&');
        for (var i = 0; i < params.length; i++) {
          var p = params[i].split('=');
          var value = decodeURIComponent(p[1]);
          if (value === 'true' || value === 'false') {
            value = JSON.parse(value);
          }
          paramMap[decodeURIComponent(p[0])] = value;
        }
      }

      return paramMap;
    }
  }

  return QueryString;
};

        </script>
        <script type="text/javascript">
        /**
 Starting with version 2.0, this file "boots" Jasmine, performing all of the necessary initialization before executing the loaded environment and all of a project's specs. This file should be loaded after `jasmine.js` and `jasmine_html.js`, but before any project source files or spec files are loaded. Thus this file can also be used to customize Jasmine for a project.

 If a project is using Jasmine via the standalone distribution, this file can be customized directly. If a project is using Jasmine via the [Ruby gem][jasmine-gem], this file can be copied into the support directory via `jasmine copy_boot_js`. Other environments (e.g., Python) will have different mechanisms.

 The location of `boot.js` can be specified and/or overridden in `jasmine.yml`.

 [jasmine-gem]: http://github.com/pivotal/jasmine-gem
 */

(function() {
  var jasmineRequire = window.jasmineRequire || require('./jasmine.js');

  /**
   * ## Require &amp; Instantiate
   *
   * Require Jasmine's core files. Specifically, this requires and attaches all of Jasmine's code to the `jasmine` reference.
   */
  var jasmine = jasmineRequire.core(jasmineRequire),
    global = jasmine.getGlobal();
  global.jasmine = jasmine;

  /**
   * Since this is being run in a browser and the results should populate to an HTML page, require the HTML-specific Jasmine code, injecting the same reference.
   */
  jasmineRequire.html(jasmine);

  /**
   * Create the Jasmine environment. This is used to run all specs in a project.
   */
  var env = jasmine.getEnv();

  /**
   * ## The Global Interface
   *
   * Build up the functions that will be exposed as the Jasmine public interface. A project can customize, rename or alias any of these functions as desired, provided the implementation remains unchanged.
   */
  var jasmineInterface = jasmineRequire.interface(jasmine, env);

  /**
   * Add all of the Jasmine global/public interface to the global scope, so a project can use the public interface directly. For example, calling `describe` in specs instead of `jasmine.getEnv().describe`.
   */
  extend(global, jasmineInterface);

  /**
   * ## Runner Parameters
   *
   * More browser specific code - wrap the query string in an object and to allow for getting/setting parameters from the runner user interface.
   */

  var queryString = new jasmine.QueryString({
    getWindowLocation: function() { return window.location; }
  });

  var filterSpecs = !!queryString.getParam("spec");

  var config = {
    failFast: queryString.getParam("failFast"),
    oneFailurePerSpec: queryString.getParam("oneFailurePerSpec"),
    hideDisabled: queryString.getParam("hideDisabled")
  };

  var random = queryString.getParam("random");

  if (random !== undefined && random !== "") {
    config.random = random;
  }

  var seed = queryString.getParam("seed");
  if (seed) {
    config.seed = seed;
  }

  /**
   * ## Reporters
   * The `HtmlReporter` builds all of the HTML UI for the runner page. This reporter paints the dots, stars, and x's for specs, as well as all spec names and all failures (if any).
   */
  var htmlReporter = new jasmine.HtmlReporter({
    env: env,
    navigateWithNewParam: function(key, value) { return queryString.navigateWithNewParam(key, value); },
    addToExistingQueryString: function(key, value) { return queryString.fullStringWithNewParam(key, value); },
    getContainer: function() { return document.body; },
    createElement: function() { return document.createElement.apply(document, arguments); },
    createTextNode: function() { return document.createTextNode.apply(document, arguments); },
    timer: new jasmine.Timer(),
    filterSpecs: filterSpecs
  });

  /**
   * The `jsApiReporter` also receives spec results, and is used by any environment that needs to extract the results  from JavaScript.
   */
  env.addReporter(jasmineInterface.jsApiReporter);
  env.addReporter(htmlReporter);

  /**
   * Filter which specs will be run by matching the start of the full name against the `spec` query param.
   */
  var specFilter = new jasmine.HtmlSpecFilter({
    filterString: function() { return queryString.getParam("spec"); }
  });

  config.specFilter = function(spec) {
    return specFilter.matches(spec.getFullName());
  };

  env.configure(config);

  /**
   * Setting up timing functions to be able to be overridden. Certain browsers (Safari, IE 8, phantomjs) require this hack.
   */
  window.setTimeout = window.setTimeout;
  window.setInterval = window.setInterval;
  window.clearTimeout = window.clearTimeout;
  window.clearInterval = window.clearInterval;

  /**
   * ## Execution
   *
   * Replace the browser window's `onload`, ensure it's called, and then run all of the loaded specs. This includes initializing the `HtmlReporter` instance and then executing the loaded Jasmine environment. All of this will happen after all of the specs are loaded.
   */
  var currentWindowOnload = window.onload;

  window.onload = function() {
    if (currentWindowOnload) {
      currentWindowOnload();
    }
    htmlReporter.initialize();
    env.execute();
  };

  /**
   * Helper function for readability above.
   */
  function extend(destination, source) {
    for (var property in source) destination[property] = source[property];
    return destination;
  }

}());

        </script>
        <script type="text/javascript">
            
describe('dmbButton Directive', () => {
    let element = null;
    let container = null;
    
    container = document.querySelector('#components');
    element = document.createElement('dmb-button');
    element.classList.add('button');
    element.classList.add('button-primary');
    container.append(element);

    afterEach( done => {
        element && element.remove();
        done();
    });

    it('Should render element', (done) => {
        expect(element).toBeDefined();
        done();
    });

});
describe('DmbForm Directive', () => {
    let element = null;
    let select = null;
    let button = null;
    let inputs = null;
    let textarea = null;
    let container = null;

    let input = null;

    element = document.createElement('dmb-form');
    select = document.createElement('dmb-select');
    button = document.createElement('dmb-button');
    inputs = document.createElement('dmb-input');
    textarea = document.createElement('dmb-text-area');
    container = document.querySelector('#components');
    
    container.append(element);

    select.setAttribute('validate', 'required');
    inputs.setAttribute('validate', 'required');
    textarea.setAttribute('validate', 'required');
    button.classList.add('button');
    button.classList.add('button-primary');
    button.innerHTML = 'TestForm';


    inputs.setAttribute('label', 'label');
    element.append(inputs);
    element.append(select);
    element.append(textarea);
    
    button.setAttribute('type','submit');
    element.append(button);
    
    
    select.setAttribute('values', true);
    select.value = null;

    select.values = [
        {value: '', text: 'Seleccione', selected: true},
        {value: '1', text: 'Laboral'},
        {value: '2', text: 'Pension'},
        {value: '3', text: 'Accidente'}
    ];

    afterEach( done => {
        element && element.remove();
        done();
    });

    beforeEach((done) => {
        inputs.value = '';
        select.value = null;
        input = inputs.querySelector('input');
        done();
    });

    it('Should render element', (done) => {
        expect(element).toBeDefined();
        done();
    });
    
    it('Should validate', (done) => {
        element.submit();
        expect(element.valids).toBe(0);
        done();
    });

    it('Should have valid inputs', (done) => {
        inputs.value = 'value';
        element.submit();
        expect(element.valids).toBe(1);
        done();
    });
});
describe('DmbImageUploader Directive', () => {
    let element = null;
    // eslint-disable-next-line no-unused-vars
    let loadFile = null; // this var is actually used for spy purposes
    let container = null;

    const contentType = 'image/png';
    const img1px = 'iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==';

    element = document.createElement('dmb-image-uploader');
    container = document.querySelector('#components');
    container.append(element);

    const dataURLtoFile = (b64Data, contentType='', sliceSize=512) => {
        const byteCharacters = atob(b64Data);
        const byteArrays = [];
    
        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
            const slice = byteCharacters.slice(offset, offset + sliceSize);
        
            const byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
        
            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        const blob = new Blob(byteArrays, {type: contentType});
        return blob;
    };
  
    const imgFile = dataURLtoFile(img1px, contentType);

    afterEach( done => {
        element && element.remove();
        done();
    });

    it('Should render element', (done) => {
        expect(element).toBeDefined();
        done();
    });

    loadFile = function(target) {
        console.log(`trying to send data to ${target}`);
    };

    it('Should check if element was render', (done) => {
        spyOn(element, 'loadFile');
        element.querySelector('input[type="file"]').dispatchEvent(new Event('change'));
        expect(element.loadFile).toHaveBeenCalled();
        done();
    });

    it('Should load the image in content preview', (done) => {
        const previewimg = element.querySelector('.preview img');
        previewimg.src = '';
        element.loadFile(imgFile).then(() => {
            expect(previewimg.getAttribute('src')).toBe(`data:image/png;base64,${img1px}`);
            done();
        });
    });
});

describe('DmbInput Directive', () => {
    let element = null;
    let input = null;
    let container = null;
    
    element = document.createElement('dmb-input');
    container = document.querySelector('#components');
    element.setAttribute('label', 'label');
    container.append(element);
    
    afterEach( done => {
        element && element.remove();
        done();
    });
    
    beforeAll((done) => {
        input = element.querySelector('input');
        done();
    });
    
    it('Should render element', (done) => {
        expect(element).toBeDefined();
        done();
    });

    it('Should have label', (done) => {
        const label = element.querySelector('label');
        expect(label).toBeDefined();
        done();
    });

    it('Should have input text', (done) => {
        expect(input).toBeDefined();
        done();
    });

    it('Should validate required', (done) => {
        element.setAttribute('validate', 'required');
        input.value = null;
        input.dispatchEvent(new Event('focusin'));
        input.dispatchEvent(new Event('blur'));
        expect(input.hasAttribute('valid')).toBe(false);
        input.value = 'a value';
        input.dispatchEvent(new Event('focusin'));
        input.dispatchEvent(new Event('blur'));
        expect(input.hasAttribute('valid')).toBe(true);
        done();
    });

    it('Should validate email', (done) => {
        element.setAttribute('validate', 'email');
        input.value = 'anything but email address';
        input.dispatchEvent(new Event('focusin'));
        input.dispatchEvent(new Event('blur'));
        expect(input.hasAttribute('valid')).toBe(false);
        done();
    });
});

describe('DmbSelect Directive', () => {
    let element = null;
    let input = null;
    let container = null;
    
    element = document.createElement('dmb-select');
    container = document.querySelector('#components');
    element.setAttribute('label', 'label');
    container.append(element);

    element.setAttribute('values', true);
    element.value = null;

    element.values = [
        {value: '', text: 'Seleccione', selected: true},
        {value: '1', text: 'Laboral'},
        {value: '2', text: 'Pension'},
        {value: '3', text: 'Accidente'}
    ];

    afterEach( done => {
        element && element.remove();
        done();
    });

    beforeAll((done) => {
        input = element.querySelector('select');
        done();
    });
    
    it('Should render element', (done) => {
        expect(element).toBeDefined();
        done();
    });

    it('Should have label', (done) => {
        const label = element.querySelector('label');
        expect(label).toBeDefined();
        done();
    });

    it('Should have select', (done) => {
        expect(input).toBeDefined();
        done();
    });

    it('Should validate required', (done) => {
        element.setAttribute('validate', 'required');
        element.value = '';
        input.dispatchEvent(new Event('focusin'));
        input.dispatchEvent(new Event('blur'));
        expect(input.hasAttribute('valid')).toBe(false);
        element.value = '1';
        input.dispatchEvent(new Event('focusin'));
        input.dispatchEvent(new Event('blur'));
        expect(input.hasAttribute('valid')).toBe(true);
        done();
    });
});
describe('DmbVideoUploader Directive', () => {
    let element = null;
    // eslint-disable-next-line no-unused-vars
    let loadFile = null; // this var is actually used for spy purposes
    let container = null;

    const contentType = 'video/ogg';
    const vid1sec = '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EQAIAAAocAAACLBBU2JxgEJDVgIAUQAABsWxLE0TRZKkaZoniiRJ0zxPFGma53meacLzPM80IYqiaJoQRVE0TZimaaoqME1VFQAAUOAAABBgg6bE4gCFhqwEAEICAByKYlma5nmeJ4qmqZokSdM8TxRF0TRNU1VJkqZ5niiKommapqqyLE3zPFEURdNUVVWFpnmeKIqiaaqq6sLzPE8URdE0VdV14XmeJ4qiaJqq6roQRVE0TdNUTVV1XSCKpmmaqqqqrgtETxRNU1Vd13WB54miaaqqq7ouEE3TVFVVdV1ZBpimaaqq68oyQFVV1XVdV5YBqqqqruu6sgxQVdd1XVmWZQCu67qyLMsCAAAOHAAAAoygk4wqi7DRhAsPQKEhKwKAKAAAwBimFFPKMCYhpBAaxiSEFEImJaXSUqogpFJSKRWEVEoqJaOUUmopVRBSKamUCkIqJZVSAADYgQMA2IGFUGjISgAgDwCAMEYpxhhzTiKkFGPOOScRUoox55yTSjHmnHPOSSkZc8w556SUzjnnnHNSSuacc845KaVzzjnnnJRSSuecc05KKSWEzkEnpZTSOeecEwAAVOAAABBgo8jmBCNBhYasBABSAQAMjmNZmuZ5omialiRpmud5niiapiZJmuZ5nieKqsnzPE8URdE0VZXneZ4oiqJpqirXFUXTNE1VVV2yLIqmaZqq6rowTdNUVdd1XZimaaqq67oubFtVVdV1ZRm2raqq6rqyDFzXdWXZloEsu67s2rIAAPAEBwCgAhtWRzgpGgssNGQlAJABAEAYg5BCCCFlEEIKIYSUUggJAAAYcAAACDChDBQashIASAUAAIyx1lprrbXWQGettdZaa62AzFprrbXWWmuttdZaa6211lJrrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmstpZRSSimllFJKKaWUUkoppZRSSgUA+lU4APg/2LA6wknRWGChISsBgHAAAMAYpRhzDEIppVQIMeacdFRai7FCiDHnJKTUWmzFc85BKCGV1mIsnnMOQikpxVZjUSmEUlJKLbZYi0qho5JSSq3VWIwxqaTWWoutxmKMSSm01FqLMRYjbE2ptdhqq7EYY2sqLbQYY4zFCF9kbC2m2moNxggjWywt1VprMMYY3VuLpbaaizE++NpSLDHWXAAAd4MDAESCjTOsJJ0VjgYXGrISAAgJACAQUooxxhhzzjnnpFKMOeaccw5CCKFUijHGnHMOQgghlIwx5pxzEEIIIYRSSsaccxBCCCGEkFLqnHMQQgghhBBKKZ1zDkIIIYQQQimlgxBCCCGEEEoopaQUQgghhBBCCKmklEIIIYRSQighlZRSCCGEEEIpJaSUUgohhFJCCKGElFJKKYUQQgillJJSSimlEkoJJYQSUikppRRKCCGUUkpKKaVUSgmhhBJKKSWllFJKIYQQSikFAAAcOAAABBhBJxlVFmGjCRcegEJDVgIAZAAAkKKUUiktRYIipRikGEtGFXNQWoqocgxSzalSziDmJJaIMYSUk1Qy5hRCDELqHHVMKQYtlRhCxhik2HJLoXMOAAAAQQCAgJAAAAMEBTMAwOAA4XMQdAIERxsAgCBEZohEw0JweFAJEBFTAUBigkIuAFRYXKRdXECXAS7o4q4DIQQhCEEsDqCABByccMMTb3jCDU7QKSp1IAAAAAAADQDwAACQXAAREdHMYWRobHB0eHyAhIiMkAgAAAAAABkAfAAAJCVAREQ0cxgZGhscHR4fICEiIyQBAIAAAgAAAAAggAAEBAQAAAAAAAIAAAAEBE9nZ1MAAEAAAAAAAAAADe7VXgIAAAB1+v8DDf///////////////8gSkWwO6+v7z5qpoH3vvfe+9tfefexo+/r7/b7z7/vPv+8+/7z7/uH3/bX3vvff9/3vvAffAuvvU+9977wHdeq7gL94+8ff959/l37fe+994+8C/f9uKLVo+9977lfePv+8+/7z7+Gnv7fe+994+8ff6PT733vvfffvG/ee/hTgB1959/3n3/cPv9gGit++vP7wAOwBrW/ePvAaA9w40PT7x94D7wH3hx9+igC/eAaADPvD0+8dgPiPZ25+8dhwOfvA7APvH35pe+gen3j7wHeCNAAAAAPvH352X79X7wAAA37x94D2fe+8fe+997733vvfe+97vvfe+99773u+997733j733vvfe/AQfe+997734Aj733vvfe3O1639r/xMPIgEL9HkiPzijONpjZ/UGJCSfJ+/mGKIG23tUfj+22kEEyBgX3N8jKkD3DseXTSCctNOyPFEZXXx1DTqD7/tPj+z4hoNv1////uz/vkgOF+0/Pxv/1+jqOo5+vj9C6/6hH/wcRt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zyeptttZgAAAYAAAQDkL23f2ahfM9DxD3xLzoiHT3y5j0evRTp6i9JvfOmDqIjaKetgee+mBw+D16KiaH6omAYMRU5WqYn/8AqwD1FIceEXE4OovfHRnb0nU856OFHxQRPjnLoR3freE4dPwmI3uOymmsrzfadmnyKPMV7Ez4H1+BiWI7B5XX0a92U6W11zW+MnnXCYaPIblTPB5Q+8GjkW7O3ycCdv2PE5fO/I/Kv3OQKBoBIwRPodnL9DTsCnkTlw8z4Hg+x8hPYADEAACAlAAIAgASqQCoqBcH33x9lJclf+8vaHkdGEOh7iJj3EdGw6NrY3Ai9euQGSYl8fD0j16S2Fha2uU9nwMOHr76C9g9uevlj6Jg896j08wlh6WmH49wWI9RH18Ovh4eHnU9sfj30tfF9j2er0P09NsF8kT42JFQXyAiJmMCYPnWCv0CgBSOX4JLyfgKNfgAPRr7H4dSH3Pc7PwU0h+CmU7gfjx2wcgUib3x3z1F748c+WfLPwDoZOZ5vWBXLh8r6n4UMBPO54+YCaDuB8dfjPrkntTZv4bcHQ1z4s7sth6BpO/D688bNeksNobh1VnFjdr1vyE7PU9PyA+YCUT5lPgB5Pkez09gaafE+57OSFW24bbhAAIAgQAQoAIKgCCG3FcIlf8gQ2nlqkyFo2C+uHIMpEV6eOFyZ8ejhvW4Z9fbTzAe9OnuSqZC4fQbZPMksU6YevUjAntqie+nmHB5Nh8dI6KJYHr4HV3eh5rA9h84E9nZ1MAAEAGAAAAAAAADe7VXgYAAADCpeCUDf///////////////4YSkWwPc+37z27fe+99x9h97X3gHcv3+33j7wD6vvPv+87+8+9833j76Pq+8+/7z7/vPMg195o7+9977x94++j0p39z733vvff9G6fe+997733n3H3j7x9/3n3uwff959/3n3zd137fe+994+8ff6PT733vvfe+/Vfee+iXUAafePvfe+8fePv8wB2I7c/eAcffoGnr94+8B94T3AAH3gAAAAPvH3gPvKDjQ7AD7x94aboH3+30maVoHegAAv3j3AC+4AAa1p94+/ADvQPvAAAAAfePvH3j7wH3l+8AAfeAAaAfeOwPve7733vvfe+997733vvfe+8fePvfe+997733j733j8BB97733vwIH3vvB97M7XsU6UHhP7xM4i8J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';

    element = document.createElement('dmb-video-uploader');
    container = document.querySelector('#components');
    element.setAttribute('preview', true);
    container.append(element);

    const dataURLtoFile = (b64Data, contentType='', sliceSize=512) => {
        const byteCharacters = atob(b64Data);
        const byteArrays = [];
        let blob = null;
        let slice = null;
        let byteNumbers = null;
        let byteArray = null;
    
        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
            slice = byteCharacters.slice(offset, offset + sliceSize);
        
            byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
        
            byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }

        blob = new Blob(byteArrays, {type: contentType});
        return blob;
    };
  
    const imgFile = dataURLtoFile(vid1sec, contentType);
    let previewvideo = null;

    afterEach( done => {
        element && element.remove();
        done();
    });
    
    beforeAll((done) => {
        previewvideo = element.querySelector('.preview video');
        done();
    });

    it('Should render element', (done) => {
        expect(element).toBeDefined();
        done();
    });

    loadFile = function(target) {
        console.log(`trying to send data to ${target}`);
    };

    it('Should check if video was previewed', (done) => {
        spyOn(element, 'loadFile');
        element.querySelector('input[type="file"]').dispatchEvent(new Event('change'));
        expect(element.loadFile).toHaveBeenCalled();
        done();
    });

    it('Should load the image in content preview', (done) => {
        previewvideo.src = '';
        element.loadFile(imgFile).then(() => {
            expect(previewvideo.getAttribute('src')).toBe(`data:video/ogg;base64,${vid1sec}`);
            done();
        });
    });
});

describe('dmbWYSIWYG Directive', () => {
    let element = null;
    let textarea = null;
    let editarea = null;
    let container = null;

    element = document.createElement('dmb-wysiwyg');
    container = document.querySelector('#components');
    container.append(element);

    afterEach( done => {
        element && element.remove();
        done();
    });

    beforeAll((done) => {
        textarea = element.querySelector('textarea.dmb-wysiwyg__content-content');
        editarea = element.querySelector('section.dmb-wysiwyg__content-content');
        done();
    });

    beforeEach(() => {
        textarea.value = '';
        editarea.innerHTML = '';
    });

    it('Should render element', (done) => {
        expect(element).toBeDefined();
        done();
    });

    it('Should check fields if have data', (done) => {
        element.setAttribute('validate', 'required');
        textarea.value = 'prueba';
        editarea.innerHTML = 'prueba';
        editarea.dispatchEvent(new Event('focusin'));
        editarea.dispatchEvent(new Event('blur'));
        const errMsg = element.querySelector('span.error-container').innerHTML;
        expect(errMsg).toBe('');
        done();
    });

    it('Should sync data from textarea to editarea', (done) => {
        editarea.setAttribute('hidden', true);
        textarea.removeAttribute('hidden');
        editarea.innerHTML = '';
        textarea.value = 'texto';
        element.syncData();
        expect(editarea.innerHTML).toBe('texto');
        done();
    });

    it('Should sync data from editarea to textarea', (done) => {
        textarea.setAttribute('hidden', true);
        editarea.removeAttribute('hidden');
        textarea.value = '';
        editarea.innerHTML = 'texto';
        element.syncData();
        expect(textarea.value).toBe('texto');
        done();
    });

    it('Should validate required in textarea', (done) => {
        element.setAttribute('validate', 'required');
        editarea.setAttribute('hidden',true);
        textarea.removeAttribute('hidden');
        textarea.value = null;
        textarea.dispatchEvent(new Event('focusin'));
        textarea.dispatchEvent(new Event('blur'));
        const errMsg = element.querySelector('span.error-container').innerHTML;
        expect(errMsg).toBe('Este campo es obligatorio');
        done();
    });

    it('Should validate required in editarea', (done) => {
        element.setAttribute('validate', 'required');
        textarea.setAttribute('hidden',true);
        editarea.removeAttribute('hidden');
        editarea.innerHTML = '';
        editarea.dispatchEvent(new Event('focusin'));
        editarea.dispatchEvent(new Event('blur'));
        const errMsg = element.querySelector('span.error-container').innerHTML;
        expect(errMsg).toBe('Este campo es obligatorio');
        done();
    });
});

        </script>
</body>
</html>